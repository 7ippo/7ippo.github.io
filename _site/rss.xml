<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tingsven's blog</title>
    <description>What is the purpose of LIFE</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 01 Aug 2019 20:04:22 -0700</pubDate>
    <lastBuildDate>Thu, 01 Aug 2019 20:04:22 -0700</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>一首诗</title>
        <description>&lt;p&gt;你我都是孩子，&lt;/p&gt;

&lt;p&gt;你却像我的影子，&lt;/p&gt;

&lt;p&gt;陪伴是彼此存活的方式，&lt;/p&gt;

&lt;p&gt;也让你我成为彼此最珍贵的，最难以割舍的&lt;/p&gt;

&lt;p&gt;挚友。&lt;/p&gt;

&lt;p&gt;热切的讨论让我们忘了明天，&lt;/p&gt;

&lt;p&gt;嬉笑和打闹留在了这个房间，&lt;/p&gt;

&lt;p&gt;以至于分别时会止不住想念。&lt;/p&gt;

&lt;p&gt;过了多少日子依然会想起，&lt;/p&gt;

&lt;p&gt;和你认识是在南京湛蓝清澈的秋天。&lt;/p&gt;

&lt;p&gt;或许是从那时起，&lt;/p&gt;

&lt;p&gt;我便不再像年轻时一样空谈往后，&lt;/p&gt;

&lt;p&gt;而是知道了余生漫漫，道阻且长。&lt;/p&gt;

&lt;p&gt;不过有你，路走起来也不那么苦涩，&lt;/p&gt;

&lt;p&gt;因为你一笑啊，&lt;/p&gt;

&lt;p&gt;我就拥有了整个世界。&lt;/p&gt;

&lt;p&gt;近来托朋友给你带了香榭的落叶，&lt;/p&gt;

&lt;p&gt;又计划着和你去远方看碧草蓝天。&lt;/p&gt;

&lt;p&gt;心有所想，若有所思&lt;/p&gt;

&lt;p&gt;全系着你的影子。&lt;/p&gt;

&lt;p&gt;我最珍爱的挚友，&lt;/p&gt;

&lt;p&gt;你的每一步，也是我丈量自己的样子，&lt;/p&gt;

&lt;p&gt;你活着，就是我存活的方式。&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Aug 2019 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/2019/08/01/%E4%B8%80%E9%A6%96%E8%AF%97.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/01/%E4%B8%80%E9%A6%96%E8%AF%97.html</guid>
        
        <category>随笔</category>
        
        
        <category>lover</category>
        
      </item>
    
      <item>
        <title>浅谈浏览器缓存机制与H5游戏的缓存策略</title>
        <description>&lt;h2&gt;缓存类型&lt;/h2&gt;
&lt;p&gt;HTTP缓存有很多种，广义上分为共享缓存(public)和私有缓存(private)。共享缓存包括代理缓存、网关缓存、CDN、反向代理缓存和负载均衡器等，本文讨论的是私有缓存：浏览器缓存。从H5游戏开发的角度看，如何在解决不同浏览器环境下缓存带来的热更新问题的同时，最大化利用缓存是追求的目标，为此需要了解缓存机制，制定一个合适的缓存策略并验证分析其正确性。&lt;/p&gt;
&lt;h2&gt;先了解浏览器的缓存逻辑&lt;/h2&gt;
&lt;h3&gt;1. 第一次请求&lt;/h3&gt;
&lt;p&gt;第一次请求，因为浏览器没有缓存该内容，所以缓存不会命中。向服务器请求资源返回的响应头中，会有缓存结果和缓存指示(directives)，浏览器将内容和缓存指示一同存入缓存中。&lt;/p&gt;
&lt;h3&gt;2. 第二次请求同样的资源&lt;/h3&gt;
&lt;p&gt;浏览器在缓存中找到该资源的缓存指示，根据指示选择之后的缓存策略。根据是否需要向服务器重新发起HTTP请求，我们可以将缓存过程分为两个部分，分别是强缓存和协商缓存。&lt;/p&gt;
&lt;h4&gt;1)强缓存阶段&lt;/h4&gt;
&lt;p&gt;不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size栏显示from disk cache(从硬盘缓存读取)或from memory cache(从内存缓存读取)。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c3f553ed4f29614.png&quot; alt=&quot;图1，强缓存命中&quot; /&gt;&lt;br /&gt;
强缓存可以通过设置三种 HTTP Header 实现：&lt;code&gt;Expires&lt;/code&gt;，&lt;code&gt;Pragma&lt;/code&gt; 和 &lt;code&gt;Cache-Control&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;Expires: Wed, 19 Jun 2019 15:00:00 GMT&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Expires&lt;/strong&gt; :&lt;br /&gt;
&lt;strong&gt;HTTP/1.0&lt;/strong&gt;的产物，属于HTTP响应的头部字段，值为HTTP Date类型，指定了所请求的资源到期的具体时间。浏览器在下一次请求时会判断本地时间，如果没有超过Expires设置的过期时间，则直接从缓存中读取，否则需要发起HTTP请求。但是需要说明的是，&lt;code&gt;Expires&lt;/code&gt;已经被&lt;code&gt;Cache-Control&lt;/code&gt;替代，如果响应头中存在&lt;code&gt;Cache-Control&lt;/code&gt;控制缓存过期时间的字段，则&lt;code&gt;Expires&lt;/code&gt;会被忽略。P.S. 搭建的HTTP服务器使用的HTTP/1.1协议，抓包没有看到响应中有&lt;code&gt;Expires&lt;/code&gt;字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;Pragma:no-cache&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Pragma&lt;/strong&gt; :&lt;br /&gt;
&lt;strong&gt;HTTP/1.0&lt;/strong&gt;的产物，属于HTTP请求与响应通用的头部字段，只有一个&lt;code&gt;no-cache&lt;/code&gt;命令，行为与&lt;code&gt;Cache-Control: no-cache&lt;/code&gt;一致，优先级低于&lt;code&gt;Cache-Control&lt;/code&gt;。作为请求头时作用是强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行验证，确保返回最新资源(强制刷新时浏览器会在请求头中加入&lt;code&gt;Pragma:no-cache&lt;/code&gt;)。作为响应头时行为不统一，依赖浏览器具体实现，所以该字段不可靠。MDN建议只在需要兼容 &lt;code&gt;HTTP/1.0&lt;/code&gt; 客户端的场合下应用 Pragma 首部。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c9f23dfecd58526.png&quot; alt=&quot;强刷新请求头中的Pragma字段与Cache-Control字段&quot; /&gt;  
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;Cache-control: must-revalidate,no-cache,no-store,no-transform,public,private,proxy-revalidate,max-age=&amp;lt;seconds&amp;gt;,s-maxage=&amp;lt;seconds&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt; :&lt;br /&gt;
&lt;strong&gt;HTTP/1.1&lt;/strong&gt;的产物，属于HTTP请求与响应通用的头部字段,命令可用于控制内容可缓存性、到期时间、是否重新验证和重新加载等。可通过组合命令实现具体的缓存策略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;no-cache&lt;/code&gt;: 作为请求头时同Pragma字段行为一致，强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行验证，确保返回最新资源，强制刷新请求会携带该字段。作为响应头时表现为客户端在使用缓存前需要发送请求验证缓存可用，即跳过强缓存，进行协商缓存。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;: 设置缓存有效的最大周期，超过这个时间缓存被认为过期(单位秒)，需要重新向服务器请求资源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;must-revalidate&lt;/code&gt; :  只能作为响应头字段，指示一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存服务器不能用该资源响应后续请求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public/private&lt;/code&gt;: &lt;code&gt;public&lt;/code&gt;表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，&lt;code&gt;private&lt;/code&gt;表明响应只能被用户缓存，不能作为共享缓存（即代理服务器不能缓存）。&lt;/p&gt;
&lt;p&gt;其他字段含义可参考&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control&quot;&gt;MDN&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;2)协商缓存阶段&lt;/h4&gt;
&lt;p&gt;协商缓存就是强制缓存失效后，浏览器携带缓存指示向服务器发起请求，由服务器根据缓存指示决定是否使用缓存的过程。协商缓存使用的缓存指示存在请求和响应的HTTP头部中，包括&lt;code&gt;响应头Last-Modified/请求头If-Modified-Since&lt;/code&gt;和&lt;code&gt;响应头ETag/请求头If-None-Match&lt;/code&gt;。协商缓存的结果有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;协商缓存失效，服务器返回200和最新资源&lt;/li&gt;
&lt;li&gt;协商缓存有效，服务器返回304 Not Modified，浏览器从缓存中读取对应资源&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;Last-Modified: Wed, 19 Jun 2019 15:00:00 GMT
If-Modified-Since: Wed, 19 Jun 2019 15:00:00 GMT&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Last-Modified/If-Modified-Since&lt;/strong&gt;:&lt;br /&gt;
服务器会在响应头部添加&lt;code&gt;Last-Modified&lt;/code&gt;字段，值为资源在服务器上的最后修改时间。浏览器将该缓存指示同缓存结果一同存入缓存中。浏览器请求资源时，如果存在&lt;code&gt;Last-Modified&lt;/code&gt;字段，会把该值通过&lt;code&gt;If-Modified-Since&lt;/code&gt;字段添加到请求头中。服务器再次收到这个资源请求，会根据&lt;code&gt;If-Modified-Since&lt;/code&gt;中的值与服务器中该资源的最后修改时间对比。如果没有变化，返回304和空的响应体，浏览器直接从缓存读取。如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c40d1e448c35360.png&quot; alt=&quot;Last-Modified Example&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;ETag: W/&amp;quot;2251799814418149-5669-2019-06-18T12:14:19.152Z&amp;quot;
If-None-Match: W/&amp;quot;2251799814418149-5669-2019-06-18T12:14:19.152Z&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ETag/If-None-Match&lt;/strong&gt;:&lt;br /&gt;
&lt;code&gt;ETag&lt;/code&gt;是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。只要资源有变化，&lt;code&gt;ETag&lt;/code&gt;就会重新生成。服务器通过比较客户端传来的&lt;code&gt;If-None-Match&lt;/code&gt;跟自己服务器上该资源的&lt;code&gt;ETag&lt;/code&gt;是否一致来决定返回结果。如果不一致，GET返回200，新资源和新&lt;code&gt;ETag&lt;/code&gt;，一致则返回304 Not Modified。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;ETag与Last-Modified对比&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;精确度上&lt;code&gt;ETag&lt;/code&gt;要优于&lt;code&gt;Last-Modified&lt;/code&gt;。&lt;code&gt;Last-Modified&lt;/code&gt;的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的&lt;code&gt;Last-Modified&lt;/code&gt;其实并没有体现出来修改，但是&lt;code&gt;ETag&lt;/code&gt;每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的&lt;code&gt;Last-Modified&lt;/code&gt;也有可能不一致。&lt;/li&gt;
&lt;li&gt;性能上ETag要逊于&lt;code&gt;Last-Modified&lt;/code&gt;，毕竟&lt;code&gt;Last-Modified&lt;/code&gt;只需要记录时间，而&lt;code&gt;ETag&lt;/code&gt;需要服务器通过算法来计算出一个hash值。&lt;/li&gt;
&lt;li&gt;优先级上服务器校验优先考虑&lt;code&gt;ETag&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;打开页面的方式影响浏览器缓存的使用逻辑&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;地址栏回车：浏览器先查看请求资源有无缓存，无缓存则向服务器请求资源。若该资源有缓存则根据缓存指示采用对应缓存策略。先查找强缓存，强缓存有效则直接使用缓存200(from cache)，强缓存无效则走协商缓存返回304 Not Modified或返回最新资源200&lt;/li&gt;
&lt;li&gt;F5/ctrl+R：刷新页面。仅请求该页面，并跳过强缓存阶段，走协商缓存，所以会向服务器发送协商请求，返回304 Not Modified或返回最新资源200。注意：该页面所引用的资源不会跳过强缓存，且对Chrome而言，在页面通过地址栏回车的方式打开与页面相同URL的行为等同于刷新&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c3ee62087918381.png&quot; alt=&quot;图7：F5刷新逻辑&quot; /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+F5/ctrl+shift+R：强制刷新页面及页面所引用的资源，跳过所有缓存阶段，无论如何都会向服务器发送请求，强制返回最新资源200&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c3f0d7522c59021.png&quot; alt=&quot;图8强刷&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;H5游戏应该选择怎样的缓存策略&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;游戏入口index.html确保不被缓存，游戏依赖的资源文件通过gulp构建工具做版本管理&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每次更新文件内容时，更改文件名加上md5后缀。因为入口引用的资源名称变了，浏览器会直接请求新的资源。当没有变化时，又会直接读取缓存。这一步一些H5游戏引擎如laya已经实现了，通过修改laya的gulp脚本，可以自定义修改构建的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如何确保入口不被缓存？我们可以使用meta标签的&lt;code&gt;http-equiv&lt;/code&gt;属性把content内容添加到HTTP响应的头部信息，但是默认的HTTP服务器(比如自己搭建的node http服务器)不会在响应时根据meta标签来处理头部信息。这种情况下需要通过&lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_headers_module.html&quot;&gt;nginx设置&lt;/a&gt;显示地在请求index.html的响应头中加入这些字段。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--meta标签--&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Cache-Control&amp;quot; content=&amp;quot;no-cache,max-age=0,must-revalidate&amp;quot;&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Expires&amp;quot; content=&amp;quot;0&amp;quot;&amp;gt;  &lt;!--兼容HTTP/1.0--&gt;
&amp;lt;meta http-equiv=&amp;quot;Pragma&amp;quot; content=&amp;quot;no-cache&amp;quot;&amp;gt; &lt;!--兼容HTTP/1.0--&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;// nginx设置
add_header Pragma no-cache;
expires    epoch;

// 注:expires epoch语法等同于设置Expires字段为Thu, 01 Jan 1970 00:00:01 GMT以及Cache-Control字段为no-cache
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c4766e27bf98921.png&quot; alt=&quot;nginx设置后&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*上图为nginx设置应用在&lt;a href=&quot;http://develop.h5game.com/h5client1/web/index.html&quot;&gt;内网H5RPG项目&lt;/a&gt;的结果*&lt;/em&gt;  
&lt;/p&gt;
&lt;h2&gt;不同浏览器环境的表现验证&lt;/h2&gt;
&lt;p&gt;缓存机制的逻辑最终还是由浏览器来实现，部分浏览器不一定严格遵守W3C的规范，为此需要验证不同浏览器环境下我们选择的缓存策略表现。我们选择&lt;a href=&quot;http://develop.h5game.com/h5client1/web/index.html&quot;&gt;内网H5RPG项目&lt;/a&gt;来进行多种浏览器环境的测试。nginx设置如下:&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c7b516a40c14526.jpg&quot; alt=&quot;nginx设置&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;验证方法：&lt;/p&gt;
&lt;p&gt;PC开热点让手机连接，在不同的浏览器环境中测试我们使用的缓存策略，使用Wireshark抓包查看请求和响应。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开/允许使用缓存&lt;/li&gt;
&lt;li&gt;第一次请求资源&lt;/li&gt;
&lt;li&gt;第二次请求资源(&lt;strong&gt;不使用刷新&lt;/strong&gt;)查看是否会向服务器发送请求(检查是否使用强缓存)，只要发送了请求，则使用的协商缓存，达到预期的效果，实现了热更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Chrome&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;: &lt;em&gt;Chrome 74.0.3729.169(Release)(64 bit)&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;是否有请求&lt;/strong&gt;:&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c7e8a6f56d95279.png&quot; alt=&quot;Chrome第二次请求&quot; /&gt;&lt;br /&gt;
&lt;strong&gt;结论&lt;/strong&gt;: 只有两个请求，分别是index.html以及version.json，并且使用协商缓存返回304，其余资源都是直接读取缓存。符合预期。&lt;/p&gt;
&lt;h3&gt;Safari&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;: &lt;em&gt;iPhone 7 iOS 12.2&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;是否有请求&lt;/strong&gt;:&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c812e6e33774720.png&quot; alt=&quot;Safari第二次请求&quot; /&gt;&lt;br /&gt;
&lt;strong&gt;结论&lt;/strong&gt;: 只有两个请求，分别是index.html以及version.json，并且使用协商缓存返回304，其余资源都是直接读取缓存。符合预期。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用iPhone Safari测试，需要关闭无痕模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Wechat Browser&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;: &lt;em&gt;WeChat 7.0.4&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;是否有请求&lt;/strong&gt;:&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c83aee434831989.png&quot; alt=&quot;微信浏览器第二次请求&quot; /&gt;
&lt;strong&gt;结论&lt;/strong&gt;: 同样只有两个请求，并且使用协商缓存返回304，其余资源都是读取缓存。符合预期。&lt;/p&gt;
&lt;h3&gt;X5 Core(TBS) apk&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;: &lt;em&gt;TBS V4.5 43646&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;是否有请求&lt;/strong&gt;:&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c9a3604ea782416.png&quot; alt=&quot;X5内核默认设置不缓存&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*demo默认设置不使用缓存，相当于强刷*&lt;/em&gt;  
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c9a82afa7273901.png&quot; alt=&quot;修改CacheMode后符合预期&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*设置WebView CacheMode后使用协商缓存*&lt;/em&gt;  
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;: X5 WebView默认情况下不使用缓存，所有GET请求都会带上no-cache请求头去获取最新资源，每次进入apk都相当于强制刷新。需要设置&lt;code&gt;CacheMode&lt;/code&gt;，设置后正常走协商缓存，符合预期。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;webSetting.setCacheMode(IX5WebSettings.DEFAULT_CACHE_CAPACITY);&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;最后制作一张流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c9e04485d821258.png&quot; alt=&quot;GET请求浏览器缓存流程图&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ&quot;&gt;HTTP 缓存 - MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/54cc04190252&quot;&gt;深入理解浏览器的缓存机制 - 简书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/pdfrfc/rfc7234.txt.pdf&quot;&gt;Hypertext Transfer Protocol (HTTP/1.1): Caching - RFC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 21 Jun 2019 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/2019/06/21/%E6%B5%85%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8EH5%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/21/%E6%B5%85%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8EH5%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.html</guid>
        
        <category>H5</category>
        
        <category>Cache</category>
        
        
        <category>H5</category>
        
      </item>
    
      <item>
        <title>Unity入门:编写一个2D Roguelike游戏</title>
        <description>&lt;p&gt;跑完了Unity官方的Basic Tutorial Demo后，意犹未尽的下载了一个Tutorial Project Demo:2D Roguelike。跟着官方的&lt;a href=&quot;https://unity3d.com/cn/learn/tutorials/s/2d-roguelike-tutorial&quot;&gt;教程&lt;/a&gt;从头开始做了一个Roguelike类型的2D生存游戏，每一关随机生成地图，食物和敌人。玩家要尽可能到达更高的关数。每天晚上跟着码代码和理解，花了两天时间终于build出来了windows版本的游戏，自己玩了玩还挺有意思，虽然有一个碰撞的bug...不过也算是上手了Unity的编辑器，对游戏这个概念有一个从代码到动画表现上的多层次理解。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c5492e939016.png&quot; alt=&quot;Windows Build&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;对游戏以及Unity一些浅薄的理解&lt;/h2&gt;
&lt;p&gt;对这个游戏以及Unity有了一些浅薄的理解:  
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们看到的游戏中的物体都被看做是一个对象，&lt;strong&gt;GameObject&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象的形态外貌（&lt;strong&gt;Sprite Render&lt;/strong&gt;）由我们赋予，比如人物场景等任何元素的样子。外形是对象的一个属性，我们可以赋值成一些贴图。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象的动画由一帧一帧的图片组成，动画（&lt;strong&gt;Animator&lt;/strong&gt;）也是对象的一个可以被添加的属性，可以被添加移除以达到复用效果的属性更应该被称为组件（&lt;strong&gt;Component&lt;/strong&gt;）。我们可以设置动画播放的快慢，是否连续播放，是否不可被打断等动画效果，也可以通过代码控制动画播放的时机。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于动画有一个有意思的事情，就是动画有限状态机。其负责播放动画，以及在不同动画状态间来回切换。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c55bbff23067.png&quot; alt=&quot;AnimationController&quot; /&gt;&lt;br /&gt;
比如Demo中的主角，当玩家没有指令时，为状态一：这个状态下动画控制器（Animator Controller）就负责循环播放“PlayerIdle”（待机）这个动画，表现是主角一直在“呼吸抖动”&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c55cc8646305.png&quot; alt=&quot;AnimationController2&quot; /&gt;&lt;br /&gt;
当触发被攻击或者破坏墙壁的这两件事件时，代码通过Animator  Controller切换动画状态。被攻击事件时切换到“PlayerChop”状态，预先设定是进入这个状态后播放一次然后退出，所以主角动画表现是被攻击晃了一下，然后又回到“PlayerIdle”这个状态，循环播放待机动画。&lt;br /&gt;
也就是说，动画控制器负责播放动画（包括播放几次，速度快慢，几个动画状态），代码控制怎么在动画状态之间切换，何时进入，何时退出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象组件Component的理解：为了让我们的对象具有某些特性，我们还需要添加一些Component组件，其实际上是让这个对象拥有多一些其他类所拥有的方法和属性。比如这个Demo中，我们把主角和敌人视作可以检测碰撞的刚体，所以都加了Box Collider 2D和Rigidbody 2D两个组件。在控制这两种对象时，我们就可以使用这两种类中的方法来检测碰撞，然后扣取主角的生命值。墙体只检测碰撞来阻止敌人和主角移动，所以都添加Box Collider 2D组件。至于对象之间的互动，何时互动，我们都是通过C#代码来操控的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;地图大小固定是8x8的方块，因为是Roguelike的游戏，墙（可以被主角攻击打碎），敌人，地面上的水果食物都是根据关数在一个范围内随机生成（UnityEngine的Random类），在8x8地图上随机摆放，下一关入口则固定在右上方，主角每一关一开始都出现在左下角。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c57b0dc60751.png&quot; alt=&quot;Game&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个demo还涉及一些简单的UI和音频，分别通过Text类和AudioSource类来实现，通过脚本设置内容，在移动或被攻击的时候去更新内容，字体和颜色等属性可以在Unity中通过Text Component来改，也可以通过脚本GetComponent来修改。&lt;/p&gt;   
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;游戏设计需要面向对象&lt;/h2&gt;
&lt;p&gt;设计这些游戏对象的方法，我们肯定是采用面向对象的编程方法，极大的节省了代码量和维护成本，更好理解对象之间的行为方式。对于这个很简单的Roguelike游戏，我们可以设计这么几个类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GameManager类：用于管理整个游戏基本的初始化，随机地图生成，以及游戏基本逻辑（每个回合敌人都会移动），还有过场动画，角色死亡动画等;&lt;/li&gt;
&lt;li&gt;MovingObject类：考虑到主角和敌人都会移动，可以设计这样一个类，用于解决对象的移动表现（从一个地块到相邻的地块其实动画上可以有很多表现形式，具体怎么表现需要代码决定），是否可以移动（是否遇到障碍了）以及处理对象之间的碰撞关系（设计一个抽象类，由具体类去实现）;&lt;/li&gt;
&lt;li&gt;Player类：继承MovingObject类，处理详细的逻辑，比如向墙壁、食物、敌人移动分别是什么表现，还得检查食物是否小于0（死亡）;&lt;/li&gt;
&lt;li&gt;Enemy类：有点像写AI的移动逻辑了，每个回合什么表现，遇到主角时播放攻击动画等都由这个类控制;&lt;/li&gt;
&lt;li&gt;BoardManager类：地图场景的管理类，具体怎么生成随机地图，怎么生成墙体、食物、敌人，随机位置还不可以重复;&lt;/li&gt;
&lt;li&gt;Wall类：除了周围的碎石，场景中间的石块也是有表现的，可以被击碎，所以也要写一个具体的类来描述这一类对象;&lt;/li&gt;
&lt;li&gt;SoundManager类：管理背景音乐的循环播放。  
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;采用面向对象的编程方法，设计由顶向下，对整体的概念就会非常清晰，可以一点一点实现细节，也不会出现后期发现设计有问题，要推倒重来的情况。如果你思维很健壮，能考虑很多情况和可能性，还可以避免很多bug，亦或者是使很多bug更容易理解。比如这个例子中，只有主角和敌人可以移动，那就设计一个MovingObject的类，把二者通用的属性和方法都写进去，然后单独设计主角和敌人时，只需要继承这个类，实现独有的逻辑即可。  
&lt;/p&gt;
&lt;h2&gt;也只是刚刚入门&lt;/h2&gt;
&lt;p&gt;经过了这么一个demo，基本有了对小型简单游戏的设计理解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有了一个比较好的idea后，能描述出游戏的雏形，核心玩法是什么，特色是什么，实现机制是什么？比如Roguelike，就是地牢生存，特点是随机事件；&lt;/li&gt;
&lt;li&gt;思考如何设计游戏中的对象，和对象间的互动；&lt;/li&gt;
&lt;li&gt;在纸上画出游戏的各个元素，动画，原型，音效，用代码合理的组织起来；&lt;/li&gt;
&lt;li&gt;通过代码实现具体表现。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 28 Nov 2018 00:00:00 -0800</pubDate>
        <link>http://localhost:4000/2018/11/28/Unity%E5%85%A5%E9%97%A8-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA2DRoguelike%E6%B8%B8%E6%88%8F.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/28/Unity%E5%85%A5%E9%97%A8-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA2DRoguelike%E6%B8%B8%E6%88%8F.html</guid>
        
        <category>Unity</category>
        
        <category>C#</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Apk Permissions Check</title>
        <description>&lt;h2&gt;目的&lt;/h2&gt;
&lt;p&gt;反编译apk并解析xml文件，检查其中是否存在设定白名单外的权限声明。该工具可以作为分发安卓包前工具链的一部分。&lt;/p&gt;
&lt;h2&gt;使用说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用前请配置apkPermissionsCheck.py中的必要权限集合:NECESSARYPERMISSIONSSET。集合外的权限将会被警告打印到控制台&lt;/li&gt;
&lt;li&gt;需要将apktool.jar放置在同目录下&lt;/li&gt;
&lt;li&gt;
执行脚本
&lt;blockquote&gt;
&lt;p&gt;&lt;font size=&quot;3&quot;&gt;python apkPermissionsCheck.py -path [ directory ] &lt;br /&gt;
# -path/--path 检查某个路径下的所有apk &lt;br /&gt;
或 &lt;br /&gt;
python apkPermissionsCheck.py -apkname [ apk1 ] ( [apk2] ... ) &lt;br /&gt;
# -apkname/--apkname 检查若干当前路径下的apk文件&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;apkPermissionsCheck Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/7ippo/ApkPermissionsCheck&quot;&gt;☆Github Repo☆&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
import os
import re
import argparse
import xml.etree.ElementTree as ET

parser = argparse.ArgumentParser()
parser.add_argument('--path', '-path', required=False,
                    help='Optional, Directory path of a group of apk files')
parser.add_argument('--apkname', '-apkname', required=False,
                    help='Optional, Several apk files\' names', nargs='+')

NECESSARYPERMISSIONSSET = {'android.permission.RECEIVE_USER_PRESENT',
                           'android.permission.MOUNT_UNMOUNT_FILESYSTEMS',
                           'android.permission.CAMERA',
                           'android.permission.WRITE_EXTERNAL_STORAGE',
                           'android.permission.READ_EXTERNAL_STORAGE',
                           'android.permission.RECORD_AUDIO'}


def deCompile(filename):
    apktool_command = &quot;java -jar apktool.jar d -f &quot; + filename
    os.system(apktool_command)


def checkPermissionsList(filename):
    manifest_path = os.path.join(&quot;./&quot; + filename + &quot;/AndroidManifest.xml&quot;)
    ET.register_namespace(
        'android', 'http://schemas.android.com/apk/res/android')
    print(manifest_path)
    manifest_tree = ET.parse(manifest_path)
    manifest_root = manifest_tree.getroot()
    uses_permission_list = manifest_root.findall(&quot;uses-permission&quot;)

    warnings_permissions = []
    for permission in uses_permission_list:
        permission_name = permission.attrib[
            '{http://schemas.android.com/apk/res/android}name']
        if(re.search(r'^(android\.permission)\..*', permission_name)):
            if permission_name not in NECESSARYPERMISSIONSSET:
                if(permission_name not in warnings_permissions):
                    warnings_permissions.append(permission_name)
    warnings_permissions.append(filename)
    return warnings_permissions


def reportPermissionsWarnings(warnings_permissions):
    warning_nums = len(warnings_permissions)-1
    if warning_nums == 0:
        print()
        print('========{}========'.format(&quot;Checking Result...&quot;))
        print()
        print('**CLEAR ~**\n')
        print('There is 0 WARNING Android permission in : {}'.format(
            warnings_permissions[0]))
    else:
        print()
        print('========{}========'.format(&quot;Checking Result...&quot;))
        print()
        print('**WARNING !**\n')
        print('{} unnecessary permissions founded in : {}'.format(
            warning_nums, warnings_permissions[warning_nums]))
        for i in range(warning_nums):
            print('        {}\n'.format(warnings_permissions[i]))
    return


if __name__ == '__main__':
    args = parser.parse_args()
    if not(args.path) and not(args.apkname):
        parser.print_help()
        exit(0)
    if args.path:
        for apks in os.listdir(args.path):
            if(re.search(r'apk$', apks)):
                print()
                deCompile(apks)
                folder_name = re.sub(r'\.apk$', '', apks)
                warnings_permissions = checkPermissionsList(folder_name)
                reportPermissionsWarnings(warnings_permissions)
    elif args.apkname:
        for apks in args.apkname:
            deCompile(apks)
            folder_name = re.sub(r'\.apk$', '', apks)
            warnings_permissions = checkPermissionsList(folder_name)
            reportPermissionsWarnings(warnings_permissions)

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Another&lt;/h2&gt;
&lt;p&gt;介于公司对AndroidManifest合并的逻辑太过粗暴导致重复权限声明&amp;lt;uses-permission&amp;gt;多达四五十个，遂顺手写了另一个小工具removeRedundantPermissions，同样解析AndroidManifest.xml，删除重复的权限声明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font size=&quot;3&quot;&gt;python removeRedundantPermissions.py -xml/--xml [ AndroidManifest1.xml ] ( [AndroidManifest2.xml] ...)&lt;br /&gt;
# -xml/--xml 删除若干AndroidManifest.xml中的重复权限声明 &lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;removeRedundantPermissions Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/7ippo/ApkPermissionsCheck&quot;&gt;☆Github Repo☆&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
import argparse
import xml.etree.ElementTree as ET

parser = argparse.ArgumentParser()
parser.add_argument('--xml', '-xml', required=True,
                    help='Several XML files', nargs='+')

if __name__ == '__main__':
    args = parser.parse_args()
    if args.xml:
        for xml in args.xml:
            ET.register_namespace(
                'android', 'http://schemas.android.com/apk/res/android')
            manifest_tree = ET.parse(xml)
            manifest_root = manifest_tree.getroot()
            uses_permission_list = manifest_root.findall(&quot;uses-permission&quot;)
            permission_list = []
            for permission in uses_permission_list:
                permission_name = permission.attrib[
                    '{http://schemas.android.com/apk/res/android}name']
                if permission_name not in permission_list:
                    permission_list.append(permission_name)
                else:
                    manifest_root.remove(permission)
            manifest_tree.write(xml)
&lt;/code&gt;
&lt;/pre&gt;
</description>
        <pubDate>Tue, 06 Nov 2018 00:00:00 -0800</pubDate>
        <link>http://localhost:4000/2018/11/06/Apk-Permissions-Check.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/06/Apk-Permissions-Check.html</guid>
        
        <category>Android</category>
        
        <category>Python</category>
        
        <category>工具</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Log for Shell</title>
        <description>&lt;h2&gt;目标&lt;/h2&gt;
&lt;p&gt;Shell脚本面向内部技术人员，编写目标如下：   
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;脚本编写简单小巧，结构清晰，便于维护&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;脚本内容需要分为若干步骤，同时打印步骤序号和步骤名称&lt;/li&gt;
&lt;li&gt;一个脚本做的事情不超过5步，脚本内容过多则进行相应拆分,避免某一个脚本过于复杂&lt;/li&gt;
&lt;li&gt;脚本的每个步骤以及函数实现遵循单一功能原则，代码长度控制在50行以内（50行大概是整个桌面窗口最大化后能全部展示的行数）&lt;/li&gt;
&lt;li&gt;文件部署尽量清晰，及时清理废弃脚本和废弃文件夹，被注释掉的无用代码及时删除&lt;/li&gt;
&lt;li&gt;入口脚本应该提供&lt;strong&gt;-help&lt;/strong&gt;，&lt;strong&gt;-version&lt;/strong&gt;功能
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志输出可以快速定位问题，打印格式规范统一&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;日志止于出错位置，并且能够明确指出错误位置&lt;/li&gt;
&lt;li&gt;能够看到执行脚本的脚本名与执行时的具体参数&lt;/li&gt;
&lt;li&gt;关键日志和非关键日志进行区分&lt;/li&gt;
&lt;li&gt;不打印看起来没有意义或没有人会看的日志&lt;/li&gt;
&lt;li&gt;调试脚本时打印的辅助日志，调试完成后&lt;strong&gt;务必&lt;/strong&gt;删掉&lt;/li&gt;
&lt;li&gt;生产环境中执行脚本&lt;strong&gt;不要带-x选项&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;脚本部署结构&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
&amp;gt;scripts
    &amp;gt;bin  业务脚本
    &amp;gt;lib  引用库
        &amp;gt;tools  内部工具
        ...
    &amp;gt;etc  配置文件，包括通用配置与本地配置
        &amp;gt;local_etc  本地配置
            &amp;gt;default  默认配置
            &amp;gt;using_etc*  本地使用的环境配置
        ...
    &amp;gt;tmp*  临时文件
        &amp;gt;log*  日志
        ...
    &amp;gt;server  服务脚本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;local_etc目录下存放着default与using_etc两个配置目录，default纳入版本控制系统，下存放着默认的环境配置。using_etc为default的拷贝，为机器最终使用的环境配置，方便做动态增加机器，环境变量的特殊修改和还原操作。&lt;/li&gt;
&lt;li&gt;带星号*的目录不会纳入版本控制系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;规约&lt;/h2&gt;
&lt;h3&gt;命名风格统一&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文件名、内部变量名使用&amp;nbsp;&lt;strong&gt;&lt;em&gt;lowerCamelCase&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;小写驼峰形式，如:&amp;nbsp; buildServerConsole.sh，resultNum&lt;/li&gt;
&lt;li&gt;函数名使用&amp;nbsp;&lt;strong&gt;&lt;em&gt;UpperCamelCase&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;大写驼峰形式，如:&amp;nbsp; ReportFailure，AfterShell&lt;/li&gt;
&lt;li&gt;常量名、路径名使用以下划线连接的全大写单词形式，如:&amp;nbsp;QUIET_RUN，SCRIPTS_AUTOBUILD_DIR&lt;/li&gt;
&lt;li&gt;命名时，除非某个单词有业内通用的缩写简写，否则不要使用单词缩写简写命名，&lt;strong&gt;特别不要把自己平时的缩写简写写入公共脚本&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;日志输出规范&lt;/h3&gt;
&lt;p&gt;编写了一套Shell的日志工具脚本:&lt;a href=&quot;https://github.com/7ippo/logForShell&quot;&gt;☆logForShell代码☆&lt;/a&gt;。目前能够实现：统一格式打印，带TAG输出，分步执行，时间戳，出错后停止输出日志，出错后打印Shell堆栈，区分关键日志与非关键日志。编写Shell脚本时请按照以下规范调用日志方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Usage 使用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;source ./logForShell.sh &quot;default&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;入口脚本&lt;/strong&gt;中，在调用任何日志方法之前，请先调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;CleanFlagBeforeStart&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数。该函数会清除上一次可能因脚本执行失败而留下的标志文件，该标志会阻止日志继续输出。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有日志通过调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;Show&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;Show &quot;Log For Shell&quot;

2018-09-05 [17:50:24] Log For Shell
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要打印带TAG的Shell日志，可以在source logForShell.sh时传入TAG参数(默认为空)，则日志打印时均会带上该TAG输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;source ./logForShell.sh [Shell]
Show &quot;Using TAG to LOG&quot;

2018-09-11 [10:08:26] [Shell] Using TAG to LOG
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本开始时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;BeforeShell&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数，传入所有执行参数$@。该函数会打印执行脚本名称与所有参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;BeforeShell $@

2018-09-05 [17:52:21]
2018-09-05 [17:52:21]    +   test.sh  BEGIN   +
2018-09-05 [17:52:21]    +   test.sh -n -r -android 90   +
2018-09-05 [17:52:21]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本执行步骤时，打印步骤序号和步骤名称。调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;Step&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数，传入两个参数，第一个为步骤序号，第二个为步骤名称。该函数会打印步骤标志：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;Step 1 &quot;Copy Unity Resource&quot;

2018-09-05 [17:52:21]
2018-09-05 [17:52:21] ==================== test.sh  STEP 1 : Copy Unity Resource ====================
2018-09-05 [17:52:21]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本结束时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;AfterShell&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数。该函数会打印脚本结束标志：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;AfterShell

2018-09-05 [17:52:21]
2018-09-05 [17:52:21]    +   test.sh  FINISH   +
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要打印关键步骤成功的标志时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;ReportSuccess&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数(默认为空)，可以传入关键步骤名称参数。该函数会打印成功结果标志：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;ReportSuccess &quot;Build Dynamic Framework Project&quot;	

****     Build Dynamic Framework Project SUCCESS      ****

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要打印错误标志时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;ReportFailure&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数。该函数会打印调用者的行号、脚本名，并阻止之后的日志输出，并通过内建命令caller输出一个Shell的调用堆栈：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;ReportFailure		

****     line 10 test.sh REPORTED FAILURE     ****


    CALLER LIST
 - line 10 a test.sh
 - line 14 b test.sh
 - line 17 main test.sh

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非关键命令，如svn操作，拷贝命令执行前请调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;BlankLine&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;打印一个空行&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;其他规范&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;脚本设计编写时应考虑按功能模块拆分成独立脚本，执行时均使用sh或source执行，去掉分配脚本执行权限的过程&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量使用时要加花括号&lt;/p&gt;
&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;$Ditch =&amp;gt; ${Ditch}&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
规范脚本的错误码，调用脚本后需要对脚本返回值$?进行相应处理，推荐每个调用其他脚本的脚本内部写一个处理返回值的函数。该函数最少应具备处理错误返回值的情况，如面对错误返回值不继续执行后续操作，需要清除相应标志位：&lt;/li&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;function HandleError(){
returnVal=$?
if [ $retVal -ne 0 ]; then
    Show &quot; error exit status &quot;$returnVal&quot; last command&quot;
    rm -f ${MARK_FILE}
    exit 0
fi
}
&lt;/code&gt;&lt;/pre&gt;
&lt;li&gt;
&lt;code&gt;引用命令输出时，使用$()而不用反引号``&lt;/code&gt;
&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;`pwd` =&amp;gt; $(pwd)&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
&lt;p&gt;打印变量时，把变量名和变量值一起打印&lt;/p&gt;
&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;如Show &quot;$PLATFORM&quot;,至少应该写成Show &quot;PLATFORM:$PLATFORM&quot;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
定义函数时在函数名前加上&lt;em&gt;function&lt;/em&gt;:&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;function UpperCamelCase(){
	...
}
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
if-else流程控制，then和条件判断请写在同一行:&lt;/li&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;if [ ... ];then
  ...
elif [ ... ]; then
  ...
else
  ...
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;li&gt;区分$0与$BASH_SOURCE的区别，需要打印当前执行脚本名时使用$BASH_SOURCE
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;logforshell代码&quot;&gt;&lt;a href=&quot;https://github.com/7ippo/logForShell&quot;&gt;☆logForShell代码☆&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;#!/bin/bash

# 全局执行结果标志位，有一步出错后日志不会继续输出
# 考虑到子Shell与父Shell进程间通信，使用与该文件同目录下的tag文件作为标志位进行信息传递和判断
export GLOBAL_FAIL_FLAG=&quot;$(cd $(dirname ${BASH_SOURCE[0]}); pwd )/globalFailFlag.tag&quot;

# 是否加入标签TAG标志位，默认为default
# 如： . ./logForShell.sh default
# 需要加入TAG时，调用该脚本时传入TAG参数
# 如： . ./logForShell.sh [Shell]
if [ &quot;${1}&quot; != &quot;default&quot; ];then
	TAG_FOR_SHELL=${1}
else
	TAG_FOR_SHELL=&quot;&quot;
fi

# 核心打印函数：用于区分关键与非关键日志
# 正常log前加时间戳，这样如svn cp等命令打印的内容没有时间戳
# 打印日志前加入自定义标签，方便过滤检索

function Show(){
	dateStr=`echo $(date +%Y-%m-%d) $(date +[%H:%M:%S])`
	if [ ! -f ${GLOBAL_FAIL_FLAG} ]; then
		echo &quot;${dateStr} ${TAG_FOR_SHELL} $@&quot;
	fi
}

# 空行打印函数：请在非关键日志如svn,cp,wget等命令前打印一个空行

function BlankLine(){
	echo &quot;&quot;
}

# 纯净打印函数：无时间戳无标签无格式

function NoFormatShow(){
	echo &quot;$@&quot;
}

# 步骤打印函数：需要传入$1：步骤序号，$2：步骤描述
# 如： Step 1 &quot;Copy Unity Resource&quot;

function Step(){
	sourceFileName=`caller`
	Show &quot;&quot;
	Show &quot;==================== ${sourceFileName##*/}  STEP $1 : $2 ====================&quot;
	Show &quot;&quot;
}

# 进入脚本函数：在关键脚本开始时执行，调用时需要传入执行脚本的所有参数
# 如： BeforeShell $@

function BeforeShell(){
	sourceFileName=`caller`
	Show &quot;&quot;
	Show &quot;   +   ${sourceFileName##*/}  BEGIN   +&quot;
	Show &quot;   +   ${sourceFileName##*/} $@   +&quot;
	Show &quot;&quot;
}

# 退出脚本函数：在脚本结束时执行
# 如： AfterShell

function AfterShell(){
	sourceFileName=`caller`
	Show &quot;&quot;
	Show &quot;   +   ${sourceFileName##*/}  FINISH   +&quot;
}

# 错误报告函数：在某一步结束后判断执行结果，若出错则调用该函数
# 如： ReportFailure
# 该函数会改变执行结果标志位，阻止出错后日志继续输出

function ReportFailure(){
	touch ${GLOBAL_FAIL_FLAG}
	echo &quot;&quot;
	echo &quot;&quot;
	echo &quot;****     line `caller` REPORTED FAILURE     ****&quot;
	echo &quot;&quot;
	echo &quot;&quot;
	# 通过循环判断caller返回，如果不为空则持续打印，最多打印5行
	echo &quot;    CALLER LIST    &quot;
	echo &quot; - line `caller 0`&quot;
	for loop in 1 2 3 4
	do
		if [ &quot;`caller ${loop}`&quot; != &quot;&quot; ];then
			echo &quot; - line `caller ${loop}`&quot;
		else
			echo &quot;&quot;
			break
		fi
	done
}

# 成功报告函数：在关键步骤结束后判断执行结果，成功则调用该函数
# 一般步骤不用调用该函数输出
# 如： ReportSuccess &quot;Init and check related params&quot;

function ReportSuccess(){
	echo &quot;&quot;
	echo &quot;****     $1 SUCCESS      ****&quot;
	echo &quot;&quot;
}

# 清理标志位函数：在加载logForShell函数后，务必在主入口脚本所有语句执行前调用

function CleanFlagBeforeStart(){
	if [ -f ${GLOBAL_FAIL_FLAG} ]; then
		rm -f ${GLOBAL_FAIL_FLAG}
	fi
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 28 Sep 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/2018/09/28/Log-for-Shell.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/28/Log-for-Shell.html</guid>
        
        <category>Shell</category>
        
        <category>工具</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Hello Jekyll</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Transform your plain text into static websites and blogs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;welcome&quot;&gt;Welcome&lt;/h3&gt;

&lt;p&gt;This site aims to be a comprehensive guide to Jekyll. We’ll cover topics such as getting your site up and running, creating and managing your content, customizing the way your site works and looks, deploying to various environments, and give you some advice on participating in the future development of Jekyll itself.&lt;/p&gt;

&lt;h3 id=&quot;so-what-is-jekyll-exactlypermalink&quot;&gt;So what is Jekyll, exactly?Permalink&lt;/h3&gt;

&lt;p&gt;Jekyll is a simple, blog-aware, static site generator. It takes a template directory containing raw text files in various formats, runs it through a converter (like &lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot;&gt;Markdown&lt;/a&gt;) and our &lt;a href=&quot;https://github.com/Shopify/liquid/wiki&quot;&gt;Liquid&lt;/a&gt; renderer, and spits out a complete, ready-to-publish static website suitable for serving with your favorite web server. Jekyll also happens to be the engine behind GitHub Pages, which means you can use Jekyll to host your project’s page, blog, or website from GitHub’s servers for free.&lt;/p&gt;

&lt;h3 id=&quot;helpful-hintspermalink&quot;&gt;Helpful HintsPermalink&lt;/h3&gt;

&lt;p&gt;Throughout this guide there are a number of small-but-handy pieces of information that can make using Jekyll easier, more interesting, and less hazardous. Here’s what to look out for.&lt;/p&gt;

&lt;h3 id=&quot;video-test&quot;&gt;Video Test&lt;/h3&gt;

&lt;iframe type=&quot;text/html&quot; width=&quot;100%&quot; height=&quot;385&quot; src=&quot;http://www.youtube.com/embed/gfmjMWjn-Xg&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
</description>
        <pubDate>Tue, 18 Apr 2017 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/2017/04/18/hello-jekyll.html</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/18/hello-jekyll.html</guid>
        
        
      </item>
    
  </channel>
</rss>
