<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ting's blog</title>
    <description>What is the purpose of LIFE</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 13 Nov 2018 16:49:24 +0800</pubDate>
    <lastBuildDate>Tue, 13 Nov 2018 16:49:24 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>Apk Permissions Check</title>
        <description>&lt;h2&gt;目的&lt;/h2&gt;
&lt;p&gt;反编译apk并解析xml文件，检查其中是否存在白名单外的权限声明，作为分发安卓包前工具链的一部分。&lt;/p&gt;
&lt;h2&gt;使用说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用前请配置必要权限集合:NECESSARYPERMISSIONSSET。集合外的权限将会被检查警告&lt;/li&gt;
&lt;li&gt;需要将apktool.jar放置在同目录下&lt;/li&gt;
&lt;li&gt;
执行脚本
&lt;blockquote&gt;
&lt;p&gt;&lt;font size=&quot;3&quot;&gt;python apkPermissionsCheck.py -path [ directory ] &lt;br /&gt;
# -path/--path 检查某个路径下的所有apk &lt;br /&gt;
或 &lt;br /&gt;
python apkPermissionsCheck.py -apkname [ apk1 ] ( [apk2] ... ) &lt;br /&gt;
# -apkname/--apkname 检查若干当前路径下的apk文件&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/7ippo/ApkPermissionsCheck&quot;&gt;☆Github Repo☆&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
import os
import re
import argparse
import xml.etree.ElementTree as ET

parser = argparse.ArgumentParser()
parser.add_argument('--path', '-path', required=False,
                    help='Optional, Directory path of a group of apk files')
parser.add_argument('--apkname', '-apkname', required=False,
                    help='Optional, Several apk files\' names', nargs='+')

NECESSARYPERMISSIONSSET = {'android.permission.RECEIVE_USER_PRESENT',
                           'android.permission.MOUNT_UNMOUNT_FILESYSTEMS',
                           'android.permission.CAMERA',
                           'android.permission.WRITE_EXTERNAL_STORAGE',
                           'android.permission.READ_EXTERNAL_STORAGE',
                           'android.permission.RECORD_AUDIO'}


def deCompile(filename):
    apktool_command = &quot;java -jar apktool.jar d -f &quot; + filename
    os.system(apktool_command)


def checkPermissionsList(filename):
    manifest_path = os.path.join(&quot;./&quot; + filename + &quot;/AndroidManifest.xml&quot;)
    ET.register_namespace(
        'android', 'http://schemas.android.com/apk/res/android')
    print(manifest_path)
    manifest_tree = ET.parse(manifest_path)
    manifest_root = manifest_tree.getroot()
    uses_permission_list = manifest_root.findall(&quot;uses-permission&quot;)

    warnings_permissions = []
    for permission in uses_permission_list:
        permission_name = permission.attrib['{http://schemas.android.com/apk/res/android}name']
        if(re.search(r'^(android\.permission)\..*', permission_name)):
            if permission_name not in NECESSARYPERMISSIONSSET:
                if(permission_name not in warnings_permissions):
                    warnings_permissions.append(permission_name)
    warnings_permissions.append(filename)
    return warnings_permissions


def reportPermissionsWarnings(warnings_permissions):
    warning_nums = len(warnings_permissions)-1
    if warning_nums == 0:
        print()
        print('========{}========'.format(&quot;Checking Result...&quot;))
        print()
        print('**CLEAR ~**\n')
        print('There is 0 WARNING Android permission in : {}'.format(
            warnings_permissions[0]))
    else:
        print()
        print('========{}========'.format(&quot;Checking Result...&quot;))
        print()
        print('**WARNING !**\n')
        print('{} unnecessary permissions founded in : {}'.format(
            warning_nums, warnings_permissions[warning_nums]))
        for i in range(warning_nums):
            print('        {}\n'.format(warnings_permissions[i]))
    return


if __name__ == '__main__':
    args = parser.parse_args()
    if not(args.path) and not(args.apkname):
        parser.print_help()
        exit(0)
    if args.path:
        for apks in os.listdir(args.path):
            if(re.search(r'apk$', apks)):
                print()
                deCompile(apks)
                folder_name = re.sub(r'\.apk$', '', apks)
                warnings_permissions = checkPermissionsList(folder_name)
                reportPermissionsWarnings(warnings_permissions)
    elif args.apkname:
        for apks in args.apkname:
            deCompile(apks)
            folder_name = re.sub(r'\.apk$', '', apks)
            warnings_permissions = checkPermissionsList(folder_name)
            reportPermissionsWarnings(warnings_permissions)

&lt;/code&gt;
&lt;/pre&gt;
</description>
        <pubDate>Tue, 06 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/06/Apk-Permissions-Check.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/06/Apk-Permissions-Check.html</guid>
        
        <category>安卓</category>
        
        <category>工具</category>
        
        <category>Python</category>
        
        <category>XML解析</category>
        
        <category>ET</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Log for Shell</title>
        <description>&lt;h2&gt;目标&lt;/h2&gt;
&lt;p&gt;Shell脚本面向内部技术人员，编写目标如下：   
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;脚本编写简单小巧，结构清晰，便于维护&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;脚本内容需要分为若干步骤，同时打印步骤序号和步骤名称&lt;/li&gt;
&lt;li&gt;一个脚本做的事情不超过5步，脚本内容过多则进行相应拆分,避免某一个脚本过于复杂&lt;/li&gt;
&lt;li&gt;脚本的每个步骤以及函数实现遵循单一功能原则，代码长度控制在50行以内（50行大概是整个桌面窗口最大化后能全部展示的行数）&lt;/li&gt;
&lt;li&gt;文件部署尽量清晰，及时清理废弃脚本和废弃文件夹，被注释掉的无用代码及时删除&lt;/li&gt;
&lt;li&gt;入口脚本应该提供&lt;strong&gt;-help&lt;/strong&gt;，&lt;strong&gt;-version&lt;/strong&gt;功能
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志输出可以快速定位问题，打印格式规范统一&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;日志止于出错位置，并且能够明确指出错误位置&lt;/li&gt;
&lt;li&gt;能够看到执行脚本的脚本名与执行时的具体参数&lt;/li&gt;
&lt;li&gt;关键日志和非关键日志进行区分&lt;/li&gt;
&lt;li&gt;不打印看起来没有意义或没有人会看的日志&lt;/li&gt;
&lt;li&gt;调试脚本时打印的辅助日志，调试完成后&lt;strong&gt;务必&lt;/strong&gt;删掉&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;文件部署&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
&amp;gt;build_scripts
    &amp;gt;bin  业务脚本
    &amp;gt;lib  引用库
        &amp;gt;tools  内部工具
        ...
    &amp;gt;etc  配置文件，包括通用配置与本地配置
        &amp;gt;local_etc  本地配置
            &amp;gt;default  默认配置
            &amp;gt;using_etc*  本地使用的环境配置
        ...
    &amp;gt;tmp*  临时文件
        &amp;gt;log*  日志
        ...
    &amp;gt;server  服务脚本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;local_etc目录下存放着default与using_etc两个配置目录，default纳入版本控制系统，下存放着默认的环境配置。using_etc为default的拷贝，为机器最终使用的环境配置，方便做动态增加机器，环境变量的特殊修改和还原操作。&lt;/li&gt;
&lt;li&gt;带星号*的目录不会纳入版本控制系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;规约&lt;/h2&gt;
&lt;h3&gt;命名风格统一&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文件名、内部变量名使用&amp;nbsp;&lt;strong&gt;&lt;em&gt;lowerCamelCase&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;小写驼峰形式，如:&amp;nbsp; buildServerConsole.sh，resultNum&lt;/li&gt;
&lt;li&gt;函数名使用&amp;nbsp;&lt;strong&gt;&lt;em&gt;UpperCamelCase&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;大写驼峰形式，如:&amp;nbsp; ReportFailure，AfterShell&lt;/li&gt;
&lt;li&gt;常量名、路径名使用以下划线连接的全大写单词形式，如:&amp;nbsp;QUIET_RUN，SCRIPTS_AUTOBUILD_DIR&lt;/li&gt;
&lt;li&gt;命名时，除非某个单词有业内通用的缩写简写，否则不要使用单词缩写简写命名，&lt;strong&gt;特别不要把自己平时的缩写简写写入公共脚本&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;日志输出规范&lt;/h3&gt;
&lt;p&gt;编写了一套Shell的日志工具脚本:&lt;a href=&quot;https://github.com/7ippo/logForShell&quot;&gt;☆logForShell代码☆&lt;/a&gt;。目前能够实现：统一格式打印，带TAG输出，分步执行，时间戳，出错后停止输出日志，出错后打印Shell堆栈，区分关键日志与非关键日志。编写Shell脚本时请按照以下规范调用日志方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;入口脚本&lt;/strong&gt;中，在调用任何日志方法之前，请先调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;CleanFlagBeforeStart&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数。该函数会清除上一次可能因执行失败而留下的标志。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本开始时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;BeforeShell&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数，传入所有执行参数$@。该函数会打印执行脚本名称与所有参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;BeforeShell $@

2018-09-05 [17:52:21]
2018-09-05 [17:52:21]    +   test.sh  BEGIN   +
2018-09-05 [17:52:21]    +   test.sh -n -r -android 90   +
2018-09-05 [17:52:21]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本执行步骤时，打印步骤序号和步骤名称。调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;Step&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数，传入两个参数，第一个为步骤序号，第二个为步骤名称。该函数会打印步骤标志：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;Step 1 &quot;Copy Unity Resource&quot;

2018-09-05 [17:52:21]
2018-09-05 [17:52:21] ==================== test.sh  STEP 1 : Copy Unity Resource ====================
2018-09-05 [17:52:21]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本结束时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;AfterShell&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数。该函数会打印脚本结束标志：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;AfterShell

2018-09-05 [17:52:21]
2018-09-05 [17:52:21]    +   test.sh  FINISH   +
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要打印关键步骤成功的标志时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;ReportSuccess&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数(默认为空)，可以传入关键步骤名称参数。该函数会打印成功结果标志：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;ReportSuccess &quot;Build Dynamic Framework Project&quot;	

****     Build Dynamic Framework Project SUCCESS      ****

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要打印错误标志时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;ReportFailure&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数。该函数会打印调用者的行号、脚本名，并阻止之后的日志输出，并通过内建命令caller输出一个Shell的调用堆栈：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;ReportFailure		

****     line 10 test.sh REPORTED FAILURE     ****


    CALLER LIST
 - line 10 a test.sh
 - line 14 b test.sh
 - line 17 main test.sh

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非关键命令，如svn操作，cp命令执行前请调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;BlankLine&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;打印一个空行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要打印带TAG的Shell日志，可以在source logForShell.sh时传入TAG参数(默认为空)，则日志打印时均会带上该TAG输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;source ./logForShell.sh [Shell]
Show &quot;Using TAG to LOG&quot;

2018-09-11 [10:08:26] [Shell] Using TAG to LOG
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;其他规范&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;脚本设计编写时应考虑按功能模块拆分成独立脚本，执行时均使用sh或source执行，去掉分配脚本执行权限的过程&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量使用时要加花括号&lt;/p&gt;
&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;$Ditch =&amp;gt; ${Ditch}&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
规范脚本的错误码，调用脚本后需要对脚本返回值$?进行相应处理，推荐每个调用其他脚本的脚本内部写一个处理返回值的函数。该函数最少应具备处理错误返回值的情况，如面对错误返回值不继续执行后续操作，需要清除相应标志位：&lt;/li&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;function HandleError(){
returnVal=$?
if [ $retVal -ne 0 ]; then
    Show &quot; error exit status &quot;$returnVal&quot; last command&quot;
    rm -f ${MARK_FILE}
    exit 0
fi
}
&lt;/code&gt;&lt;/pre&gt;
&lt;li&gt;
&lt;code&gt;引用命令输出时，使用$()而不用反引号``&lt;/code&gt;
&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;`pwd` =&amp;gt; $(pwd)&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
&lt;p&gt;打印变量时，把变量名和变量值一起打印&lt;/p&gt;
&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;如Show &quot;$PLATFORM&quot;,至少应该写成Show &quot;PLATFORM:$PLATFORM&quot;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
定义函数时在函数名前加上&lt;em&gt;function&lt;/em&gt;:&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;function UpperCamelCase(){
	...
}
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
if-else流程控制，then和条件判断请写在同一行:&lt;/li&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;if [ ... ];then
  ...
elif [ ... ]; then
  ...
else
  ...
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;li&gt;区分$0与$BASH_SOURCE的区别，需要打印当前执行脚本名时使用$BASH_SOURCE
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;logforshell代码&quot;&gt;&lt;a href=&quot;https://github.com/7ippo/logForShell&quot;&gt;☆logForShell代码☆&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;#!/bin/bash

# 全局执行结果标志位，有一步出错后日志不会继续输出
# 考虑到子Shell与父Shell进程间通信，使用与该文件同目录下的tag文件作为标志位进行信息传递和判断
export GLOBAL_FAIL_FLAG=&quot;$(cd $(dirname ${BASH_SOURCE[0]}); pwd )/globalFailFlag.tag&quot;

# 是否加入标签TAG标志位，默认为default
# 如： . ./logForShell.sh default
# 需要加入TAG时，调用该脚本时传入TAG参数
# 如： . ./logForShell.sh [Shell]
if [ &quot;${1}&quot; != &quot;default&quot; ];then
	TAG_FOR_SHELL=${1}
else
	TAG_FOR_SHELL=&quot;&quot;
fi

# 核心打印函数：用于区分关键与非关键日志
# 正常log前加时间戳，这样如svn cp等命令打印的内容没有时间戳
# 打印日志前加入自定义标签，方便过滤检索

function Show(){
	dateStr=`echo $(date +%Y-%m-%d) $(date +[%H:%M:%S])`
	if [ ! -f ${GLOBAL_FAIL_FLAG} ]; then
		echo &quot;${dateStr} ${TAG_FOR_SHELL} $@&quot;
	fi
}

# 空行打印函数：请在非关键日志如svn,cp,wget等命令前打印一个空行

function BlankLine(){
	echo &quot;&quot;
}

# 纯净打印函数：无时间戳无标签无格式

function NoFormatShow(){
	echo &quot;$@&quot;
}

# 步骤打印函数：需要传入$1：步骤序号，$2：步骤描述
# 如： Step 1 &quot;Copy Unity Resource&quot;

function Step(){
	sourceFileName=`caller`
	Show &quot;&quot;
	Show &quot;==================== ${sourceFileName##*/}  STEP $1 : $2 ====================&quot;
	Show &quot;&quot;
}

# 进入脚本函数：在关键脚本开始时执行，调用时需要传入执行脚本的所有参数
# 如： BeforeShell $@

function BeforeShell(){
	sourceFileName=`caller`
	Show &quot;&quot;
	Show &quot;   +   ${sourceFileName##*/}  BEGIN   +&quot;
	Show &quot;   +   ${sourceFileName##*/} $@   +&quot;
	Show &quot;&quot;
}

# 退出脚本函数：在脚本结束时执行
# 如： AfterShell

function AfterShell(){
	sourceFileName=`caller`
	Show &quot;&quot;
	Show &quot;   +   ${sourceFileName##*/}  FINISH   +&quot;
}

# 错误报告函数：在某一步结束后判断执行结果，若出错则调用该函数
# 如： ReportFailure
# 该函数会改变执行结果标志位，阻止出错后日志继续输出

function ReportFailure(){
	touch ${GLOBAL_FAIL_FLAG}
	echo &quot;&quot;
	echo &quot;&quot;
	echo &quot;****     line `caller` REPORTED FAILURE     ****&quot;
	echo &quot;&quot;
	echo &quot;&quot;
	# 通过循环判断caller返回，如果不为空则持续打印，最多打印5行
	echo &quot;    CALLER LIST    &quot;
	echo &quot; - line `caller 0`&quot;
	for loop in 1 2 3 4
	do
		if [ &quot;`caller ${loop}`&quot; != &quot;&quot; ];then
			echo &quot; - line `caller ${loop}`&quot;
		else
			echo &quot;&quot;
			break
		fi
	done
}

# 成功报告函数：在关键步骤结束后判断执行结果，成功则调用该函数
# 一般步骤不用调用该函数输出
# 如： ReportSuccess &quot;Init and check related params&quot;

function ReportSuccess(){
	echo &quot;&quot;
	echo &quot;****     $1 SUCCESS      ****&quot;
	echo &quot;&quot;
}

# 清理标志位函数：在加载logForShell函数后，务必在主入口脚本所有语句执行前调用

function CleanFlagBeforeStart(){
	if [ -f ${GLOBAL_FAIL_FLAG} ]; then
		rm -f ${GLOBAL_FAIL_FLAG}
	fi
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 28 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/28/Log-for-Shell.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/28/Log-for-Shell.html</guid>
        
        <category>Shell</category>
        
        <category>脚本规范</category>
        
        <category>日志</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Hello Jekyll</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Transform your plain text into static websites and blogs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;welcome&quot;&gt;Welcome&lt;/h3&gt;

&lt;p&gt;This site aims to be a comprehensive guide to Jekyll. We’ll cover topics such as getting your site up and running, creating and managing your content, customizing the way your site works and looks, deploying to various environments, and give you some advice on participating in the future development of Jekyll itself.&lt;/p&gt;

&lt;h3 id=&quot;so-what-is-jekyll-exactlypermalink&quot;&gt;So what is Jekyll, exactly?Permalink&lt;/h3&gt;

&lt;p&gt;Jekyll is a simple, blog-aware, static site generator. It takes a template directory containing raw text files in various formats, runs it through a converter (like &lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot;&gt;Markdown&lt;/a&gt;) and our &lt;a href=&quot;https://github.com/Shopify/liquid/wiki&quot;&gt;Liquid&lt;/a&gt; renderer, and spits out a complete, ready-to-publish static website suitable for serving with your favorite web server. Jekyll also happens to be the engine behind GitHub Pages, which means you can use Jekyll to host your project’s page, blog, or website from GitHub’s servers for free.&lt;/p&gt;

&lt;h3 id=&quot;helpful-hintspermalink&quot;&gt;Helpful HintsPermalink&lt;/h3&gt;

&lt;p&gt;Throughout this guide there are a number of small-but-handy pieces of information that can make using Jekyll easier, more interesting, and less hazardous. Here’s what to look out for.&lt;/p&gt;

&lt;h3 id=&quot;video-test&quot;&gt;Video Test&lt;/h3&gt;

&lt;iframe type=&quot;text/html&quot; width=&quot;100%&quot; height=&quot;385&quot; src=&quot;http://www.youtube.com/embed/gfmjMWjn-Xg&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
</description>
        <pubDate>Tue, 18 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/18/hello-jekyll.html</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/18/hello-jekyll.html</guid>
        
        <category>jekyll</category>
        
        
      </item>
    
  </channel>
</rss>
