<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ting's blog</title>
    <description>What is the purpose of LIFE</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 25 May 2019 17:49:40 +0800</pubDate>
    <lastBuildDate>Sat, 25 May 2019 17:49:40 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>Unity入门:编写一个2D Roguelike游戏</title>
        <description>&lt;p&gt;跑完了Unity官方的Basic Tutorial Demo后，意犹未尽的下载了一个Tutorial Project Demo:2D Roguelike。跟着官方的&lt;a href=&quot;https://unity3d.com/cn/learn/tutorials/s/2d-roguelike-tutorial&quot;&gt;教程&lt;/a&gt;从头开始做了一个Roguelike类型的2D生存游戏，每一关随机生成地图，食物和敌人。玩家要尽可能到达更高的关数。每天晚上跟着码代码和理解，花了两天时间终于build出来了windows版本的游戏，自己玩了玩还挺有意思，虽然有一个碰撞的bug...不过也算是上手了Unity的编辑器，对游戏这个概念有一个从代码到动画表现上的多层次理解。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c5492e939016.png&quot; alt=&quot;Windows Build&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;对游戏以及Unity一些浅薄的理解&lt;/h2&gt;
&lt;p&gt;对这个游戏以及Unity有了一些浅薄的理解:  
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们看到的游戏中的物体都被看做是一个对象，&lt;strong&gt;GameObject&lt;/strong&gt;。  
&lt;/li&gt;
&lt;li&gt;对象的形态外貌（&lt;strong&gt;Sprite Render&lt;/strong&gt;）由我们赋予，比如人物场景等任何元素的样子。外形是对象的一个属性，我们可以赋值成一些贴图。  
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象的动画由一帧一帧的图片组成，动画（&lt;strong&gt;Animator&lt;/strong&gt;）也是对象的一个可以被添加的属性，可以被添加移除以达到复用效果的属性更应该被称为组件（&lt;strong&gt;Component&lt;/strong&gt;）。我们可以设置动画播放的快慢，是否连续播放，是否不可被打断等动画效果，也可以通过代码控制动画播放的时机。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于动画有一个有意思的事情，就是动画有限状态机。其负责播放动画，以及在不同动画状态间来回切换。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c55bbff23067.png&quot; alt=&quot;AnimationController&quot; /&gt;&lt;br /&gt;
比如Demo中的主角，当玩家没有指令时，为状态一：这个状态下动画控制器（Animator Controller）就负责循环播放“PlayerIdle”（待机）这个动画，表现是主角一直在“呼吸抖动”&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c55cc8646305.png&quot; alt=&quot;AnimationController2&quot; /&gt;&lt;br /&gt;
当触发被攻击或者破坏墙壁的这两件事件时，代码通过Animator  Controller切换动画状态。被攻击事件时切换到“PlayerChop”状态，预先设定是进入这个状态后播放一次然后退出，所以主角动画表现是被攻击晃了一下，然后又回到“PlayerIdle”这个状态，循环播放待机动画。&lt;br /&gt;
也就是说，动画控制器负责播放动画（包括播放几次，速度快慢，几个动画状态），代码控制怎么在动画状态之间切换，何时进入，何时退出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象组件Component的理解：为了让我们的对象具有某些特性，我们还需要添加一些Component组件，其实际上是让这个对象拥有多一些其他类所拥有的方法和属性。比如这个Demo中，我们把主角和敌人视作可以检测碰撞的刚体，所以都加了Box Collider 2D和Rigidbody 2D两个组件。在控制这两种对象时，我们就可以使用这两种类中的方法来检测碰撞，然后扣取主角的生命值。墙体只检测碰撞来阻止敌人和主角移动，所以都添加Box Collider 2D组件。至于对象之间的互动，何时互动，我们都是通过C#代码来操控的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;地图大小固定是8x8的方块，因为是Roguelike的游戏，墙（可以被主角攻击打碎），敌人，地面上的水果食物都是根据关数在一个范围内随机生成（UnityEngine的Random类），在8x8地图上随机摆放，下一关入口则固定在右上方，主角每一关一开始都出现在左下角。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c57b0dc60751.png&quot; alt=&quot;Game&quot; /&gt;  
&lt;/li&gt;
&lt;li&gt;这个demo还涉及一些简单的UI和音频，分别通过Text类和AudioSource类来实现，通过脚本设置内容，在移动或被攻击的时候去更新内容，字体和颜色等属性可以在Unity中通过Text Component来改，也可以通过脚本GetComponent来修改。   
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;游戏设计需要面向对象&lt;/h2&gt;
&lt;p&gt;设计这些游戏对象的方法，我们肯定是采用面向对象的编程方法，极大的节省了代码量和维护成本，更好理解对象之间的行为方式。对于这个很简单的Roguelike游戏，我们可以设计这么几个类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GameManager类：用于管理整个游戏基本的初始化，随机地图生成，以及游戏基本逻辑（每个回合敌人都会移动），还有过场动画，角色死亡动画等;&lt;/li&gt;
&lt;li&gt;MovingObject类：考虑到主角和敌人都会移动，可以设计这样一个类，用于解决对象的移动表现（从一个地块到相邻的地块其实动画上可以有很多表现形式，具体怎么表现需要代码决定），是否可以移动（是否遇到障碍了）以及处理对象之间的碰撞关系（设计一个抽象类，由具体类去实现）;&lt;/li&gt;
&lt;li&gt;Player类：继承MovingObject类，处理详细的逻辑，比如向墙壁、食物、敌人移动分别是什么表现，还得检查食物是否小于0（死亡）;&lt;/li&gt;
&lt;li&gt;Enemy类：有点像写AI的移动逻辑了，每个回合什么表现，遇到主角时播放攻击动画等都由这个类控制;&lt;/li&gt;
&lt;li&gt;BoardManager类：地图场景的管理类，具体怎么生成随机地图，怎么生成墙体、食物、敌人，随机位置还不可以重复;&lt;/li&gt;
&lt;li&gt;Wall类：除了周围的碎石，场景中间的石块也是有表现的，可以被击碎，所以也要写一个具体的类来描述这一类对象;&lt;/li&gt;
&lt;li&gt;SoundManager类：管理背景音乐的循环播放。  
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;采用面向对象的编程方法，设计由顶向下，对整体的概念就会非常清晰，可以一点一点实现细节，也不会出现后期发现设计有问题，要推倒重来的情况。如果你思维很健壮，能考虑很多情况和可能性，还可以避免很多bug，亦或者是使很多bug更容易理解。比如这个例子中，只有主角和敌人可以移动，那就设计一个MovingObject的类，把二者通用的属性和方法都写进去，然后单独设计主角和敌人时，只需要继承这个类，实现独有的逻辑即可。  
&lt;/p&gt;
&lt;h2&gt;也只是刚刚入门&lt;/h2&gt;
&lt;p&gt;经过了这么一个demo，基本有了对小型简单游戏的设计理解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有了一个比较好的idea后，能描述出游戏的雏形，核心玩法是什么，特色是什么，实现机制是什么？比如Roguelike，就是地牢生存，特点是随机事件；&lt;/li&gt;
&lt;li&gt;思考如何设计游戏中的对象，和对象间的互动；&lt;/li&gt;
&lt;li&gt;在纸上画出游戏的各个元素，动画，原型，音效，用代码合理的组织起来；&lt;/li&gt;
&lt;li&gt;通过代码实现具体表现。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 28 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/28/Unity%E5%85%A5%E9%97%A8-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA2DRoguelike%E6%B8%B8%E6%88%8F.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/28/Unity%E5%85%A5%E9%97%A8-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA2DRoguelike%E6%B8%B8%E6%88%8F.html</guid>
        
        <category>Unity</category>
        
        <category>C#</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Apk Permissions Check</title>
        <description>&lt;h2&gt;目的&lt;/h2&gt;
&lt;p&gt;反编译apk并解析xml文件，检查其中是否存在设定白名单外的权限声明。该工具可以作为分发安卓包前工具链的一部分。&lt;/p&gt;
&lt;h2&gt;使用说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用前请配置apkPermissionsCheck.py中的必要权限集合:NECESSARYPERMISSIONSSET。集合外的权限将会被警告打印到控制台&lt;/li&gt;
&lt;li&gt;需要将apktool.jar放置在同目录下&lt;/li&gt;
&lt;li&gt;
执行脚本
&lt;blockquote&gt;
&lt;p&gt;&lt;font size=&quot;3&quot;&gt;python apkPermissionsCheck.py -path [ directory ] &lt;br /&gt;
# -path/--path 检查某个路径下的所有apk &lt;br /&gt;
或 &lt;br /&gt;
python apkPermissionsCheck.py -apkname [ apk1 ] ( [apk2] ... ) &lt;br /&gt;
# -apkname/--apkname 检查若干当前路径下的apk文件&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;apkPermissionsCheck Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/7ippo/ApkPermissionsCheck&quot;&gt;☆Github Repo☆&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
import os
import re
import argparse
import xml.etree.ElementTree as ET

parser = argparse.ArgumentParser()
parser.add_argument('--path', '-path', required=False,
                    help='Optional, Directory path of a group of apk files')
parser.add_argument('--apkname', '-apkname', required=False,
                    help='Optional, Several apk files\' names', nargs='+')

NECESSARYPERMISSIONSSET = {'android.permission.RECEIVE_USER_PRESENT',
                           'android.permission.MOUNT_UNMOUNT_FILESYSTEMS',
                           'android.permission.CAMERA',
                           'android.permission.WRITE_EXTERNAL_STORAGE',
                           'android.permission.READ_EXTERNAL_STORAGE',
                           'android.permission.RECORD_AUDIO'}


def deCompile(filename):
    apktool_command = &quot;java -jar apktool.jar d -f &quot; + filename
    os.system(apktool_command)


def checkPermissionsList(filename):
    manifest_path = os.path.join(&quot;./&quot; + filename + &quot;/AndroidManifest.xml&quot;)
    ET.register_namespace(
        'android', 'http://schemas.android.com/apk/res/android')
    print(manifest_path)
    manifest_tree = ET.parse(manifest_path)
    manifest_root = manifest_tree.getroot()
    uses_permission_list = manifest_root.findall(&quot;uses-permission&quot;)

    warnings_permissions = []
    for permission in uses_permission_list:
        permission_name = permission.attrib[
            '{http://schemas.android.com/apk/res/android}name']
        if(re.search(r'^(android\.permission)\..*', permission_name)):
            if permission_name not in NECESSARYPERMISSIONSSET:
                if(permission_name not in warnings_permissions):
                    warnings_permissions.append(permission_name)
    warnings_permissions.append(filename)
    return warnings_permissions


def reportPermissionsWarnings(warnings_permissions):
    warning_nums = len(warnings_permissions)-1
    if warning_nums == 0:
        print()
        print('========{}========'.format(&quot;Checking Result...&quot;))
        print()
        print('**CLEAR ~**\n')
        print('There is 0 WARNING Android permission in : {}'.format(
            warnings_permissions[0]))
    else:
        print()
        print('========{}========'.format(&quot;Checking Result...&quot;))
        print()
        print('**WARNING !**\n')
        print('{} unnecessary permissions founded in : {}'.format(
            warning_nums, warnings_permissions[warning_nums]))
        for i in range(warning_nums):
            print('        {}\n'.format(warnings_permissions[i]))
    return


if __name__ == '__main__':
    args = parser.parse_args()
    if not(args.path) and not(args.apkname):
        parser.print_help()
        exit(0)
    if args.path:
        for apks in os.listdir(args.path):
            if(re.search(r'apk$', apks)):
                print()
                deCompile(apks)
                folder_name = re.sub(r'\.apk$', '', apks)
                warnings_permissions = checkPermissionsList(folder_name)
                reportPermissionsWarnings(warnings_permissions)
    elif args.apkname:
        for apks in args.apkname:
            deCompile(apks)
            folder_name = re.sub(r'\.apk$', '', apks)
            warnings_permissions = checkPermissionsList(folder_name)
            reportPermissionsWarnings(warnings_permissions)

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Another&lt;/h2&gt;
&lt;p&gt;介于公司对AndroidManifest合并的逻辑太过粗暴导致重复权限声明&amp;lt;uses-permission&amp;gt;多达四五十个，遂顺手写了另一个小工具removeRedundantPermissions，同样解析AndroidManifest.xml，删除重复的权限声明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font size=&quot;3&quot;&gt;python removeRedundantPermissions.py -xml/--xml [ AndroidManifest1.xml ] ( [AndroidManifest2.xml] ...)&lt;br /&gt;
# -xml/--xml 删除若干AndroidManifest.xml中的重复权限声明 &lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;removeRedundantPermissions Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/7ippo/ApkPermissionsCheck&quot;&gt;☆Github Repo☆&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
import argparse
import xml.etree.ElementTree as ET

parser = argparse.ArgumentParser()
parser.add_argument('--xml', '-xml', required=True,
                    help='Several XML files', nargs='+')

if __name__ == '__main__':
    args = parser.parse_args()
    if args.xml:
        for xml in args.xml:
            ET.register_namespace(
                'android', 'http://schemas.android.com/apk/res/android')
            manifest_tree = ET.parse(xml)
            manifest_root = manifest_tree.getroot()
            uses_permission_list = manifest_root.findall(&quot;uses-permission&quot;)
            permission_list = []
            for permission in uses_permission_list:
                permission_name = permission.attrib[
                    '{http://schemas.android.com/apk/res/android}name']
                if permission_name not in permission_list:
                    permission_list.append(permission_name)
                else:
                    manifest_root.remove(permission)
            manifest_tree.write(xml)
&lt;/code&gt;
&lt;/pre&gt;
</description>
        <pubDate>Tue, 06 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/06/Apk-Permissions-Check.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/06/Apk-Permissions-Check.html</guid>
        
        <category>安卓</category>
        
        <category>工具</category>
        
        <category>Python</category>
        
        <category>ET</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Log for Shell</title>
        <description>&lt;h2&gt;目标&lt;/h2&gt;
&lt;p&gt;Shell脚本面向内部技术人员，编写目标如下：   
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;脚本编写简单小巧，结构清晰，便于维护&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;脚本内容需要分为若干步骤，同时打印步骤序号和步骤名称&lt;/li&gt;
&lt;li&gt;一个脚本做的事情不超过5步，脚本内容过多则进行相应拆分,避免某一个脚本过于复杂&lt;/li&gt;
&lt;li&gt;脚本的每个步骤以及函数实现遵循单一功能原则，代码长度控制在50行以内（50行大概是整个桌面窗口最大化后能全部展示的行数）&lt;/li&gt;
&lt;li&gt;文件部署尽量清晰，及时清理废弃脚本和废弃文件夹，被注释掉的无用代码及时删除&lt;/li&gt;
&lt;li&gt;入口脚本应该提供&lt;strong&gt;-help&lt;/strong&gt;，&lt;strong&gt;-version&lt;/strong&gt;功能
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志输出可以快速定位问题，打印格式规范统一&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;日志止于出错位置，并且能够明确指出错误位置&lt;/li&gt;
&lt;li&gt;能够看到执行脚本的脚本名与执行时的具体参数&lt;/li&gt;
&lt;li&gt;关键日志和非关键日志进行区分&lt;/li&gt;
&lt;li&gt;不打印看起来没有意义或没有人会看的日志&lt;/li&gt;
&lt;li&gt;调试脚本时打印的辅助日志，调试完成后&lt;strong&gt;务必&lt;/strong&gt;删掉&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;脚本部署结构&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
&amp;gt;scripts
    &amp;gt;bin  业务脚本
    &amp;gt;lib  引用库
        &amp;gt;tools  内部工具
        ...
    &amp;gt;etc  配置文件，包括通用配置与本地配置
        &amp;gt;local_etc  本地配置
            &amp;gt;default  默认配置
            &amp;gt;using_etc*  本地使用的环境配置
        ...
    &amp;gt;tmp*  临时文件
        &amp;gt;log*  日志
        ...
    &amp;gt;server  服务脚本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;local_etc目录下存放着default与using_etc两个配置目录，default纳入版本控制系统，下存放着默认的环境配置。using_etc为default的拷贝，为机器最终使用的环境配置，方便做动态增加机器，环境变量的特殊修改和还原操作。&lt;/li&gt;
&lt;li&gt;带星号*的目录不会纳入版本控制系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;规约&lt;/h2&gt;
&lt;h3&gt;命名风格统一&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文件名、内部变量名使用&amp;nbsp;&lt;strong&gt;&lt;em&gt;lowerCamelCase&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;小写驼峰形式，如:&amp;nbsp; buildServerConsole.sh，resultNum&lt;/li&gt;
&lt;li&gt;函数名使用&amp;nbsp;&lt;strong&gt;&lt;em&gt;UpperCamelCase&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;大写驼峰形式，如:&amp;nbsp; ReportFailure，AfterShell&lt;/li&gt;
&lt;li&gt;常量名、路径名使用以下划线连接的全大写单词形式，如:&amp;nbsp;QUIET_RUN，SCRIPTS_AUTOBUILD_DIR&lt;/li&gt;
&lt;li&gt;命名时，除非某个单词有业内通用的缩写简写，否则不要使用单词缩写简写命名，&lt;strong&gt;特别不要把自己平时的缩写简写写入公共脚本&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;日志输出规范&lt;/h3&gt;
&lt;p&gt;编写了一套Shell的日志工具脚本:&lt;a href=&quot;https://github.com/7ippo/logForShell&quot;&gt;☆logForShell代码☆&lt;/a&gt;。目前能够实现：统一格式打印，带TAG输出，分步执行，时间戳，出错后停止输出日志，出错后打印Shell堆栈，区分关键日志与非关键日志。编写Shell脚本时请按照以下规范调用日志方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;入口脚本&lt;/strong&gt;中，在调用任何日志方法之前，请先调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;CleanFlagBeforeStart&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数。该函数会清除上一次可能因执行失败而留下的标志。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本开始时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;BeforeShell&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数，传入所有执行参数$@。该函数会打印执行脚本名称与所有参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;BeforeShell $@

2018-09-05 [17:52:21]
2018-09-05 [17:52:21]    +   test.sh  BEGIN   +
2018-09-05 [17:52:21]    +   test.sh -n -r -android 90   +
2018-09-05 [17:52:21]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本执行步骤时，打印步骤序号和步骤名称。调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;Step&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数，传入两个参数，第一个为步骤序号，第二个为步骤名称。该函数会打印步骤标志：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;Step 1 &quot;Copy Unity Resource&quot;

2018-09-05 [17:52:21]
2018-09-05 [17:52:21] ==================== test.sh  STEP 1 : Copy Unity Resource ====================
2018-09-05 [17:52:21]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本结束时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;AfterShell&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数。该函数会打印脚本结束标志：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;AfterShell

2018-09-05 [17:52:21]
2018-09-05 [17:52:21]    +   test.sh  FINISH   +
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要打印关键步骤成功的标志时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;ReportSuccess&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数(默认为空)，可以传入关键步骤名称参数。该函数会打印成功结果标志：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;ReportSuccess &quot;Build Dynamic Framework Project&quot;	

****     Build Dynamic Framework Project SUCCESS      ****

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要打印错误标志时，调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;ReportFailure&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;函数。该函数会打印调用者的行号、脚本名，并阻止之后的日志输出，并通过内建命令caller输出一个Shell的调用堆栈：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;ReportFailure		

****     line 10 test.sh REPORTED FAILURE     ****


    CALLER LIST
 - line 10 a test.sh
 - line 14 b test.sh
 - line 17 main test.sh

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非关键命令，如svn操作，cp命令执行前请调用&amp;nbsp;&lt;strong&gt;&lt;em&gt;BlankLine&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;打印一个空行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要打印带TAG的Shell日志，可以在source logForShell.sh时传入TAG参数(默认为空)，则日志打印时均会带上该TAG输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;source ./logForShell.sh [Shell]
Show &quot;Using TAG to LOG&quot;

2018-09-11 [10:08:26] [Shell] Using TAG to LOG
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;其他规范&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;脚本设计编写时应考虑按功能模块拆分成独立脚本，执行时均使用sh或source执行，去掉分配脚本执行权限的过程&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量使用时要加花括号&lt;/p&gt;
&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;$Ditch =&amp;gt; ${Ditch}&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
规范脚本的错误码，调用脚本后需要对脚本返回值$?进行相应处理，推荐每个调用其他脚本的脚本内部写一个处理返回值的函数。该函数最少应具备处理错误返回值的情况，如面对错误返回值不继续执行后续操作，需要清除相应标志位：&lt;/li&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;function HandleError(){
returnVal=$?
if [ $retVal -ne 0 ]; then
    Show &quot; error exit status &quot;$returnVal&quot; last command&quot;
    rm -f ${MARK_FILE}
    exit 0
fi
}
&lt;/code&gt;&lt;/pre&gt;
&lt;li&gt;
&lt;code&gt;引用命令输出时，使用$()而不用反引号``&lt;/code&gt;
&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;`pwd` =&amp;gt; $(pwd)&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
&lt;p&gt;打印变量时，把变量名和变量值一起打印&lt;/p&gt;
&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;如Show &quot;$PLATFORM&quot;,至少应该写成Show &quot;PLATFORM:$PLATFORM&quot;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
定义函数时在函数名前加上&lt;em&gt;function&lt;/em&gt;:&lt;/li&gt;
&lt;blockquote&gt;&lt;pre&gt;function UpperCamelCase(){
	...
}
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;li&gt;
if-else流程控制，then和条件判断请写在同一行:&lt;/li&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;if [ ... ];then
  ...
elif [ ... ]; then
  ...
else
  ...
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;li&gt;区分$0与$BASH_SOURCE的区别，需要打印当前执行脚本名时使用$BASH_SOURCE
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;logforshell代码&quot;&gt;&lt;a href=&quot;https://github.com/7ippo/logForShell&quot;&gt;☆logForShell代码☆&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;#!/bin/bash

# 全局执行结果标志位，有一步出错后日志不会继续输出
# 考虑到子Shell与父Shell进程间通信，使用与该文件同目录下的tag文件作为标志位进行信息传递和判断
export GLOBAL_FAIL_FLAG=&quot;$(cd $(dirname ${BASH_SOURCE[0]}); pwd )/globalFailFlag.tag&quot;

# 是否加入标签TAG标志位，默认为default
# 如： . ./logForShell.sh default
# 需要加入TAG时，调用该脚本时传入TAG参数
# 如： . ./logForShell.sh [Shell]
if [ &quot;${1}&quot; != &quot;default&quot; ];then
	TAG_FOR_SHELL=${1}
else
	TAG_FOR_SHELL=&quot;&quot;
fi

# 核心打印函数：用于区分关键与非关键日志
# 正常log前加时间戳，这样如svn cp等命令打印的内容没有时间戳
# 打印日志前加入自定义标签，方便过滤检索

function Show(){
	dateStr=`echo $(date +%Y-%m-%d) $(date +[%H:%M:%S])`
	if [ ! -f ${GLOBAL_FAIL_FLAG} ]; then
		echo &quot;${dateStr} ${TAG_FOR_SHELL} $@&quot;
	fi
}

# 空行打印函数：请在非关键日志如svn,cp,wget等命令前打印一个空行

function BlankLine(){
	echo &quot;&quot;
}

# 纯净打印函数：无时间戳无标签无格式

function NoFormatShow(){
	echo &quot;$@&quot;
}

# 步骤打印函数：需要传入$1：步骤序号，$2：步骤描述
# 如： Step 1 &quot;Copy Unity Resource&quot;

function Step(){
	sourceFileName=`caller`
	Show &quot;&quot;
	Show &quot;==================== ${sourceFileName##*/}  STEP $1 : $2 ====================&quot;
	Show &quot;&quot;
}

# 进入脚本函数：在关键脚本开始时执行，调用时需要传入执行脚本的所有参数
# 如： BeforeShell $@

function BeforeShell(){
	sourceFileName=`caller`
	Show &quot;&quot;
	Show &quot;   +   ${sourceFileName##*/}  BEGIN   +&quot;
	Show &quot;   +   ${sourceFileName##*/} $@   +&quot;
	Show &quot;&quot;
}

# 退出脚本函数：在脚本结束时执行
# 如： AfterShell

function AfterShell(){
	sourceFileName=`caller`
	Show &quot;&quot;
	Show &quot;   +   ${sourceFileName##*/}  FINISH   +&quot;
}

# 错误报告函数：在某一步结束后判断执行结果，若出错则调用该函数
# 如： ReportFailure
# 该函数会改变执行结果标志位，阻止出错后日志继续输出

function ReportFailure(){
	touch ${GLOBAL_FAIL_FLAG}
	echo &quot;&quot;
	echo &quot;&quot;
	echo &quot;****     line `caller` REPORTED FAILURE     ****&quot;
	echo &quot;&quot;
	echo &quot;&quot;
	# 通过循环判断caller返回，如果不为空则持续打印，最多打印5行
	echo &quot;    CALLER LIST    &quot;
	echo &quot; - line `caller 0`&quot;
	for loop in 1 2 3 4
	do
		if [ &quot;`caller ${loop}`&quot; != &quot;&quot; ];then
			echo &quot; - line `caller ${loop}`&quot;
		else
			echo &quot;&quot;
			break
		fi
	done
}

# 成功报告函数：在关键步骤结束后判断执行结果，成功则调用该函数
# 一般步骤不用调用该函数输出
# 如： ReportSuccess &quot;Init and check related params&quot;

function ReportSuccess(){
	echo &quot;&quot;
	echo &quot;****     $1 SUCCESS      ****&quot;
	echo &quot;&quot;
}

# 清理标志位函数：在加载logForShell函数后，务必在主入口脚本所有语句执行前调用

function CleanFlagBeforeStart(){
	if [ -f ${GLOBAL_FAIL_FLAG} ]; then
		rm -f ${GLOBAL_FAIL_FLAG}
	fi
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 28 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/28/Log-for-Shell.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/28/Log-for-Shell.html</guid>
        
        <category>Shell</category>
        
        <category>脚本规范</category>
        
        <category>日志</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Hello Jekyll</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Transform your plain text into static websites and blogs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;welcome&quot;&gt;Welcome&lt;/h3&gt;

&lt;p&gt;This site aims to be a comprehensive guide to Jekyll. We’ll cover topics such as getting your site up and running, creating and managing your content, customizing the way your site works and looks, deploying to various environments, and give you some advice on participating in the future development of Jekyll itself.&lt;/p&gt;

&lt;h3 id=&quot;so-what-is-jekyll-exactlypermalink&quot;&gt;So what is Jekyll, exactly?Permalink&lt;/h3&gt;

&lt;p&gt;Jekyll is a simple, blog-aware, static site generator. It takes a template directory containing raw text files in various formats, runs it through a converter (like &lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot;&gt;Markdown&lt;/a&gt;) and our &lt;a href=&quot;https://github.com/Shopify/liquid/wiki&quot;&gt;Liquid&lt;/a&gt; renderer, and spits out a complete, ready-to-publish static website suitable for serving with your favorite web server. Jekyll also happens to be the engine behind GitHub Pages, which means you can use Jekyll to host your project’s page, blog, or website from GitHub’s servers for free.&lt;/p&gt;

&lt;h3 id=&quot;helpful-hintspermalink&quot;&gt;Helpful HintsPermalink&lt;/h3&gt;

&lt;p&gt;Throughout this guide there are a number of small-but-handy pieces of information that can make using Jekyll easier, more interesting, and less hazardous. Here’s what to look out for.&lt;/p&gt;

&lt;h3 id=&quot;video-test&quot;&gt;Video Test&lt;/h3&gt;

&lt;iframe type=&quot;text/html&quot; width=&quot;100%&quot; height=&quot;385&quot; src=&quot;http://www.youtube.com/embed/gfmjMWjn-Xg&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
</description>
        <pubDate>Tue, 18 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/18/hello-jekyll.html</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/18/hello-jekyll.html</guid>
        
        <category>jekyll</category>
        
        
      </item>
    
  </channel>
</rss>
