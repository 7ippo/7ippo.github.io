<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tingsven's blog</title>
    <description>What is the purpose of LIFE</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 01 Apr 2021 23:40:31 +0800</pubDate>
    <lastBuildDate>Thu, 01 Apr 2021 23:40:31 +0800</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>GAMES101毕业 - 现代计算机图形学入门</title>
        <description>&lt;h2 id=&quot;现代计算机图形学入门---2020春季---闫令琪ucsb&quot;&gt;现代计算机图形学入门 - 2020春季 - 闫令琪UCSB&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html&quot; target=&quot;_blank&quot;&gt;课程主页&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://games-cn.org/forums/forum/graphics-intro/&quot; target=&quot;_blank&quot;&gt;课程论坛&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.bilibili.com/video/BV1X7411F744&quot; target=&quot;_blank&quot;&gt;课程地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;实验作业环境&quot;&gt;实验/作业环境&lt;/h2&gt;

&lt;p&gt;虚拟机下搭建环境&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Ubuntu 18.04&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;libopencv-dev
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;libeigen3-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;向量与线性代数&quot;&gt;向量与线性代数&lt;/h2&gt;

&lt;h3 id=&quot;向量点乘&quot;&gt;向量点乘&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;求夹角余弦Cosθ&lt;/li&gt;
  &lt;li&gt;通过点积结果正负判断两个向量是否同向(Forward/Backward)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;向量叉乘&quot;&gt;向量叉乘&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通过叉积结果z分量的正负判断向量的左右关系，&lt;strong&gt;A&lt;/strong&gt;X&lt;strong&gt;B&lt;/strong&gt;&amp;gt;0则B在A左边（右手定理）。这个特性可以应用于判断点是否在三角形内。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;变换二维与三维&quot;&gt;变换（二维与三维）&lt;/h2&gt;

&lt;h3 id=&quot;线性变换对称旋转缩放切变&quot;&gt;线性变换：对称、旋转、缩放、切变&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/08/i5pzD76fHVUsFNo.png&quot; alt=&quot;LinearTransforms.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图形的线性变换均可以用一个相同维度的变换矩阵左乘表示&lt;code class=&quot;highlighter-rouge&quot;&gt;x' = Mx&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其中x表示某个点（或向量），如果是二维，则M是2X2矩阵。&lt;br /&gt;
注意在这样的表述下，平移不属于线性变换，因为变化的常量与x,y无关。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;齐次坐标&quot;&gt;齐次坐标&lt;/h3&gt;

&lt;p&gt;为什么引入齐次坐标？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/08/IkF6VmRQc9b3raK.png&quot; alt=&quot;HomogenousCoordinates.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了解决上面平移不属于线性变换，无法用矩阵左乘来表示的问题，所以引入了齐次坐标。自此，所有的线性变换均可以用一个矩阵左乘来表示。注意矢量平移前后仍为同一矢量，且为了保证齐次坐标下运算的一致性（两个点相减等于一个新的矢量），所以二维向量的齐次坐标第三位是0。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;齐次坐标统一后的线性变换表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/08/rOo82UQBS5AIcbE.png&quot; alt=&quot;2DTransform.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;齐次坐标下可以将线性变换与平移写成一个变换矩阵，代表着仿射变换，先做线性变换再平移。&lt;br /&gt;
三维如上类推即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;变换模型视图投影&quot;&gt;变换（模型、视图、投影）&lt;/h2&gt;

&lt;h3 id=&quot;rodrigues-rotation-formula&quot;&gt;Rodrigues’ Rotation Formula&lt;/h3&gt;

&lt;p&gt;三维环境下的任意一个旋转都可以拆解成绕三个轴的简单旋转组合。以下公式为绕过原点旋转轴$n$旋转$\alpha$角度，具体的推导可以&lt;a href=&quot;https://blog.csdn.net/Master_Ding/article/details/82459342&quot; target=&quot;_blank&quot;&gt;参考&lt;/a&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
R(n, \alpha) = cos(\alpha)I + (1 - cos(\alpha))nn^T + sin(\alpha)\begin{pmatrix}0 &amp; -n_z &amp; n_y\\\\n_z &amp; 0 &amp;-n_x\\\\-n_y &amp; n_x &amp; 0\end{pmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;绕不经过原点的轴旋转类似二维可以拆解为：
平移使轴经过原点计算平移矩阵$T$，计算旋转矩阵$R$，平移回原来的位置$T^-$:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;M_{T^-}M_RM_T&lt;/script&gt;

&lt;h3 id=&quot;视图相机变换&quot;&gt;视图/相机变换&lt;/h3&gt;

&lt;p&gt;把相机变换至规定的位置和方向，即处于原点，向$-Z$方向看，上方向为$Y$轴正方向，这个变换矩阵叫做视图变换。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/09/r9uYSXLvcQpEHVz.png&quot; alt=&quot;ViewCameraTransform.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;非常有意思的是，旋转矩阵是正交矩阵，其可逆等于其转置。这时候用来求上图中的$R_view$就非常方便了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;投影变换&quot;&gt;投影变换&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/09/a8cFvGfDZsEPeCS.png&quot; alt=&quot;perspective_orthographic.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;正交投影&quot;&gt;正交投影&lt;/h4&gt;

&lt;p&gt;更多的用于工程制图。&lt;/p&gt;

&lt;h4 id=&quot;透视投影&quot;&gt;透视投影&lt;/h4&gt;

&lt;p&gt;更多贴近于真实的人眼，有近大远小现象，应用最广泛的投影变换。&lt;/p&gt;

&lt;h2 id=&quot;光栅化rasterization&quot;&gt;光栅化Rasterization&lt;/h2&gt;

&lt;h3 id=&quot;相机宽高比aspect-ratio与垂直视距角度-fovy&quot;&gt;相机宽高比Aspect Ratio与垂直视距角度 fovY&lt;/h3&gt;

&lt;h3 id=&quot;建立屏幕像素坐标系&quot;&gt;建立屏幕像素坐标系&lt;/h3&gt;

&lt;p&gt;Pixels’ indices are from (0, 0) to (width - 1, height - 1)&lt;/p&gt;

&lt;h3 id=&quot;视口屏幕变换&quot;&gt;视口/屏幕变换&lt;/h3&gt;

&lt;p&gt;把之前投影的结果$(-1,1)^3$经过变换映射到屏幕像素坐标系中。&lt;/p&gt;

&lt;h3 id=&quot;不同的显示设备&quot;&gt;不同的显示设备&lt;/h3&gt;

&lt;p&gt;CRT-阴极显像管显示器（高中物理） LCD-液晶显示器 LED-发光二极管 OLED-有机发光二极管 Electrophoretic-电泳显示(kindle电子墨水屏，刷新率低)&lt;/p&gt;

&lt;h2 id=&quot;光栅化抗锯齿与深度测试&quot;&gt;光栅化（抗锯齿与深度测试）&lt;/h2&gt;

&lt;h3 id=&quot;抗锯齿反走样antialiasing&quot;&gt;抗锯齿（反走样）Antialiasing&lt;/h3&gt;

&lt;p&gt;采样导致的锯齿现象属于Sampling Artifacts（Errors/Mistakes/Inaccuracies）的一种。比如人眼观察高速的车轮轮毂有时会看到倒转也属于走样，这是人眼或相机在时间上的采样导致的。毕竟是连续变离散，当采样速率追不上信号变化的速率就会导致走样，这是采样原理导致的不准确性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/11/DrAfNGx6j2yhWuc.png&quot; alt=&quot;high-pass-filter.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Filtering 滤波： 用于过滤特定频率的信号。在图像中，高频一般是灰度变化较大的边界，也是锯齿容易产生的位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/11/iLKvSDPJoas2MkA.png&quot; alt=&quot;convolution.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Convolution 卷积：通过一种计算方式，将某个信号与其周围的信号取平均，得到一组变化平滑的新信号。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以抗锯齿要做的事情是在采样前，对三角形的每个像素进行box-blur，卷积操作求平均。&lt;/p&gt;

&lt;h3 id=&quot;msaamultisample-antialiasing-2x2-4x4-8x8&quot;&gt;MSAA（Multisample Antialiasing） 2x2 4x4 8x8&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/11/GztdIwfaBbRjnDh.png&quot; alt=&quot;MSAA.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;NxN的MSAA意味着在一个像素内取N个均匀分布的采样点，计算一个像素在三角形内采样点的比例并求出该像素颜色的平均值，作为该像素的颜色。&lt;/p&gt;

&lt;h3 id=&quot;拓展-fxaa-taa-当下广泛应用的抗锯齿的方案&quot;&gt;拓展 FXAA TAA 当下广泛应用的抗锯齿的方案&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;FXAA：在图像层面做的抗锯齿，不是在采样上做文章。效率很高效果也很好。&lt;/li&gt;
  &lt;li&gt;TAA：复用上一帧的信息，效率很高。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;深度测试&quot;&gt;深度测试&lt;/h3&gt;

&lt;h2 id=&quot;着色光照与基本着色模型&quot;&gt;着色（光照与基本着色模型）&lt;/h2&gt;

&lt;h2 id=&quot;blinn-phong反射模型&quot;&gt;Blinn-Phong反射模型&lt;/h2&gt;

&lt;p&gt;$\vec{light}$着色点（shading point）指向光源的单位向量 $\vec{normal}$着色点法向量（单位向量） $\vec{view}$着色点指向视角的单位向量&lt;/p&gt;

&lt;h3 id=&quot;漫反射&quot;&gt;漫反射&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/15/FDOS8aChimjPfcq.png&quot; alt=&quot;漫反射模型.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与观察视角无关的一个光照公式，与物体材质的漫反射系数、光照强度、着色点到达光源的距离、着色点吸收的光照能量（与$\vec{light}$，$\vec{normal}$夹角有关）有关。&lt;/p&gt;

&lt;h3 id=&quot;高光&quot;&gt;高光&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/15/Y9PGCsADSnULBwZ.png&quot; alt=&quot;高光光照模型.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;观察方向与镜面反射后的光照方向接近时可以看到高光。取巧可以借助$\vec{light}$与$\vec{normal}$的半程向量$\vec{half}$和$\vec{normal}$是否接近来判断（点乘）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Blinn-Phong的高光模型属于经验简化模型，不考虑光照能量的吸收情况所以不会有$n·l$。另外夹角余弦上的指数p是用于优化余弦函数，使其更贴近现实，当夹角稍微大一点就看不到高光。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2020/03/15/rf9MYx1q8HtN4TW.png&quot; alt=&quot;余弦函数指数模型.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2020/03/15/RSQcMgzYhTb3sGZ.png&quot; alt=&quot;高光系数.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;环境光&quot;&gt;环境光&lt;/h3&gt;

&lt;p&gt;$L_a = k_aI_a$&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;假设所有点接收到的环境光强度$I_a$ 是相同的，且$L_a$和$\vec{normal}$，$\vec{view}$均无关。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;blinn-phong模型&quot;&gt;Blinn-Phong模型&lt;/h3&gt;

&lt;p&gt;三种光照叠加起来即为Blinn-Phong模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/15/PDMsiqfH7b5c8L4.png&quot; alt=&quot;Blinn-Phong.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;着色着色频率图形管线纹理映射&quot;&gt;着色（着色频率、图形管线、纹理映射）&lt;/h2&gt;

&lt;h3 id=&quot;着色频率&quot;&gt;着色频率&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/15/IgDhKa4tReny1kd.png&quot; alt=&quot;三种着色频率.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Flat shading逐三角形着色， Gouraud shading逐顶点着色， Phong shading逐像素着色三种着色频率&lt;/p&gt;

&lt;h3 id=&quot;图形管线实时渲染管线&quot;&gt;图形管线/实时渲染管线&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/15/dTAat3lsIPmoDU4.png&quot; alt=&quot;pipeline.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由GPU硬件负责全部的操作。&lt;/p&gt;

&lt;h3 id=&quot;texture-mapping&quot;&gt;Texture Mapping&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;任何三维物体表面都可以展开成二维（地球仪与世界地图）&lt;/li&gt;
  &lt;li&gt;纹理就是三维物体表面的二维映射&lt;/li&gt;
  &lt;li&gt;具体怎么映射生成的纹理，是由模型制作工具来完成的&lt;/li&gt;
  &lt;li&gt;每个三维中的三角形对应纹理的坐标$(u,v)$&lt;/li&gt;
  &lt;li&gt;纹理设计应该允许横向纵向的重复应用&lt;/li&gt;
  &lt;li&gt;纹理应用也涉及到插值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;着色重心坐标插值纹理映射纹理应用&quot;&gt;着色（重心坐标插值、纹理映射、纹理应用）&lt;/h2&gt;

&lt;h3 id=&quot;三角形插值重心坐标-interpolation-across-triangles-barycentric-coordinates&quot;&gt;三角形插值：重心坐标 Interpolation Across Triangles: Barycentric Coordinates&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/18/ysMnDB13c6aWlXu.png&quot; alt=&quot;重心坐标.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重心坐标$(\alpha,\beta,\gamma)$并不会在三维投影到二维后不变&lt;/p&gt;

&lt;h3 id=&quot;纹理映射&quot;&gt;纹理映射&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/18/3xFtNnEc6eMyUGw.png&quot; alt=&quot;纹理映射.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;找到某个点的插值uv -&amp;gt; 找到纹理中对应uv的颜色 -&amp;gt; 应用该颜色至该点的漫反射系数Kd。&lt;/p&gt;

&lt;h4 id=&quot;双线性插值&quot;&gt;双线性插值&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/18/Dl7vmZ41jxIuseP.png&quot; alt=&quot;双线性插值.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当纹理图很小时，渲染的多个像素可能都被纹理映射到同一个uv上去，为了渲染结果能够平滑无锯齿，此时需要在texture.sample(u,v)时对纹理结果进行u,v两个方向上的插值得到一个加权平均纹理值。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bicubic使用的是附近16个texel来做加权平均，以更高的计算开销来获得更好的效果&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2020/03/18/o5vgVRNisyf9eT2.png&quot; alt=&quot;纹理插值方法与表现.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;范围查询---mipmap---三线性插值&quot;&gt;范围查询 - Mipmap - 三线性插值&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/18/Tz4GREP2umAfIlp.png&quot; alt=&quot;mipmap技术&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当纹理图很大时，一个像素可能会覆盖纹理很大范围。如果此时仍然只采样中心点坐标的纹理值会导致走样，所以需要计算该像素覆盖范围内的平均值。Mipmap是一个预生成的用于快速查询某个范围纹理平均颜色的纹理图，最多付出额外1/3的显存开销。&lt;/p&gt;

&lt;h4 id=&quot;各向异性过滤&quot;&gt;各向异性过滤&lt;/h4&gt;

&lt;p&gt;一个用来解决mipmap引出的over blur过度模糊的技术，类似变种Mipmap技术，预生成不等宽高比的纹理图用于采样。最多付出额外3倍的显存开销。&lt;/p&gt;

&lt;h3 id=&quot;纹理应用&quot;&gt;纹理应用&lt;/h3&gt;

&lt;p&gt;在现代GPU中，纹理不局限为一张贴图，而是GPU内存中可以用于做查询（包括范围查询、点查询）的一块数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-math&quot;&gt;texture = memory + range query(filtering)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此纹理有以下应用&lt;/p&gt;

&lt;h4 id=&quot;环境光照&quot;&gt;环境光照&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/18/8DoITrwLP5mYy2t.png&quot; alt=&quot;环境光照.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以用纹理描述环境光照，渲染到物体上可以表现出反射。（金属球）&lt;/p&gt;

&lt;h4 id=&quot;凹凸法线贴图-bumpnormal-mapping&quot;&gt;凹凸/法线贴图 Bump/Normal mapping&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/18/aVneKqGFjglLBPi.png&quot; alt=&quot;法线贴图.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过法线贴图映射改变每个像素的法线方向，从而影响着色，就可以在某个光滑模型表面实现出凹凸质感（即不改变几何模型）。&lt;/p&gt;

&lt;h4 id=&quot;位移贴图-displalcement-mapping&quot;&gt;位移贴图 Displalcement mapping&lt;/h4&gt;

&lt;p&gt;同法线贴图，但是是真的改变几何模型顶点。更加真实，细节更丰富，并且在阴影上不会露馅。&lt;/p&gt;

&lt;h4 id=&quot;预计算shading结果&quot;&gt;预计算shading结果&lt;/h4&gt;

&lt;p&gt;比如记录环境光遮蔽信息的纹理贴图&lt;/p&gt;

&lt;h4 id=&quot;三维纹理与体积渲染-3d-textures-and-volume-rendering&quot;&gt;三维纹理与体积渲染 3D Textures and Volume Rendering&lt;/h4&gt;

&lt;h2 id=&quot;geometry-几何&quot;&gt;Geometry 几何&lt;/h2&gt;

&lt;p&gt;如何描述各种形态、复杂的物体（汽车引擎、毛发、丝绸、水、草、显微镜下的微生物、树）与复杂的场景（城市、大场景远景）是几何涉及的研究内容。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;隐式(Implicit)几何与显式(Explicit)几何： 隐式几何表示顶点之间的关系，不给实际的点数据。比如球体表面可以定义为$x^2+y^2+z^2=1$。隐式的$f(x,y,z)$函数可以简单的判断某个特定的点是否在物体内（代入算小于0则在物体内部，0在物体表面，大于0在物体外部），但是隐式难以找出所有在物体上的点。显示几何则通过给出所有点的坐标或者通过参数映射的方式遍历二维映射出三维中所有点坐标，但是判断点在物体内外变得困难。
&lt;img src=&quot;https://i.loli.net/2020/03/23/fRS3yOaAeKsm9it.png&quot; alt=&quot;隐式与显式几何.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;implicit-geometry-隐式几何&quot;&gt;Implicit Geometry 隐式几何&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CSG(Constructive Solid Geometry)是隐式几何的一种，是通过计算一些基础几何（圆柱、球）的布尔运算（交、并、差）拼凑出复杂几何。&lt;/li&gt;
  &lt;li&gt;SDF(Signed Distance Functions)也是隐式几何的一种，用来表示空间中的任意一点到物体表面的最小距离。可以计算SDF函数值为0的点来算出边界，也可以在blending混合阶段用于计算边界的混合（水滴落入水中溅起的水花）。&lt;/li&gt;
  &lt;li&gt;Level Sets水平集也是使用这种原理，只是表示的方式不太一样（表示方式类似等高线），可以通过取特定值来找出对应几何边界。&lt;/li&gt;
  &lt;li&gt;Fractals（分形，自相似，类似递归）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;隐式几何的特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;简单的描述（函数）&lt;/li&gt;
  &lt;li&gt;容易查询特定点在几何内外&lt;/li&gt;
  &lt;li&gt;易于计算光线与表面求交（光线追踪）&lt;/li&gt;
  &lt;li&gt;对于一些简单的形状可以精确的描述，不会有采样错误&lt;/li&gt;
  &lt;li&gt;易于处理物理拓扑结构的变化（水）&lt;/li&gt;
  &lt;li&gt;很难处理复杂形状的模型（所以引入显式几何）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;explicit-geometry-显式几何&quot;&gt;Explicit Geometry 显式几何&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Point Cloud 点云：list of points (x,y,z)。
    &lt;ul&gt;
      &lt;li&gt;复杂的模型需要高密度的点云&lt;/li&gt;
      &lt;li&gt;三维扫描的输出就是点云&lt;/li&gt;
      &lt;li&gt;点云通常会被转换成polygon mesh&lt;/li&gt;
      &lt;li&gt;点云的应用不是很广泛&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Polygon Mesh 多边形面：存储顶点与多边形（三角形或四边形）
    &lt;ul&gt;
      &lt;li&gt;应用最为广泛&lt;/li&gt;
      &lt;li&gt;建模软件的输出&lt;/li&gt;
      &lt;li&gt;Wavefront Object File（.obj）：一个文本文件用于定义顶点、法线、纹理坐标及其连接关系。广泛用于图形学研究&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/8K5MhjZts9PzeOo.png&quot; alt=&quot;obj.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;curves-曲线&quot;&gt;Curves 曲线&lt;/h3&gt;

&lt;h4 id=&quot;bezier-curve-贝塞尔曲线&quot;&gt;Bezier Curve 贝塞尔曲线&lt;/h4&gt;

&lt;p&gt;通过若干个点定义一条唯一的光滑的曲线，操纵控制点的位置可以得到任意一条连续光滑的曲线。可以通过de Casteljau算法来画这个曲线。&lt;/p&gt;

&lt;p&gt;先考虑三个顶点的情况（二次贝塞尔曲线）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/DAcmbPEo73ULTed.png&quot; alt=&quot;贝塞尔曲线画法1.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再考虑四个顶点的情况，递归线性插值来算出曲线上的点的具体位置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/MF75ZedklnCPYjf.png&quot; alt=&quot;贝塞尔曲线画法2.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据线性插值可以推导出N阶（即N-1个控制点）的贝塞尔曲线的代数表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/SAbwC62kQu8IWno.png&quot; alt=&quot;N阶贝塞尔曲线的代数表达式.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体的二次贝塞尔曲线（控制点b0 b1 b2）代数表达式：&lt;/p&gt;

&lt;p&gt;$b_0^2(t)=(1-t)^2b_0+2t(1-t)b_1+t^2b_2$&lt;/p&gt;

&lt;p&gt;三次贝塞尔曲线（控制点b0 b1 b2 b3）代数表达式：&lt;/p&gt;

&lt;p&gt;$b_0^3(t)=b_0(1-t)^3+b_13t(1-t)^2+b_23t^2(1-t)+b_3t^3$&lt;/p&gt;

&lt;h4 id=&quot;piecewise-bezier-curve-逐段贝塞尔曲线&quot;&gt;Piecewise Bezier Curve 逐段贝塞尔曲线&lt;/h4&gt;

&lt;p&gt;高阶的贝塞尔曲线非常难控制（因为线性插值了所有控制点的信息）。所以为了更方便的描述一些精巧的曲线，可以通过绘制几段贝塞尔曲线然后拼接，即逐段贝塞尔曲线（常用三阶贝塞尔曲线，即4个控制点来绘制）。这个方法广泛用于字体、路径、幻灯片。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;逐段贝塞尔曲线需要考虑连续光滑性，分为C0连续性（值连续）与C1连续性（导数连续）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;其他曲线&quot;&gt;其他曲线&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Spline 样条曲线&lt;/li&gt;
  &lt;li&gt;B-splines B样条曲线，具备曲线局部性（类似逐段贝塞尔）&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;surfaces-曲面&quot;&gt;Surfaces 曲面&lt;/h3&gt;

&lt;h4 id=&quot;bezier-surfaces-贝塞尔曲面&quot;&gt;Bezier Surfaces 贝塞尔曲面&lt;/h4&gt;

&lt;p&gt;在两个方向上都做一次贝塞尔曲线的绘制。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/YWFLHuedmxhVny3.png&quot; alt=&quot;贝塞尔曲面的绘制方法.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mesh-operation-网格处理&quot;&gt;Mesh Operation 网格处理&lt;/h3&gt;

&lt;p&gt;Subdivision细分、Simplification简化、Regularization规范。&lt;/p&gt;

&lt;h4 id=&quot;mesh-subdivision-网格细分&quot;&gt;Mesh Subdivision 网格细分&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Loop Subdivision：一种三角形网格细分的算法。把1个三角形各取中点相连，细分成4个，同时更新新、旧各顶点的位置（加权平均），使模型变得光滑圆润&lt;/li&gt;
  &lt;li&gt;Catmull-Clark Subdivision：一种通用网格细分算法。原理相同都是添加新的点，只不过生成四边形网格，同时加权平均计算新、旧顶点的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/26/sWYCQhGa5mqKjIv.png&quot; alt=&quot;网格细分效果.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;mesh-simplification-网格简化&quot;&gt;Mesh Simplification 网格简化&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;网格简化常用于减少顶点数，减轻计算量，优化移动端性能表现，又或者不需要细节表现的场景中使用（比如缩小、远距）。但是几何的层次结构变化可能不如图像层次结构变化来得简单（比如mipmap技术）。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2020/03/26/c2T3J9vmSZUiGko.png&quot; alt=&quot;网格简化.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Edge Collapsing 边坍缩：一种贪心算法，计算所有边坍缩后的二次误差，取二次误差最小的边进行坍缩，坍缩后重新计算更新受影响的边的二次误差值，再取最小进行坍缩。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shadow-阴影&quot;&gt;Shadow 阴影&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;umbra: 本影/硬阴影，影子中光源完全照射不到的部分。理想的点光源，不考虑光源自身体积，则只会生成硬阴影&lt;/li&gt;
  &lt;li&gt;penumbra: 半影/软阴影，黑暗与光明之间的区域。考虑光源体积则会生成硬阴影与软阴影&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/29/IS9tKsel3XOJRDN.png&quot; alt=&quot;硬软阴影.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/29/mKiOnGVISb49c12.png&quot; alt=&quot;软硬阴影2.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;光栅化着色阶段考虑每个着色点时都是进行局部的计算，并没有考虑着色点到光源之间是否有其他物体或物体其他部分阻挡。所以无法计算阴影，由此在光栅化中引入了Shadow Map用来计算阴影。&lt;/p&gt;

&lt;h3 id=&quot;shadow-mapping-阴影图映射&quot;&gt;Shadow Mapping 阴影图/映射&lt;/h3&gt;

&lt;p&gt;Shadow Mapping仅用于理想点光源/平行光源，原理是&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先把一个虚拟相机放在光源位置，做一遍光栅化并生成深度图，用于记录能看到的位置及其深度&lt;/li&gt;
  &lt;li&gt;然后再通过真实相机做一遍光栅化，着色时将着色点投影回（Reprojected）虚拟相机中，可以求得其在深度图中对应的坐标&lt;/li&gt;
  &lt;li&gt;将着色点在虚拟相机的深度与深度图中对应坐标的深度比较，二者深度一致表明着色点可见，不一致则说明在阴影中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/27/wLNnuXMoQ9iOJDl.png&quot; alt=&quot;ShadowMapping.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shadow Mapping存在精度问题，来源于&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;浮点数本身精度问题&lt;/li&gt;
    &lt;li&gt;真实相机中的一个像素可能覆盖实际物体的多个点&lt;/li&gt;
    &lt;li&gt;深度图分辨率问题，生成多少像素的深度图（走样问题）&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;尽管存在精度问题，需要渲染两遍场景，有额外开销，且只能渲染硬阴影，但Shadow Mapping仍然为一个主流的渲染技术，广泛应用于早期动画以及当下几乎所有3D游戏中（塞尔达荒野之息、马里奥奥德赛）。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 04 Jul 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/07/04/Intro-To-Modern-CG.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/07/04/Intro-To-Modern-CG.html</guid>
        
        <category>图形学</category>
        
        <category>实时渲染</category>
        
        
        <category>图形学</category>
        
      </item>
    
      <item>
        <title>基于第一个完整项目经验的性能分析与优化讨论(一)</title>
        <description>&lt;h2 id=&quot;项目经历&quot;&gt;项目经历&lt;/h2&gt;

&lt;p&gt;从2019年4月开始以引擎身份进入项目组开始，我可以说是从头到尾参与了H2项目的开发。从最开始的demo预研，立项讨论，再到开始开发2D的场景编辑器，到实现项目的基础模块和功能，包括性能问题的排查与优化，一直到2020年6月份最后收尾，这持续一年多的项目经验让我收获颇丰，也有了对游戏开发有了初步的理解。&lt;/p&gt;

&lt;p&gt;在开始聊正文之前，先简单介绍一下项目性质。H2是基于&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;引擎开发的多平台H5 RPG手游，以包括&lt;code class=&quot;highlighter-rouge&quot;&gt;Android/iOS Native&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Android/iOS WebView&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Chrome/Safari浏览器&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;微信/QQ小游戏&lt;/code&gt;等多种形式上线多个平台。这也是H5的优势：&lt;em&gt;一次开发，多端体验&lt;/em&gt; ，不过适配开发的内容也不少。&lt;/p&gt;

&lt;p&gt;游戏的内容与形式就不提了，属于国漫IP衍生产品，玩法是典型的国内RPG风格，本文单纯从技术上分享我关于游戏性能优化的一些思考。&lt;/p&gt;

&lt;h2 id=&quot;我参与了哪些性能相关的内容&quot;&gt;我参与了哪些性能相关的内容&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;这部分主要是介绍我在H2项目中做的与性能优化相关的工作。关于性能优化相关的&lt;a href=&quot;#关于性能优化我的一些思考&quot;&gt;思考&lt;/a&gt;和普适性的优化&lt;a href=&quot;/2020/06/01/How-To-Analyze-And-Optimize-Performance-1.html&quot; target=&quot;_blank&quot;&gt;思路&lt;/a&gt;可以直接跳到对应部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;资源规格的设立和约定&quot;&gt;资源规格的设立和约定&lt;/h3&gt;

&lt;p&gt;项目初期对美术资源规格的把控从基础层面决定了后期性能的表现与优化难度。而这除了通过demo进行粗略的性能验证以外，也需要大量的项目经验辅佐判断。我入组时，引擎这边预研的demo已经跑了起来，虽然只有一个简易的模型和一个2D背景。H2项目是我们第一次使用Laya引擎开发的项目，缺少很多经验和技术的积累。所以在很多不太熟悉的关键点上，需要讨论确立流程。&lt;/p&gt;

&lt;p&gt;在项目立项早期，我作为引擎共同参与了包括美术、项目组、策划等决策人员出席的研讨会，会上确立了游戏的基本表现形式，比如是2.5D还是3D，美术资源的规格与游戏精度，比如贴图的分辨率，主角有多少个朝向，动画的类型是序列帧还是骨骼动画，如果是序列帧动画那是要具体多少帧，场景内最多容纳多少怪物等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/k1qJMFTHwSVIyQO.gif&quot; alt=&quot;当时确定了主角动画用序列帧来实现&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*最终主角动画使用序列帧来实现，UI中人物用骨骼动画来展示*&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;因为考虑到整体游戏的风格和性能要求，骨骼动画并没有用作主角的展示，只是作为点缀加入到了部分UI之中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在这个阶段，通过经验选定一些内容的实现方式后还需要根据游戏的需求通过demo测一下基本的性能表现，比如可接受的情况下最多支持多少动画同屏播放。而这些性能测试的表现也间接影响了后续策划对游戏内容的一些规划。&lt;/p&gt;

&lt;h3 id=&quot;公共图集&quot;&gt;公共图集&lt;/h3&gt;

&lt;p&gt;图集是最常见的静态合批技术，通过将不同的图片优化合成为一张大图，并记录不同图片的位置大小等索引信息，达到以下效果：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;合成图集时会去除每张图片周围的空白区域，加上可以在整体上实施各种优化算法，合成图集后可以大大减少游戏包体和内存占用&lt;/li&gt;
  &lt;li&gt;多个&lt;code class=&quot;highlighter-rouge&quot;&gt;Sprite&lt;/code&gt;如果渲染的是来自同一张图集的图片时，这些&lt;code class=&quot;highlighter-rouge&quot;&gt;Sprite&lt;/code&gt;可以使用同一个渲染批次来处理，大大减少CPU的运算时间，提高运行效率。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;合并渲染批次，是实时渲染里很多CPU优化技术的核心思路。合并渲染批次，相当于减少drawcall，即调用&lt;code class=&quot;highlighter-rouge&quot;&gt;DrawIndexedPrimitive&lt;/code&gt;(DirectX)或者&lt;code class=&quot;highlighter-rouge&quot;&gt;glDrawElements&lt;/code&gt;(OpenGL)的次数。主要针对的是CPU在两次drawcall之间的渲染状态改变比如切换到使用一个不同的材质，会导致显卡驱动中进行属于资源密集型&lt;code class=&quot;highlighter-rouge&quot;&gt;resource-intensive&lt;/code&gt;的一致性验证和转换的工作，而这部分性能开销在drawcall数量上去后十分可观。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// drawcall&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SetShader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Diffuse&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;铁&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;DrawPrimitive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DeskVertexBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// another drawcall&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SetShader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;VertexLight&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;木&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;DrawPrimitive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ChairVertexBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Laya IDE内置了图集打包工具，打包会生成若干张png与一个json格式记录图集信息的atlas文件。一般情况下我们会将一个功能或UI面板中用到的图片打成一个图集来达到减少drawcall的目的，同时我们也会将各个功能通用的一些小图或组件打包成公共图集，持久的加载在内存中，避免对待普通图集时的清理，来减少drawcall数量和提升加载速度。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/DM94azPHZGdOXNg.png&quot; alt=&quot;图集&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*图集*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/1iIuwqGKTEp3a7F.png&quot; alt=&quot;公共图集&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*公共图集*&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;公共图集的优化效果则取决于各个功能模块的开发者，他们需要将多个功能/模块中通用的图片摘出，加入公共图集进行打包，而非独立打包。同时也需要考虑公共图集的大小和数量，因为长期驻存在内存中意味着内存规模的上升，这需要衡量和取舍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;对象池技术&quot;&gt;对象池技术&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object Pool&lt;/code&gt;对象池也是极其常见的性能优化技术，针对频繁、反复创建可重用对象的场景有很好的优化效果，比如游戏内的飘字，子弹，可重用的动画组件，场景内的角色怪物等等。对象池与内存池技术原理相似，都是考虑到频繁的内存申请与释放而引起的系统调用带来的性能开销。所以通过回收重用对象避免，能够有&lt;em&gt;一定&lt;/em&gt;的性能优化效果。不过优化效果因场景而异，在一些非常简单的使用场景下使用对象池技术反而会导致反向优化。&lt;/p&gt;

&lt;p&gt;一般情况下，对象池的工作逻辑时这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在初始化阶段，对象池会创建若干同一类型的对象，并初始化一个记录各对象可用状态的表。&lt;/li&gt;
  &lt;li&gt;每次需要创建对象时，改为向池借用一个对象，并且使用者自己做好初始化工作，同时记录表中更新该对象的可用状态。&lt;/li&gt;
  &lt;li&gt;当用完对象需要销毁时，改为向池归还该对象，池则会做好清理和重用的工作，比如调用该对象的构造函数，同时记录表中更新该对象的可用状态。&lt;/li&gt;
  &lt;li&gt;同时池应该也要具备自管理的一些机制，比如：
    &lt;ul&gt;
      &lt;li&gt;当没有可用对象时，需要拓展池的规模，保证能够正常的借出可用对象；&lt;/li&gt;
      &lt;li&gt;而在一个对象创建高峰过后，也应该有一些策略来缩小池的大小，销毁池内的一些对象，即控制池规模在一定范围内；&lt;/li&gt;
      &lt;li&gt;如果支持多线程，则在借出对象时需要做一些同步支持工作；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据需求不同，池的规模大小也不同，如果池的规模过大，在初始化批量创建或者缩小池的批量销毁时，可能会导致单帧Update的耗时过高，引起帧数波峰变化，这种情况下可以通过摊帧解决。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 可供参考的对象池类结构&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ObjectPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pool_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;PoolType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// 池类型&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj_class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// 对象类型&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;constructor_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// 传入构造器的参数&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;max_obj_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;// 最大对象id，从1开始&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;                    &lt;span class=&quot;c1&quot;&gt;// 对象池: {pool_obj_id, object}&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj_cur_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// 对象池当前数量&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;idle_key_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;// 记录对象信息空闲池: {pool_obj_id, boolean}&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;idle_key_cur_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 空闲池当前数量&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;retain_threshold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// 池清理的下阈值: 池中对象数量&amp;lt;=此值, 则停止清理&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;shrink_threshold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// 池清理的上阈值: 池中对象数量&amp;gt;=此值, 则可以清理&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;shrink_check_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 池清理的间隔时间&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;delay_create_flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 是否摊帧创建&lt;/span&gt;

    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;inited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pool_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;// 池ID&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;next_shrink_interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 下次池清理的剩余时间&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 构造对象池，传入对象类型，对象构造时的参数，池规模大小等信息&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 自动管理与摊帧创建&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 借出对象，同时具备拓展池规模的功能&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;RentObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 归还对象，同时检查是否需要缩小池规模&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;GiveBackObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 真正创建一个对象&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CreateOneObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 真正销毁一个对象&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;DestroyObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 缩小池规模&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Shrink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 一些统计、profile接口&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cpu耗时分析工具与可视化性能报告&quot;&gt;CPU耗时分析工具与可视化性能报告&lt;/h3&gt;

&lt;p&gt;在一些游戏场景或内容有肉眼可见的卡顿，或者平均帧数不达标，或者需要在开发的不同阶段对性能表现进行把控的时候，性能的量化和可视化工具就是一个非常重要的东西了。最常见的应该就是对CPU耗时的分析工具了，而这个大部分引擎和IDE都做了支持，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;Unity Profile&lt;/code&gt;，可以详细到函数的执行栈和具体某个函数的执行时间。&lt;/p&gt;

&lt;p&gt;Laya作为H5游戏引擎，我们可以使用Chrome的DevTool中的Performance来&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance?hl=zh-cn&quot; target=&quot;_blank&quot;&gt;分析&lt;/a&gt;游戏的CPU耗时，同样可以看到每一帧的执行栈和具体耗时。除此之外，在JavaScript执行的过程中，我们还可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;performance&lt;/code&gt; API对一些我们关注的执行过程进行耗时测量和标记。随后在DevTool记录Performance Record过程中，我们标记和测量的结果都会显示在Timeline瀑布图中的Timings栏，我们还可以在Event栏中对这些标记进行检索和排序。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A_End&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;measure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A_Result&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A_End&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对此我们可以有很多应用，比如对所有协议的收发阶段进行标记和测量，并在性能报告中对协议的耗时进行检索和排序，就能够一眼看出哪些协议耗时过高或次数过多需要优化了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/vZTgCFY4UDnXaQp.png&quot; alt=&quot;Chrome Timeline瀑布图&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*Chrome Timeline瀑布图*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;但是在使用Chrome的DevTool的过程中，我发现Chrome的瀑布流图表对异步过程的标记和测量存在bug。比如在需要测量的两个标记中如果存在其他未闭合的标记，虽然瀑布流的Timings栏会有记录，但是在Event栏却检索不到该记录，也无法根据耗时排序了。这个&lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=1000097&amp;amp;q=&amp;amp;can=4&quot; target=&quot;_blank&quot;&gt;bug&lt;/a&gt;已经提交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;crbug.com&lt;/code&gt;。但是至今还没修复，可能是和数据记录识别的方式有关系。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A_End&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;B_End&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;measure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A_Result&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A_End&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;measure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;B_Result&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;B_End&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/wArj2V7HWkflLIY.png&quot; alt=&quot;Chrome Timeline瀑布流的bug&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*Chrome Timeline瀑布图无法识别记录*&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当然&lt;code class=&quot;highlighter-rouge&quot;&gt;performance&lt;/code&gt; API现阶段并没有被完全支持，在一些环境中(比如微信小游戏，Laya Native及Safari)，你可以考虑改用&lt;code class=&quot;highlighter-rouge&quot;&gt;console.time&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;console.timeEnd&lt;/code&gt;来包裹一段执行过程，除了在console控制台输出计时外，记录也会显示在&lt;code class=&quot;highlighter-rouge&quot;&gt;DevTool&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;Performance瀑布流&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;Console栏&lt;/code&gt;中。或者你也可以封装一个profile工具，判断不同环境用不同的实现，或者空调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;值得注意的是，尽管Chrome自带的&lt;code class=&quot;highlighter-rouge&quot;&gt;Performance&lt;/code&gt;的瀑布流图表已经十分详尽，但是因为记录的内容太多，导致记录本身耗时（虽然可以关闭一些无关的记录选项，比如不关注执行栈时可以&lt;code class=&quot;highlighter-rouge&quot;&gt;disable JavaScript sample&lt;/code&gt;），且加载性能数据也非常耗时。实际上做游戏Profile时我们关心的其实只是很小的一部分，比如每个模块的耗时分布，每个协议的耗时，所以一般情况下还是需要自己做一些额外的工作，比如数据的筛选与可视化报告。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/HXgmRFOuMapZx8k.png&quot; alt=&quot;Chrome 性能数据记录的格式&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*Chrome 性能数据记录的格式*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在JavaScript中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;performance&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;console&lt;/code&gt;进行标记，并通过&lt;code class=&quot;highlighter-rouge&quot;&gt;DevTool&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;Performance&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;Record&lt;/code&gt; 产生性能数据后，通过观察输出的JSON数据格式，我们可以找到标记的一些数据特征，通过脚本筛选出来进行计算处理，输出成每个事件的耗时记录。再通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ECharts&lt;/code&gt;工具绘制成图表，根据不同的需要输出不同的可视化报告。形成自动化流程后，每个开发阶段都能对游戏的性能有一个合理的把控了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/9hiqEZuVAPmSzos.png&quot; alt=&quot;数据处理与可视化工具&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*数据处理与可视化工具脚本*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/eiIhs5Mj2F8GaHN.png&quot; alt=&quot;每帧Update耗时分析报告&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*每帧Update耗时分析报告*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/F1wLXkmVpvgWtbi.png&quot; alt=&quot;协议耗时报告&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*协议耗时报告*&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;ui打开速度的运行时监测&quot;&gt;UI打开速度的运行时监测&lt;/h3&gt;

&lt;p&gt;UI打开速度是衡量UI性能的一个重要指标，为此我们做了一些相关的工作，用来收集那些需要优化的UI面板以及加载不同阶段的耗时信息。因为UI面板的打开关闭统一抽象成了一个基类，我们可以很方便的加入不同阶段的计时操作，并且只在内部测试环境下开启。&lt;/p&gt;

&lt;p&gt;从创建一个UI面板开始计时，到显示出UI面板时停止，中间依次记录UI打开的若干阶段的耗时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加载资源阶段，包括下载时间，队列中的等待时间，图片解析的时间&lt;/li&gt;
  &lt;li&gt;UI面板在显示前自身的逻辑执行阶段&lt;/li&gt;
  &lt;li&gt;绑定监听事件阶段&lt;/li&gt;
  &lt;li&gt;显示后UI面板的一些逻辑执行阶段&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Laya的资源加载并不会提供详细的计时信息，所以我们需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya.Loader&lt;/code&gt;类中自行记录加载各阶段的耗时，这个需要对&lt;code class=&quot;highlighter-rouge&quot;&gt;laya.core.js&lt;/code&gt;进行一定的拓展，这里就不展开了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们认为一个面板的打开耗时超过 &lt;em&gt;400ms&lt;/em&gt; 即需要优化（只考虑主观感受，不考虑网络环境和设备因素）。当每次打开检查耗时超过400ms时，信息会在本地被收集，除了在日志中打印，也会被上报到管理后台收集。在后台能看到不同设备上的UI打开速度超时报告，一般来说超过400ms打开速度的UI都应该进入待优化列表。&lt;/p&gt;

&lt;p&gt;而具体需要优化的点则可以根据不同阶段的耗时来具体针对性排查和优化：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;比如加载慢，具体是哪个阶段慢？如果是等待时间长，则可能是一个UI所需资源数量过多，导致加载中存在等待的问题&lt;/li&gt;
  &lt;li&gt;如果是下载时间长则考虑图片是否可以压缩，有损还是无损，有损的话可以接受怎样的精度？&lt;/li&gt;
  &lt;li&gt;如果是具体逻辑执行阶段的明显耗时则根据具体代码来进行优化，比如对逻辑重的部分进行摊帧执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/TSzNnGfj3v6mRlK.png&quot; alt=&quot;UI打开速度监测&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*UI打开速度监测和收集的部分代码*&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;静态资源标准检查工具的实现&quot;&gt;静态资源标准检查工具的实现&lt;/h3&gt;

&lt;p&gt;上面提到UI打开速度和面板所依赖的资源规格以及资源数量有较大关系，所以需要对每个UI面板制作时用到的资源进行把控和监测。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;值得一提的是，在上线微信小游戏做适配工作时我们也发现，部分UI贴图规格竟然超过了 &lt;em&gt;2048x2048&lt;/em&gt; 导致纹理报错，而立项时我们和美术协商的贴图规格是最大 &lt;em&gt;1024x1024&lt;/em&gt; 。&lt;/p&gt;

  &lt;p&gt;所以说尽管在立项时就决定了美术产出的规格和精度，但是因为策划或美术的部分需求和创造力表现，或者是人员流动等其他原因，实际执行起来往往会出现执行出格或不到位的问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在推进游戏开发进度的过程中，就像需要&lt;code class=&quot;highlighter-rouge&quot;&gt;code lint&lt;/code&gt;来保证代码的规范性一样，必须存在针对其他方面的静态检测工具或脚本来保证一些标准的落地执行。&lt;/p&gt;

&lt;p&gt;因此我写了一些简单的python脚本，用来扫描游戏内的UI配置、图集以及实际资源规格，来判断是否制作出了超规格的UI面板。项目组根据这些报告，自行定夺是否优化。而优化完成后，再次执行工具，扫描对比后便能看到问题是否依然存在。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/Cgb93RGTNsrAHtB.png&quot; alt=&quot;UI报告&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*UI静态检测报告*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;同理也需要对特效、模型等进行扫描。其实没有任何技术难度可言，只是通过这样的简易自动化工具，便能快速发现一些问题，而不需要等待问题暴露时再去通过排查来定位。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/3NofbjPiZzR1aOI.png&quot; alt=&quot;特效报告&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*特效静态检测报告*&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;内存规模分析与内存泄漏排查&quot;&gt;内存规模分析与内存泄漏排查&lt;/h3&gt;

&lt;p&gt;内存的稳定性直接影响了游戏的稳定性，可以从下面三个角度来看：&lt;/p&gt;

&lt;h4 id=&quot;1内存泄漏&quot;&gt;1.内存泄漏&lt;/h4&gt;

&lt;p&gt;当游戏使用的内存&lt;code class=&quot;highlighter-rouge&quot;&gt;Proportional Set Size&lt;/code&gt;即实际使用的物理内存值（包括按比例计算系统共享库使用的内存）达到系统设定的最大值时，操作系统会强制杀死该进程，并报出&lt;code class=&quot;highlighter-rouge&quot;&gt;Out Of Memory&lt;/code&gt;的错误，这个报错在一些线上项目的&lt;code class=&quot;highlighter-rouge&quot;&gt;Bugly&lt;/code&gt;上经常能看到。如果游戏出现比较频繁的内存泄漏，哪怕每次泄漏分配了很小块的内存但是又没有被释放，也很可能运行三十分钟后内存就爬升到系统设定的阈值因而崩溃。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不同内存的机器和不同系统其应用可使用的内存上限不一样，比如2GB内存的iOS机器允许应用使用的最大内存是1395MB，而4GB的iOS设备则允许到2GB左右，8GB的安卓机器则远大于此。iOS允许应用可使用最大内存值可以参考&lt;a href=&quot;https://stackoverflow.com/questions/5887248/ios-app-maximum-memory-budget/15200855#15200855&quot;&gt;这里&lt;/a&gt;。在iOS13 SDK中，Apple还提供了相关的API来查询设备允许的最大内存值，安卓也有对应的查询方法：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-objectivec highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 要求iOS 13.0&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#import &amp;lt;os/proc.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;os_proc_available_memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;availableSizeOfMemory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iOS&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os_proc_available_memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 要求Android API 1+&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getMemoryThreshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;ActivityManager&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activityManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ActivityManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSystemService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;ACTIVITY_SERVICE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;ActivityManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MemoryInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memoryInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ActivityManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MemoryInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;activityManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMemoryInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memoryInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memoryInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般来说，游戏内内存泄漏的发生场景可能是以下几种，这里只讨论具有现代化的垃圾回收器的语言。需要自己管理内存的C/C++暂时不讨论：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加载的资源用完后没有及时清理，长期占用内存。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;引擎中是需要调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya.loader.clearRes&lt;/code&gt;来清理资源释放内存，否则&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya.Loader.loadedMap&lt;/code&gt;中会一直存在对该资源的引用，其占用的内存也不会被垃圾回收器回收。而在我们排查过程中发现许多业务代码中就存在这些问题，一些副本或面板退出后的特效/icon等资源没有被及时清理。&lt;/li&gt;
  &lt;li&gt;存在全局或静态变量引用而导致无法被垃圾回收的情况。同上，因为对象至始至终都有引用，所以无法被垃圾回收器回收，从而导致泄漏。这需要对模块业务代码进行筛查，在有使用全局或静态变量来记录一些临时对象的地方要谨慎对待。&lt;/li&gt;
  &lt;li&gt;错误使用引擎代码而引起的内存无法回收。开发过程中几乎不可能避免封装，游戏引擎也是高度封装的一种。错误的使用别人封装的模块往往也会导致内存泄漏。像&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;这样有源码的则需要彻读源码了解具体的实现，没有源码的封装则需要详尽阅读模块说明，做到尽可能的符合规范。&lt;code class=&quot;highlighter-rouge&quot;&gt;H2&lt;/code&gt;项目就出现因为错误使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Socket&lt;/code&gt;模块而导致Socket连接断开时字节buffer没有被清理。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么具体如何排查内存泄漏？这就需要一些辅助的工具来发现问题。&lt;/p&gt;

&lt;h5 id=&quot;引擎工具&quot;&gt;引擎工具&lt;/h5&gt;

&lt;p&gt;首先是借助引擎内部的一些debug工具或profile工具来检查无用资源或引擎对象的清理是否正常。如果自己封装了一个管理类，则还要测试管理类的加载和清理策略是否正确，清理策略是否合理。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;H2&lt;/code&gt;项目中，我写了一个实时展示&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;引擎可视对象的数量的统计组件，用来检查游戏内各个功能或场景是否存在引擎对象泄漏的问题。因为项目中的所有可视对象都继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;类，所以可以拿到子类的name，再通过hook其构造和销毁函数统计子对象的数量变化。&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 引擎自定义对像统计CustomStat.ts&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getClassName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Hook Part&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CreatedFunc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;class_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CustomStat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getClassName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;CustomStat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ReportNew&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;class_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;DestroyFunc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;class_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CustomStat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getClassName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;CustomStat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ReportDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;class_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;laya&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CreatedFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;laya&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;destroy&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;DestroyFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/ftY1ZvwISCc3ye2.png&quot; alt=&quot;引擎对象统计&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*引擎对象统计*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们通过反复打开关闭某一功能或进出某场景，再对比统计数量就能看到一些组件的泄漏。这是统计监测引擎对象数量变化的组件，同样我们需要实时能够看到一些贴图资源是否真的从&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya.Loader.loadedMap&lt;/code&gt;中移除并真正的释放内存。如果是通过控制台&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log(Laya.Loader.loadedMap)&lt;/code&gt;观察也可以，但是太过麻烦，并且有时候加载的资源数量达到几百上千条，则会卡控制台。为了解决这个问题，我们拓展了&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;DebugPanel&lt;/code&gt;进行展示，并且通过资源路径来区分不同的资源种类，并提供一些预估值来计算其占用的内存大小。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;引擎本身在&lt;code class=&quot;highlighter-rouge&quot;&gt;laya.debugtool.js&lt;/code&gt;中写了一些用于debug和profile的功能组件，但是不知道为什么官网并没有给出使用说明，可能废弃了大部分功能，只保留了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;DebugPanel&lt;/code&gt;。并且还对DebugPanel的一些代码进行了base64加密，给最初拓展该组件带来了一定的麻烦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/WKXc9ABCgbu3nkh.png&quot; alt=&quot;DebugPanel拓展&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*DebugPanel拓展*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;H2&lt;/code&gt;项目中我使用这两个工具在最后性能收尾阶段跑完了游戏内所有40个功能以及20个副本，发现了数十个泄漏以及代码上的问题并修复。从这个结果上看，引擎层面的工具对游戏的稳定性而言是十分重要的。&lt;/p&gt;

&lt;h5 id=&quot;设备内存&quot;&gt;设备内存&lt;/h5&gt;

&lt;p&gt;以上是游戏引擎层面的工具，在设备/系统方面我们也需要一些工具来确定内存的整体规模和判断是否有内存泄漏的问题。比如在iOS设备上使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode&lt;/code&gt;调试查看应用使用的内存，CPU，网络，甚至耗电情况和原因，当然&lt;code class=&quot;highlighter-rouge&quot;&gt;Android Studio&lt;/code&gt;也基本有同样的功能。这些IDE除了提供查看实时的内存规模变化的功能外，还提供了一些专门检测&lt;code class=&quot;highlighter-rouge&quot;&gt;Leaks&lt;/code&gt;即内存泄漏的功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/lE3WPieXY2dSAgm.png&quot; alt=&quot;使用AS查看应用使用的内存&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*使用Android Studio查看应用使用的内存*&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;和引擎层面排查泄漏同理，通过观察反复进出同一场景/打开同一功能引起的内存规模的波动是否正常，一般就能判断游戏内是否存在内存泄漏问题。&lt;code class=&quot;highlighter-rouge&quot;&gt;H2&lt;/code&gt;项目也因此解决了若干个因为错误使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;引擎的动态合批功能而引起的内存暴涨导致的&lt;code class=&quot;highlighter-rouge&quot;&gt;OOM&lt;/code&gt;问题，将项目内存规模稳定到了Android设备测试环境下400-600MB区间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为项目是多平台发行的，除了传统的iOS/Android设备环境外，还有Chrome以及小游戏环境，同样需要对应的Profile工具来查看内存情况。微信小游戏环境下可以使用安卓设备，运行时打开Profile模式，便可以在右上角看到内存信息，机制与安卓同理。Chrome则可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Shift + Del&lt;/code&gt;打开浏览器的任务管理器，查看页面内存使用情况。如果觉得表格数字不够直观，你也可以使用 &lt;em&gt;GraphProcess&lt;/em&gt; 这款Chrome插件来查看内存变化情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/XxIz7SNTJkH3FYp.png&quot; alt=&quot;使用GraphProcess查看Chrome内存波动&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*使用GraphProcess查看Chrome内存波动*&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;2内存规模&quot;&gt;2.内存规模&lt;/h4&gt;

&lt;p&gt;而除了内存泄漏方面的问题，游戏内整体的内存规模也应该控制在合理水平，才能让更多相对低配的机器能够畅玩。一个游戏对相对低配的设备越友好，潜在的玩家数量也会越大，PUBG除外。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PUBG刚出来的那会，内存管理就做的十分差劲。许多网吧8GB的机器玩起来十分吃力，并且游戏应该存在较为明显的内存泄漏问题，每跳三次伞基本就会发生一次闪退。虽然这样的内存管理拉动了内存条价格飞涨和玩家机器配置的飞升，但是这样的游戏体验也颇为大家诟病。&lt;br /&gt;
在&lt;code class=&quot;highlighter-rouge&quot;&gt;H2&lt;/code&gt;项目中，我们就在优化阶段将小游戏环境下的内存规模优化了&lt;strong&gt;400MB&lt;/strong&gt;左右，使得iPhone7这样的2GB的设备能够正常运行，达到了我们的目标，而在优化前2GB的iOS设备基本只能跑十分钟主线就会被微信杀掉。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在优化游戏整体的内存规模时，需要对优化目标有一个选择。虽然大家都很想要竭尽全力的做好每一处细节使得性能最优，但是出于工作量考量，质量与性能取舍等原因，一个项目不能无限优化。一个针对具体项目的性能期望则是优化收束的终点。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;H2&lt;/code&gt;项目中，我们希望内存优化可以使得&lt;em&gt;iOS 2GB&lt;/em&gt;设备与&lt;em&gt;Android 4GB&lt;/em&gt;设备可以在微信小游戏环境下稳定运行超过&lt;strong&gt;2小时&lt;/strong&gt;。而&lt;em&gt;iOS 1GB&lt;/em&gt;的设备（如iPhone6）从优化开始的阶段就已经被放弃，因为1GB的iOS设备应用可使用的内存阈值也只有645MB左右，并且还需要跑在微信的环境下，可使用的内存更少了，对可接受的游戏品质而言是基本无法做到稳定运行的。&lt;/p&gt;

&lt;h4 id=&quot;3垃圾回收&quot;&gt;3.垃圾回收&lt;/h4&gt;

&lt;p&gt;内存方面还容易出现的一个问题是垃圾回收即&lt;code class=&quot;highlighter-rouge&quot;&gt;Garbage Collection&lt;/code&gt;频率过高，因为现在大部分解释型语言的VM垃圾回收器都是运行在主线程，且或多或少都会引发用户线程暂停执行即&lt;code class=&quot;highlighter-rouge&quot;&gt;Stop The World&lt;/code&gt;，哪怕是&lt;code class=&quot;highlighter-rouge&quot;&gt;Lua 5.3&lt;/code&gt;的步进式GC，每一次Step都需要暂停主线程执行。而即使是&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript V8引擎&lt;/code&gt;做了大量多线程优化后，一次Major GC也要10ms左右。所以过于频繁的GC会导致部分帧渲染耗时飙升，从而造成掉帧卡顿。&lt;/p&gt;

&lt;p&gt;因此在Profile CPU耗时时也需要关注GC的次数是否过于频繁而影响到了性能。如果GC次数过多，则需要进一步判断是否需要使用池技术来减少真实的内存分配和回收的过程。&lt;/p&gt;

&lt;p&gt;那具体怎么做来优化内存规模呢？这个之后在&lt;a href=&quot;/2020/06/01/How-To-Analyze-And-Optimize-Performance-1.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;讲。&lt;/p&gt;

&lt;h3 id=&quot;微信小游戏卡顿问题的定位&quot;&gt;微信小游戏卡顿问题的定位&lt;/h3&gt;

&lt;p&gt;因为这是公司第一款上线微信小游戏的产品，在这方面还没有技术积累。所以小游戏这方面的所有开发Leader全权交给了我去研究和实现。在调通了&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;发布到微信小游戏环境后，我需要做一些适配工作，这个写在了&lt;a href=&quot;/2020/01/18/Laya-Wechat-MiniGame.html&quot;&gt;这篇文章&lt;/a&gt;中。除此之外还写了一个登陆支付的SDK客户端，以及开发一些其他的平台性质的需求比如首屏Loading图加载和播放视频。当然我们也遇到了一些其他的性能问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;5s内收到2次&lt;code class=&quot;highlighter-rouge&quot;&gt;Memory Warning&lt;/code&gt;导致的&lt;code class=&quot;highlighter-rouge&quot;&gt;OOM&lt;/code&gt;被杀问题。这个我通过优化内存规模，排查内存泄漏，调整更为保守的内存Cache策略解决了。&lt;/li&gt;
  &lt;li&gt;一些贴图超&lt;em&gt;2048&lt;/em&gt;导致无法显示，以及一些贴图过高精度导致加载慢，这些通过写的静态扫描工具去排查逐一解决。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;引擎提供的适配层&lt;code class=&quot;highlighter-rouge&quot;&gt;laya.wxmini.js&lt;/code&gt;中存在的一些bug，比如短时间多次请求同一音效资源Cache未拦截后续请求，导致短时间大量播放音效而卡顿的问题，这个通过修复引擎层解决了。&lt;/li&gt;
  &lt;li&gt;小游戏环境下因为性能表现受限，需要限制一些游戏表现和行为。如除主角外其他模型均使用圆影阴影而非实时阴影，限制角色升级这类统计事件上报的频率等。这些通过判断环境做适配区分解决。&lt;/li&gt;
  &lt;li&gt;音效资源比特率未统一，部分音效比特率过高，解码时引起内存大幅度扰动。这个通过统一压缩音效资源比特率解决。&lt;/li&gt;
  &lt;li&gt;如果使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;的缓存策略的同时又使用微信API&lt;code class=&quot;highlighter-rouge&quot;&gt;LogManager&lt;/code&gt;来记录本地日志文件，则会因为二者共享50MB的用户空间而导致&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;自己计算的可使用缓存空间大小错误，因而在用尽本地用户空间时，无法正确的缓存新下载的文件，这个通过改写&lt;code class=&quot;highlighter-rouge&quot;&gt;laya.wxmini.js&lt;/code&gt;中的最大缓存空间为45MB即可，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;LogManager&lt;/code&gt;记录的本地日志文件最大为5MB。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;值得一提的是排查主流程某个性能问题的经历。表现是游戏内主流程跑到某个阶段，必现的加载缓慢，游戏卡顿的问题。我首先确定了使用的资源已经经过压缩，然后通过在引擎层对加载各阶段的耗时统计，以及近N次加载耗时的平均发现了卡顿时的异样表现，最终定位到了原因是在Loader队列中等待的时间过长。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/jqswg41XK582zid.png&quot; alt=&quot;资源加载各阶段的耗时统计&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;
&lt;em&gt;*资源加载各阶段的耗时统计与问题定位*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;通过打印等待队列长度及其内容时发现，卡顿时等待队列最长去到26个待加载资源。而这是因为打开了某个制作未被优化而依赖了十余个icon的UI，或者游戏内主流程在某个阶段进行频繁的场景切换，而大量场景地块、怪物、NPC乃至角色的部分动画都因为Cache策略的调整而未被缓存到内存中，需要重新下载，导致待加载队列过长，从而导致大幅度的下载延时。这一点在其他端没有测出来，但是在小游戏环境下表现颇为明显。&lt;/p&gt;

&lt;p&gt;发现问题后，我们通过将角色全部动画缓存在小游戏的50MB用户空间，使得切换场景时不用下载，以及调整了地块等其他资源的Cache时间，使得其短期内加载更频繁命中缓存，并且优化了有问题的UI面板，使其依赖资源数量大幅度减少，解决了爆表的等待队列问题。&lt;/p&gt;

&lt;h3 id=&quot;微信小游戏缓存50mb策略优化&quot;&gt;微信小游戏缓存50MB策略优化&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;令人欣慰的是，在作者写本文时，微信小游戏本地文件系统最大支持容量已经增加到了200MB，不再拮据，大部分H5游戏兴许也不再需要特意针对优化其缓存策略了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;微信小游戏的文件系统中，本地缓存文件与本地用户文件共享50MB的最大容量，可以参考官方的小游戏基础能力&lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/guide/base-ability/file-system.html&quot;&gt;说明&lt;/a&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先所有的云端游戏资源通过&lt;code class=&quot;highlighter-rouge&quot;&gt;wx.downloadFile&lt;/code&gt;下载到本地临时空间，并会返回一个临时文件路径，你可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;readFile&lt;/code&gt;直接读取加载。该空间不限大小，但是下次冷启动时大概率会被清理，所以没办法用来做持续缓存策略。&lt;/li&gt;
  &lt;li&gt;如果需要缓存该资源，则可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;FileSystemManager.saveFile&lt;/code&gt;接口移动文件到本地缓存空间，本地缓存文件只有在代码包被清理的时会被清理，也就是用户常按删除小程序的时候。该空间与本地用户空间共享50MB大小限制。&lt;/li&gt;
  &lt;li&gt;本地用户空间则是对应&lt;code class=&quot;highlighter-rouge&quot;&gt;wx.env.USER_DATA_PATH&lt;/code&gt;目录，开发者对该空间拥有完全的读写权限，可以通过其他文件接口如&lt;code class=&quot;highlighter-rouge&quot;&gt;FileSystemManager.writeFile&lt;/code&gt;创建文件并写入内容等。该空间与本地缓存空间也共享50MB大小，并且也只有在代码包被清理的时会被清理。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;上文提到的微信的日志API&lt;code class=&quot;highlighter-rouge&quot;&gt;LogManager&lt;/code&gt;记录的日志文件则是存放在本地用户空间下，最大占用5MB，挤占了本地缓存空间的大小，才导致了&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;默认的缓存策略计算可用大小判断是否缓存时的错误。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;引擎提供的&lt;code class=&quot;highlighter-rouge&quot;&gt;laya.wxmini.js&lt;/code&gt;适配层的资源缓存策略是完全在&lt;em&gt;本地用户空间&lt;/em&gt;下做的：下载网络资源后，如果属于图片资源或json资源，则拷贝到本地用户空间下作为缓存文件，然后在本地用户空间下读取该文件，同时更新维护一个本地文件&lt;code class=&quot;highlighter-rouge&quot;&gt;layaairfiles.txt&lt;/code&gt;来管理缓存的URL与对应文件的路径映射用于下次加载时命中缓存，以及记录可用空间大小用于控制整体缓存大小。每次启动游戏时便会根据该文件来反序列化一个内存对象，而新增缓存文件时则又通过序列化更新该文件。&lt;/p&gt;

&lt;p&gt;以上策略都没有问题，问题是当准备缓存的临时文件大小超过了&lt;code class=&quot;highlighter-rouge&quot;&gt;layaairfiles.txt&lt;/code&gt;文件中计算出的可用大小后，&lt;code class=&quot;highlighter-rouge&quot;&gt;Laya&lt;/code&gt;的默认缓存策略会删除最早进入缓存的一批文件(默认是清理出5MB大小的空间，会根据即将缓存的文件大小调整)来为即将缓存的文件腾出空间。但是因为游戏最早的加载阶段，缓存的全是各功能模块依赖最多的公共图集资源。这一部分资源理应常驻缓存，即使删除了则又会马上下载，并且再走一遍移动到缓存空间的过程，且不说这样的操作直接影响资源加载响应的速度，频繁的文件IO也会带来更高的性能开销。而事实上，每当缓存空间满50MB后默认清理5MB空间，根据我们项目的资源加载频率，我们测试平均 &lt;em&gt;10s&lt;/em&gt; 不到便又会出现满50MB的情况。游戏内观察也出现了明显的加载响应慢的问题。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//缓存过滤，只缓存公共图集、UI icon与音效&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;MiniFileMgr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cacheFilter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;RegExp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;(/atlas/|/icon/|/sound/)&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//符合要求的才进入缓存，缓存满后不再进行缓存&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;MiniAdpter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;autoCacheFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isSaveFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;readyUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.php&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MiniFileMgr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cacheFilter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;readyUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;MiniAdpter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;reachMemLimit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;MiniFileMgr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;copyFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tempFilePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;readyUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callBack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isAutoClear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为此我设计了一个针对性的缓存策略，根据请求的URL通过正则匹配，只针对公共图集，UI icon，音效这类频繁使用的资源进行缓存。即我们对进入缓存的资源进行手动选择，尽量充分利用空间大小，并且屏蔽了清理逻辑，当缓存空间满后，不再将临时文件移入缓存。通过统计&lt;code class=&quot;highlighter-rouge&quot;&gt;Network&lt;/code&gt;所有请求中缓存文件&lt;code class=&quot;highlighter-rouge&quot;&gt;http://usr&lt;/code&gt;请求的比例，就能计算出缓存命中率。我们发现同样跑完新手流程，调整缓存策略后缓存命中率比之前还提高了20%。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有趣的是，如果只考虑缓存命中率，降低长时间游戏中的网络开销，可以考虑使用本地临时空间来进行缓存。依据微信官方的说明，本地临时文件只保证在小程序当前生命周期内有效，一旦小程序被关闭就可能被清理，即下次冷启动不保证可用。所以在长时间游戏过程中，可以自己设计一套映射办法，使用本地临时空间中的文件作为缓存文件读取，因为没有大小限制，可以极大提高缓存命中率。但是因为加载阶段下载公共图集等资源需要4-6s，项目更在乎第二次进入游戏的速度，所以我们没有做这方面的考虑。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;关于性能优化我的一些思考&quot;&gt;关于性能优化我的一些思考&lt;/h2&gt;

&lt;p&gt;以上是基于H2项目优化时的一些经验，接下来这部分主要想分享一下我关于性能优化这方面的一些思考和感悟。作为一个零项目经验的人（因为头一年都在做SDK接入与开发，打包分发等移动应用相关的工作），从头到尾经历完整个项目的生命周期后，回过头来思考怎样才能做出一个性能表现不错的项目是一件很有意思的事情。&lt;/p&gt;

&lt;h3 id=&quot;量化&quot;&gt;量化&lt;/h3&gt;

&lt;p&gt;如同市面上的CPU更新时都会和上一代进行算力对比一样，在我们对游戏进行性能优化的过程中，也一定要对前后的具体性能表现进行性能量化，差异对比。否则做了任何一个改动都只能从主观上去臆测，无法知道优化的有效性，也无法直观查看优化的结果。没有量化数据指导的优化工作以及迭代更新不但结果抽象，而且往往会陷入没有目标，没有反馈，优化效率低下，徒劳，甚至负优化的情形中去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/Zc6SU59mPyqYJXN.png&quot; alt=&quot;如JavaScript V8引擎每次有新的技术迭代都会展示优化的结果&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*如JavaScript V8引擎每次有新的技术迭代都会展示优化的结果*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;性能优化离不开量化，而量化则离不开好的工具和模块设计。不过测量性能指标的工具有好有坏，最理想的往往是在设计功能模块时，就已经思考了如何量化这个模块的性能指标，并且随着模块的实现，相应的量化工具也写出来了。比如设计一个协议的收发模块，就要考虑如何方便量化协议的耗时。协议基类可以将收发协议拆分成若干个独立步骤，比如组装，发送，解析，执行，这样在后期量化性能指标的时候，便能非常方便的打点统计，数据清晰，哪里不符合标准也一目了然。在H2项目后期我排查场景、特效模块引起的内存泄漏时，颇有这种遗憾。当业务功能已经铺开或实现完全时，再重新设计模块和规则要求大家一起使用或遵守是不现实的。量化的工具不应该是单独于项目之外的东西，而是随着功能实现同时设计产出的东西。&lt;/p&gt;

&lt;p&gt;那么具体怎么量化呢？这个取决于在做什么样的优化工作。和衡量算法一样，无非是时间和空间两个维度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;时间维度衡量：
    &lt;ul&gt;
      &lt;li&gt;各种模块执行耗时：如一帧Update中各模块的耗时，某个关键步骤或函数的执行时间，打开一个功能或页面需要的时间等。&lt;/li&gt;
      &lt;li&gt;一定时间内事件发生的次数：如同一个场景下一段时间内GC发生的次数，一段时间内某个函数循环的次数等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;空间维度衡量：
    &lt;ul&gt;
      &lt;li&gt;规模大小：如游戏使用的内存大小，显存大小，游戏内各种资源的大小，总包体大小等。&lt;/li&gt;
      &lt;li&gt;空间使用率：如内存中有大量相同的数据如纹理，mesh，动画，音频等，或者缓存了无效资源等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;量化结果需要前后对比才能凸显优化工作的价值，但是一定要注意控制条件变量。当掺杂多个变量时，性能优化前后的对比结果则毫无指导意义。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;自动化监测&quot;&gt;自动化监测&lt;/h3&gt;

&lt;p&gt;自动化是解放生产力的重要因素，而自动化监测性能数据则是在推进游戏开发进度的过程中预防性能表现失控的关键因素。没有自动化监测的工具，则意味着项目组需要投入人力，频繁检查性能表现，排查隐患。何况对人而言，在开发内容快速推进的时候，“排查”是一项费时费力，并且容易有遗漏的工作。在人力有限的情况下，这样做可能会导致开发进度被拖累。&lt;/p&gt;

&lt;p&gt;在H2项目中，随着项目推进总共进行了2次相对集中的性能优化工作。从公司的视角而言，因为我们没有足够的人力持续性的监视着性能数据或者投入到性能优化的工作上去，所以每次只能集中一段时间投入2-3个人对项目的性能表现进行把控和优化。这非常可以理解，哪怕数百人的项目组也经常存在人力紧张的情况。但是问题是这些优化的时间节点往往是性能肉眼可见地出问题了（失控），项目要内测了，项目要上线了这些因素影响的。如果项目本身相对简单，或者初期就有了一定的开发规范，也没有大量的需求改动，那么游戏性能也不会有什么大问题。但是当项目复杂度提升到一定水平时，这样的工作安排往往捉襟见肘。而这就是自动化监测工具需要完成的工作：先于“人眼”报告出游戏的性能问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/jc6BCh4RziQGAHX.png&quot; alt=&quot;自动化监测&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*市面上对产品进行性能、质量、兼容性测试的商业化测试软件PerfDog*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;理想的情况下，从项目一开始便应该投入人力开发一些自动化工具监测性能表现。有别于市面上对完整游戏产品进行质量测试的商业测试软件如&lt;code class=&quot;highlighter-rouge&quot;&gt;PerfDog&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UPR&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Airtest&lt;/code&gt;等等，这些工具理应随着功能模块的开发或规则的制定一起实现，关注一些具有项目个性化关键的性能指标，独立或嵌入模块之内。一般分以下两种形式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;独立于游戏外的静态检测工具，定期执行，扫描出不符合要求的性能相关问题，包括自动运行游戏的脚本。&lt;/li&gt;
  &lt;li&gt;嵌入游戏的动态监测工具，在以测试模式运行时发现问题会弹出警告，收集相关数据并上传到性能后台。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些工具伴随着项目进度的推进，全程监测着性能数据是否符合要求。不必等到问题肉眼可见，一旦出现性能异常，项目组立刻就能响应派遣人力解决，并且制定出新的规范来指导后续的开发工作，避免同类型问题再次出现。显而易见，如果游戏开发到内测全程性能表现处于可控状态，那么最终游戏上线时性能表现也必然不会失控。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;值得注意的是，这样的工具可能很容易实现，但是根据不同项目对不同性能数据设立不同的标准，则对游戏开发经验有很高的要求。即游戏性能与质量二者大多难以兼得，如何设置合理的性能预期也是十分重要的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;可视化&quot;&gt;可视化&lt;/h3&gt;

&lt;p&gt;当你拥有一系列性能指标数据需要对比展示时，使用表格列出各项数据是最简单的，但是这样的形式往往不够直观。尤其是在数据项庞杂的时候，对比每一项数据显得尤其费力，没有重点，并且结论也不够显而易见。比如在寻找帧数剧烈变化的掉帧场景时，如果仅有包含近万条帧率数据的表格而没有折线图，那你很难找到帧率的抖动情况。并且，相比硬生生的丢出一堆数据而不做处理，绘制成可视化图表才是更具艺术、简洁、优雅的报告形式。在现代化工具的帮助下，这也不会耗费多少时间。一般情况下，对数据进行可视化也就这么几步：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过性能测量工具收录数据&lt;/li&gt;
  &lt;li&gt;可能需要通过分析处理工具进行过滤和筛选，将值得关注的信息拣选出来&lt;/li&gt;
  &lt;li&gt;选择合适的图表形式绘制可视化报告&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/01/kBJWrbOQzGsftq8.png&quot; alt=&quot;echarts示例&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 85%;&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*基于JavaScript的开源可视化图表库ECharts示例*&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;图表形式的选择直接影响了报告的直观程度，最常见的帧率变化一般选择折线图，内存变化选择堆叠面积图（如Android Studio的Memory Profile），简单的耗时对比就用柱状图。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;

&lt;h4 id=&quot;设计封装&quot;&gt;设计封装&lt;/h4&gt;

&lt;p&gt;优秀的性能表现离不开优秀的设计和封装。一个模块最核心的部分封装好了，开发人员只需要往模块内部填充业务，哪怕代码水平参差不齐，写的再天马行空，项目也大概率不会出现严重的性能问题。举个例子，一个面板加载的资源和对象组件是否存在泄漏，这个就需要在设计UI模块之时加以考虑。例如我们可以在面板初始化时统一使用某个接口注册加载其依赖的资源和组件，面板销毁时同样由统一接口管理对应资源的清理。这样能有效避免组件或资源泄漏问题，并且即使出现个别代码加载未注册的资源时，也能及时发现并解决。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每个公司都有自己的代码标准或者开发规约，但是开发者执行的好与坏就是体现代码水平的差异了。但是，好的设计与封装就如同硬性的规定，极大的提高了代码水平的下限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;重构&quot;&gt;重构&lt;/h4&gt;

&lt;p&gt;对模块的重构一定要时刻进行，尤其是在业务代码飞速增长的阶段。如同对待性能优化的态度不能是游戏做完再进行性能优化一样，对待重构的态度不可以是全部功能实现完再进行重构。比如在H2项目中，开发各个不同平台的同一功能时，都要判断平台类型，再去调用不同的实现。而在添加第二个各平台都需要的功能时，就要思考之前的设计是否合理，调用日志如何统一，如何兼容没有该功能的平台，考虑怎样设计能够方便之后的拓展和维护。根据经验，哪怕一个很小的模块，经过若干次代码的增长和不同人手的开发后，其结构或多或少的都会变得臃肿不堪，无法直视，大概率出现冗余，或者出现性能问题。严格来讲，&lt;code class=&quot;highlighter-rouge&quot;&gt;Code Review&lt;/code&gt;与重构的时机，就应该像是内存分配器在每次分配内存前会检查是否要进行垃圾回收一样，添加代码前也要先整理一遍代码，思考是否合理，是否需要重构。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;组内Code Review是一项很难在内部推广的事情，除了代码水平参差不齐的问题外，还有一些感性的因素形成阻碍，至少在公司尝试了两次推行组内Code Review失败后我是这么认为的。但是自己对自己写的代码进行Code Review，及时重构是非常有必要的。虽然在版本管理工具的帮助下，大家可以通过blame看到每行代码的作者，但是我认为每个程序员都应该出于本能的在自己写的代码片段“签名”，&lt;code class=&quot;highlighter-rouge&quot;&gt;Review&amp;amp;Refactoring&lt;/code&gt;是对自己工作的一种负责。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;做的一些其他工作&quot;&gt;做的一些其他工作&lt;/h2&gt;

&lt;p&gt;除性能相关的优化工作外，作为引擎我还在H2项目中做了一些其他工作，这里简单列举一些：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;基于Unity Editor拓展开发2D场景编辑器&lt;/li&gt;
  &lt;li&gt;开发Laya IDE拓展（VSCode插件）给美术使用&lt;/li&gt;
  &lt;li&gt;开发了三端（浏览器包括Native WebView，iOS，Android）的本地日志记录与上报模块&lt;/li&gt;
  &lt;li&gt;三端的视频播放功能组件&lt;/li&gt;
  &lt;li&gt;三端的闪屏实现&lt;/li&gt;
  &lt;li&gt;资源更新版本管理机制的研究与资源缓存nginx的配置&lt;/li&gt;
  &lt;li&gt;JavaScript报错堆栈收集与解析服务&lt;/li&gt;
  &lt;li&gt;三端的基础模块如获取设备信息，内存信息，权限申请的开发&lt;/li&gt;
  &lt;li&gt;优化Laya的gulp编译流程，增量编译&lt;/li&gt;
  &lt;li&gt;解决了微信小游戏上线的各种问题包括分包、WSS、闪屏、视频播放等&lt;/li&gt;
  &lt;li&gt;修复了Laya引擎底层的若干漏洞&lt;/li&gt;
  &lt;li&gt;开发与接入微信/QQ小游戏客户端聚合js SDK&lt;/li&gt;
  &lt;li&gt;实现2D的实时阴影&lt;/li&gt;
  &lt;li&gt;安卓WebView端接入X5内核&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;分享了这么多，那么如果给一个既定的项目给我，我该如何下手去优化呢？或者说，关于性能优化，有没有一些普适性的思路和常见的解决办法呢？这部分就留到&lt;a href=&quot;/2020/06/01/How-To-Analyze-And-Optimize-Performance-1.html&quot; target=&quot;_blank&quot;&gt;下一篇&lt;/a&gt;文章去讨论了。&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/guide/&quot;&gt;微信官方文档 - 小游戏&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://v8.dev/blog/trash-talk&quot;&gt;Trash talk: the Orinoco garbage collector - Google V8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 01 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/06/01/How-To-Analyze-And-Optimize-Performance-0.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/06/01/How-To-Analyze-And-Optimize-Performance-0.html</guid>
        
        <category>H5</category>
        
        <category>Laya</category>
        
        <category>性能优化</category>
        
        
        <category>H5</category>
        
      </item>
    
      <item>
        <title>Laya项目轻松上线微信小游戏</title>
        <description>&lt;p&gt;Laya引擎为了H5游戏上线微信等小游戏平台的无缝对接做了许多工作，但是项目上线微信小游戏还是遇到了不少的问题。不过都已经一一解决，现在把收获的经验和解决问题的方法和同学们分享一下。以下我就按照从Laya发布小游戏开始，问题可能出现的顺序简单讨论一下。&lt;/p&gt;

&lt;h2 id=&quot;挂载全局变量到window域&quot;&gt;挂载全局变量到window域&lt;/h2&gt;

&lt;p&gt;将发布的目录导入微信开发者工具中编译后，最容易出现的问题是一些已经引入的js文件中的全局变量报undefined，常见于我们自己写的js库。这个问题和微信的&lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/guide/framework/module.html&quot; target=&quot;_blank&quot;&gt;模块机制&lt;/a&gt;有关，微信的JavaScript引擎与浏览器中的不同，浏览器js执行时默认绑定全局变量到window域。在微信小游戏环境下，Laya导出的index.js中require引入的js文件并不会将其全局变量暴露给其他js文件调用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/27/ZHkmqBbgrAWPFeC.png&quot; alt=&quot;模块机制.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 80%;&quot; /&gt;&lt;br /&gt;
*&lt;em&gt;微信小游戏的模块机制&lt;/em&gt;*&lt;/p&gt;

&lt;p&gt;小游戏环境中其实也有一个类似浏览器中window的全局对象：GameGlobal，且微信官方对此做了一定的polyfill工作，其工程目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;weapp-adapter.js&lt;/code&gt;允许我们只要显示的将全局变量绑定到window域下，即可在其他文件里通过window调用。比如引入了logline.js第三方库，那在该文件中我们可以显示地绑定:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 暴露Logline变量到window域给其他js调用&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Logline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Logline&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其他js文件此时便可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Logline.debug()&lt;/code&gt;方法了。其实可以查看laya.core.js等等laya自己写的js libs文件，都是有做这个处理的。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// laya.core.js Laya version 2.2&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Laya&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...}({}))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;引用第三方domparser库&quot;&gt;引用第三方DOMParser库&lt;/h2&gt;

&lt;p&gt;微信小游戏环境缺少对HTMLDivElement组件的支持(游戏中UI富文本会用到，而大部分浏览器都是支持的)，所以在微信开发者工具中运行时，laya底层库会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;需要引入xml解析文件&lt;/code&gt;的错误。Laya官方给出了&lt;a href=&quot;https://ask.layabox.com/question/13487&quot; target=&quot;_blank&quot;&gt;解决方案&lt;/a&gt;。我们只需要拷贝三个js文件至laya libs库中，并且在主包game.js中引入即可：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// game.js&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;./libs/dom_parser&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;部分api不支持&quot;&gt;部分API不支持&lt;/h2&gt;

&lt;p&gt;检查是否有使用微信小游戏环境不支持的Web API。比如我们项目使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Performance&lt;/code&gt;用于性能统计，在小游戏环境不支持，需要屏蔽掉。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;微信不支持直接通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Performance&lt;/code&gt;来调用，而是做了一层&lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/api/base/performance/wx.getPerformance.html&quot; target=&quot;_blank&quot;&gt;封装&lt;/a&gt;，需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;wx.getPerformance()&lt;/code&gt;来调用，且只支持其部分功能。所以如果发现API不支持，可以先在&lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/api/&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;搜索一下是否有替代办法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;合法域名与https&quot;&gt;合法域名与HTTPS&lt;/h2&gt;

&lt;p&gt;不出意外的话，到这一步已经可以在&lt;strong&gt;微信开发者工具&lt;/strong&gt;中跑通了（因为开发者工具中预览对包体大小没有限制）。记得检查一下是否在&lt;em&gt;详情 - 项目&lt;/em&gt;中勾选了&lt;em&gt;不检查合法域名与HTTPS&lt;/em&gt;。否则就要求网络请求均为https协议，WebSocket连接均为wss协议，且在微信后台&lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/guide/base-ability/network.html&quot; target=&quot;_blank&quot;&gt;配置&lt;/a&gt;后才可以继续运行，这也是真机上预览的要求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/27/3JprQta7wPKUekB.png&quot; alt=&quot;不校验域名.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 60%;&quot; /&gt;    &lt;br /&gt;
*&lt;em&gt;勾选不校验域名&lt;/em&gt;*&lt;/p&gt;

&lt;h2 id=&quot;分包&quot;&gt;分包&lt;/h2&gt;

&lt;p&gt;由于微信小游戏限制每个本地包大小最大为4MB，虽然支持多个分包，但总大小也限制为12MB，且无法动态下载执行js。这就意味着我们需要把所有js代码放在包里，而资源尽量动态加载不要占用宝贵的包体大小。&lt;/p&gt;

&lt;h3 id=&quot;资源单独发布&quot;&gt;资源单独发布&lt;/h3&gt;

&lt;p&gt;相信没有多少中等规模的项目可以将游戏资源总大小控制在12MB以内，所以第一步要做的就是把资源单独抽离出去，发布在线上。为此需要在加载完本地的资源后，设置一下线上资源地址，这一步往往在index.js文件末尾处理，可以参考Laya官方的&lt;a href=&quot;https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-4&quot; target=&quot;_blank&quot;&gt;说明&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// index.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Laya&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;basePath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;https://XXXX.com/&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;拆分bundlejs---大型项目最重要的一步&quot;&gt;拆分bundle.js - 大型项目最重要的一步&lt;/h3&gt;

&lt;p&gt;Laya执行gulp脚本中的打包工具（旧版本使用browserify.js，新版本使用rollup.js）将typescript源码编译生成一份bundle.js，以管理源码各文件模块的依赖关系。但是这也不可避免的导致了项目上架微信小游戏时的窘迫，当项目规模变大时，bundle文件在压缩后也能很轻松地突破4MB的限制（我们目前的项目压缩后的bundle已经有6.2MB）。这还不算上laya引擎的文件（已经有将近1.8MB）以及我们自己写的一些需要预先加载的js文件，这些都是必须放在主包中先加载的。&lt;/p&gt;

&lt;p&gt;所以我们需要使用一些支持拆分bundle的打包工具，将bundle.js拆分成若干部分，使其某一部分可以放在主包先加载，其他部分可以在若干个分包中加载。我第一个想起了webpack。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实在想到用webpack拆分前我也试过很多别的方法，比如升级到Laya 2.3用rollup打包，其比用browserify打包体积可以减少0.2MB（主要归功于ES6），然后删减了所有日志打印、测试类以及性能统计方法，想了很多办法尽量减少压缩后字符数，也只能将bundle再缩减0.2MB，这0.4MB并不能本质上解决问题。恰好我之前在开发H5SDK时接触了webpack，所以才会想到是否可以用webpack的插件来拆分打包，并后来成功验证了这一想法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;webpack很友好的提供了&lt;a href=&quot;https://webpack.js.org/plugins/split-chunks-plugin/&quot; target=&quot;_blank&quot;&gt;splitChunks插件&lt;/a&gt;，本身是用于拆分两个包体的公共代码块的，简单配置一下我们就能将bundle拆分成若干份符合我们大小要求的文件。&lt;/p&gt;

&lt;p&gt;首先我们全局安装需要用到的npm工具。由于我们使用typescript编写项目，所以还需要安装typescript编译需要的一些包。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i typescript  ts-loader clean-webpack-plugin webpack webpack-cli &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt;
npm &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;ts-loader clean-webpack-plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，在工程根路径下只需要&lt;code class=&quot;highlighter-rouge&quot;&gt;npm link&lt;/code&gt;链接全局安装的&lt;code class=&quot;highlighter-rouge&quot;&gt;ts-loader&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;clean-webpack-plugin&lt;/code&gt;两个包。修改工程tsconfig.json：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;compilerOptions&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;commonjs&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;es5&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;es6&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;dom&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;noEmitHelpers&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;sourceMap&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;exclude&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;node_modules&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为我们要用&lt;code class=&quot;highlighter-rouge&quot;&gt;splitChunks&lt;/code&gt;拆分两个bundle的公共代码块，就要新生成一个与主bundle有大量相同代码块的分bundle，所以我们可以选择一些基础模块作为新的打包入口。配置webpack.config.js如下：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CleanWebpackPlugin&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;clean-webpack-plugin&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;distFolder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;./dist&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;production&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./src/Main.ts&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 选择某一个入口文件打包用于拆分与主包相似的代码块，尽量选择一些基础模块&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./src/a.ts&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CleanWebpackPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;devtool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;source-map&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\.&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;tsx&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;$/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;ts-loader&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;exclude&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/node_modules/&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;optimization&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;splitChunks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 配置splitChunks插件&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;chunks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;minSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 拆出来的代码块最小约300kb&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;maxSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 拆出来的代码块最大约3MB&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;extensions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.ts&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;[name].js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__dirname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;distFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在根目录下运行&lt;code class=&quot;highlighter-rouge&quot;&gt;webpack&lt;/code&gt;，会在dist目录下生成打包后的文件以及对应的sourcemap文件。sourcemap文件要保留好，日后出现报错堆栈可以通过该符号文件解析到源码。关于堆栈解析映射可以使用我写的这个&lt;a href=&quot;/2019/09/11/JavaScript-Source-Mapping.html&quot; target=&quot;_blank&quot;&gt;sourcemapping工具&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/28/nwtgkrBPoLDG5sy.png&quot; alt=&quot;dist分包结果.png&quot; data-action=&quot;zoom&quot; style=&quot;max-width: 60%;&quot; /&gt;&lt;br /&gt;
*&lt;em&gt;webpack-splitChunks打包结果&lt;/em&gt;*&lt;/p&gt;

&lt;p&gt;delete.js文件只是我们用来拆分bundle的一个产物，因为其模块也被其他模块所依赖，所以已经被打进公共代码块，故可以将其删除。剩余的js文件则随意分成几个部分，放入小游戏主包与分包中，使其满足4MB大小限制即可。通过微信的分包机制先加载主包，主包中最后再加载各个分包。webpack的加载机制保证了公共代码块乱序引入也可以正确的加载打包模块的依赖关系。所以尽量使主包接近4MB大小限制即可。关于微信的分包实现就不赘述，非常简单可以参考微信官方&lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/guide/base-ability/sub-packages.html&quot; target=&quot;_blank&quot;&gt;文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;真机测试&quot;&gt;真机测试&lt;/h2&gt;

&lt;p&gt;如果已经配置好了https与wss连接，并且实现了分包，那么至此就可以成功在真机上预览以及上传发布了。关于微信小游戏，Laya项目还需要做一些别的优化，比如如何高效利用50MB缓存空间（基于Laya那套管理逻辑再优化），内存监控，日志模块实现等，这些日后看是否有需要单独拿出来讨论。&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/guide/&quot; target=&quot;_blank&quot;&gt;微信开放文档 - 微信&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://webpack.docschina.org/plugins/split-chunks-plugin/&quot; target=&quot;_blank&quot;&gt;splitChunksPlugin - webpack&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-6&quot; target=&quot;_blank&quot;&gt;微信小游戏适配文档 - Laya&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 18 Jan 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/01/18/Laya-Wechat-MiniGame.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/01/18/Laya-Wechat-MiniGame.html</guid>
        
        <category>H5</category>
        
        <category>Laya</category>
        
        <category>小游戏</category>
        
        
        <category>H5</category>
        
      </item>
    
      <item>
        <title>Laya编译发布优化</title>
        <description>&lt;h2 id=&quot;laya-ide编译与发布的一些问题&quot;&gt;Laya IDE编译与发布的一些问题&lt;/h2&gt;

&lt;p&gt;随着游戏开发的推进，越来越多的功能和内容被添加，IDE的编译与发布也越来越慢，逐渐暴露了一些流程问题。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;bundle文件过大需要拆分。假设把sourcemap的内容独立出去，bundle也有9.4MB之大，uglify压缩后也有4MB多。日后稍微更新一点内容，这个庞大的文件就要用户去重新下载。倘若频繁更新发布，网络请求对服务器造成的负担不说，对用户而言加载速度则是很大问题。&lt;/li&gt;
  &lt;li&gt;编译速度太慢。稍微改动一点点内容便要花1分钟去编译与查看效果。&lt;/li&gt;
  &lt;li&gt;browserify打包生成内嵌sourcemap导致bundle膨胀。我们使用2.0的IDE版本，在什么也不修改的情况下，bundle体积已经膨胀到30MB。其中21MB都是browserify打包生成的符号文件sourcemap的内容，被base64编码后添加到bundle的最后一行。&lt;/li&gt;
  &lt;li&gt;Laya压缩混淆js不生成符号文件。发布时勾选Laya IDE中的压缩混淆js选项，js被混淆，却不会生成映射到typescript源码的符号文件。这对发布后收集错误堆栈时的解析有很大影响。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Laya IDE的编译与发布实际上是在IDE安装目录的node环境下执行工程目录下.laya文件夹中的gulp脚本。所以基于以上问题，我对Laya IDE的编译发布脚本做了一些改动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/01/zYWEKolCXImRky7.png&quot; alt=&quot;编译脚本&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;拆分bundle&quot;&gt;拆分bundle&lt;/h2&gt;

&lt;p&gt;首先解决bundle过大的问题。browserify工具没有提供很好的解决方案，但是我们可以很轻松的用webpack对其进行模块拆分。二者都是将typescript进行模块打包，但是webpack很友好的提供了splitChunks的插件，简单配置一下我们就能将bundle拆分若干份符合我们大小要求的文件。这也是我们微信小游戏分包使用的策略。&lt;/p&gt;

&lt;p&gt;首先我们全局安装拆分需要的npm工具。由于我们使用typescript编写项目，所以还需要安装typescript编译需要的一些包。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i typescript  ts-loader clean-webpack-plugin webpack webpack-cli &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt;
npm &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;ts-loader clean-webpack-plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，在工程根路径下只需要链接全局安装的&lt;code class=&quot;highlighter-rouge&quot;&gt;ts-loader&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;clean-webpack-plugin&lt;/code&gt;两个包，修改tsconfig.json：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;compilerOptions&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;commonjs&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;es5&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;es6&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;dom&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;noEmitHelpers&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//需要生成一些helper方法，否则会报__extend undefined&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;sourceMap&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;exclude&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;node_modules&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后配置webpack：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CleanWebpackPlugin&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;clean-webpack-plugin&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;distFolder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;./dist&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;development&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;bundle2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./src/main.ts&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 项目主入口&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;bundle1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./src/a/b.ts&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 另一个入口&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CleanWebpackPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;devtool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;source-map&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\.&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;ts$/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;ts-loader&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;exclude&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/node_modules/&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;optimization&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 配置splitChunks插件，拆分公共的代码块出来&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;splitChunks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;chunks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;minSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 拆出来的代码块最小约300kb&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;maxSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3000000&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 拆出来的代码块最大约3MB&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;extensions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.ts&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;[name].js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__dirname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;distFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在工程目录执行webpack打包后，就可以在dist文件夹下看到拆分后的bundle了。将其引入index.js中即可运行查看效果，推荐在bin目录使用&lt;a href=&quot;https://www.npmjs.com/package/live-server&quot;&gt;live-server&lt;/a&gt;快速搭建http服务器查看效果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;webpack拆分出来的模块可以异步加载，可以打乱顺序引入index.js中运行，这也是微信小游戏分包的关键。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;加快编译速度&quot;&gt;加快编译速度&lt;/h2&gt;

&lt;p&gt;目前工程体量里，typescript源文件有1000多个，执行一次编译需要耗时50多秒。编译时间之久，导致很难实现编写代码-浏览器查看效果-修改代码-浏览器自动刷新查看效果这样理想的工作流了。不过可以通过增量编译来加快编译速度，尽可能实现理想的工作流。关于增量编译可以有三种实现。&lt;/p&gt;

&lt;h3 id=&quot;tsc--w&quot;&gt;tsc -w&lt;/h3&gt;

&lt;p&gt;在Laya2.0版本以前，项目并不会用import，export去管理模块关系，每个js文件都是全局执行，顺序引入，所以可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;tsc -w -p . --outDir bin/js&lt;/code&gt;命令开启typescript增量编译输出js文件，然后用脚本处理index.js依照依赖关系顺序引入执行。使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-w&lt;/code&gt;选项开启增量编译后，每修改一个typescript文件就会在毫秒内编译成js。浏览器刷新后就能立刻看到效果。这是最符合理想情况的开发环境了，但是考虑到现有的项目都是模块化编写，写法不同于全局变量的方式，不同模块间都有import与export引用关系。使用&lt;code class=&quot;highlighter-rouge&quot;&gt;tsc&lt;/code&gt;编译出来的js文件并不能顺序执行，这也是需要打包的原因。所以最后也没有使用这种方案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;想要获取源码文件的依赖关系顺序，可以使用&lt;a href=&quot;https://github.com/dependents/node-dependency-tree&quot;&gt;dependency-tree&lt;/a&gt;工具。&lt;br /&gt;
想要浏览器监测到文件变化自动刷新，推荐使用&lt;a href=&quot;https://www.npmjs.com/package/webpack-dev-server&quot;&gt;webpack-dev-server&lt;/a&gt;或者是&lt;a href=&quot;https://www.npmjs.com/package/live-server&quot;&gt;live-server&lt;/a&gt;工具，使用webpack打包或者自行修改一些js代码时，比起耗费编译的大量时间用Laya的运行调试来看效果，不如使用本地工具快速跑一个http服务器来测试。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;watchify&quot;&gt;watchify&lt;/h3&gt;

&lt;p&gt;第二种方法是继续使用browserify打包，同时使用watchify工具。可以参考&lt;a href=&quot;https://v3.gulpjs.com.cn/docs/recipes/fast-browserify-builds-with-watchify/&quot;&gt;gulp官网&lt;/a&gt;使用watchify进行增量编译。这需要修改编译脚本.laya/compile.js，安装两个npm包:&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i watchify gulp-util -g

&lt;span class=&quot;c1&quot;&gt;# 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;LayaAirIDE_2.0.2\resources\app
npm &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;watchify gulp-util
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后修改Laya工程根目录.laya中的compile.js编译脚本，以下提供compile.js&lt;strong&gt;&lt;em&gt;添加或修改&lt;/em&gt;&lt;/strong&gt;的部分用于参考:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//添加引用watchify&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;watchify&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ideModuleDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;watchify&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;gutil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ideModuleDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;gulp-util&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;watchify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;browserify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;basedir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;workSpaceDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//是否开启调试，开启后会生成jsmap，方便调试ts源码，但会影响编译速度&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;src/Main.ts&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;packageCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;plugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tsify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//使用tsify插件编译ts&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bundleOnWatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;增量编译耗时&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toLocaleString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;检测到文件更改，开始增量编译...&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//使用source把输出文件命名为bundle.js&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;bundle.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//把bundle.js复制到bin/js目录&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gulp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;workSpaceDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/bin/js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toLocaleString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;编译完成!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;timeEnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;增量编译耗时&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//使用browserify，转换ts到js，并输出到bin/js目录&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;gulp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;prevTasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/**
   * ...省略
   * */&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//使用source把输出文件命名为bundle.js&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;bundle.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 把bundle.js复制到bin/js目录&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gulp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;workSpaceDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/bin/js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bundleOnWatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 每次监测到typeScript文件改变时执行打包&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;gutil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 将日志打印到控制台&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实测效果第一次编译和正常编译一样，需要50s，但是增量编译缩短至25s，打包速度提升了50%，如果不需要调试文件即&lt;code class=&quot;highlighter-rouge&quot;&gt;debug: false&lt;/code&gt;，增量编译缩短至19s。再使用热重载的本地http服务器，勉强可以实现相对理想的工作流。&lt;/p&gt;

&lt;h3 id=&quot;webpack-watch&quot;&gt;webpack –watch&lt;/h3&gt;

&lt;p&gt;webpack4本身的打包速度就比Laya使用的browserify快，同样的项目体量，不生成sourcemap符号文件，browserify需要42s，webpack打包只需要37秒。并且使用&lt;code class=&quot;highlighter-rouge&quot;&gt;webpack --watch&lt;/code&gt;开启增量编译模式后，第一次以后的打包时间缩短到18秒，再配置webpack-dev-server实现自动reload，这样的工作流也算是比较理想了。&lt;/p&gt;

&lt;h2 id=&quot;编译browserify打包时拆分出独立sourcemap文件&quot;&gt;编译browserify打包时拆分出独立sourcemap文件&lt;/h2&gt;

&lt;p&gt;如果继续使用browserify，在工程体量变大后还会遇到一个问题就是browserify打包生成的是inline-sourcemap，内嵌到bundle.js文件中。如果不做改动，现在编译出一个bundle可以达到30MB，其中base64编码后的sourcemap内容占21MB，先不考虑发布是否压缩的问题，连内网浏览时去下载执行js都需要耗很长的时间，游戏此间一直为白屏。为此可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;exorcist&lt;/code&gt;抽离出sourcemap为独立文件。需要安装&lt;code class=&quot;highlighter-rouge&quot;&gt;exorcist&lt;/code&gt;包:&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i exorcist -g

&lt;span class=&quot;c1&quot;&gt;# 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;LayaAirIDE_2.0.2\resources\app
npm &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;exorcist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后修改Laya工程根目录.laya中的compile.js编译脚本，以下提供compile.js&lt;strong&gt;&lt;em&gt;添加或修改&lt;/em&gt;&lt;/strong&gt;的部分用于参考:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 提取分离sourcemap&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;exorcist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ideModuleDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;exorcist&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 使用browserify，转换ts到js，并输出到bin/js目录&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;gulp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;prevTasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/**
   * ...
   * */&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browserify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;basedir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;workSpaceDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 是否开启调试，开启后会生成jsmap，方便调试ts源码，但会影响编译速度&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;src/Main.ts&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;packageCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 使用tsify插件编译ts&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;plugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tsify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 分离sourcemap&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exorcist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;workSpaceDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/bin/js/bundle.js.map&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 使用source把输出文件命名为bundle.js&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;bundle.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 把bundle.js复制到bin/js目录&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gulp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;workSpaceDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/bin/js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/01/PsJnZLhbz8e4kGm.jpg&quot; alt=&quot;分离sourcemap&quot; data-action=&quot;zoom&quot; /&gt;&lt;br /&gt;
*&lt;em&gt;被分离后的bundle与sourcemap文件&lt;/em&gt;*&lt;/p&gt;

&lt;h2 id=&quot;发布时生成sourcemap&quot;&gt;发布时生成sourcemap&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/01/iBYR5TsDKc7jyzo.jpg&quot; alt=&quot;laya发布&quot; data-action=&quot;zoom&quot; /&gt;
*&lt;em&gt;laya发布界面&lt;/em&gt;*&lt;/p&gt;

&lt;p&gt;发布时Laya提供压缩混淆js的选项，其使用&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp-uglify&lt;/code&gt;进行压缩，却不生成sourcemap符号文件，给开发者日后解析外网收集的报错带来了不少困难。为此需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp-sourcemaps&lt;/code&gt;，在uglify压缩过程生成sourcemap文件，并且最好还能与上一步&lt;code class=&quot;highlighter-rouge&quot;&gt;browserify&lt;/code&gt;打包分离出来的sourcemap文件合并成一个map文件，可以直接从js混淆后代码映射到typescript源码。为此需要npm安装&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp-sourcemaps&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i gulp-sourcemaps -g

&lt;span class=&quot;c1&quot;&gt;# 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;LayaAirIDE_2.0.2\resources\app
npm &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;gulp-sourcemaps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后修改Laya工程根目录.laya中的publish.js发布脚本，以下提供publish.js&lt;strong&gt;&lt;em&gt;添加或修改&lt;/em&gt;&lt;/strong&gt;的部分用于参考:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 引入gulp-sourcemaps生成sourcemap&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sourcemaps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ideModuleDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;gulp-sourcemaps&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**
 * ...
 * */&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 压缩js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;gulp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;compressJs&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;compressJson&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;compressJs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;gulp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;compressJsFilter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sourcemaps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loadMaps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;largeFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;uglify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;warn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sourcemaps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;sourcemaps&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addComment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gulp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;releaseDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**
 * ...
 * */&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;gulp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;publish&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;version2&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
     * ...
     * */&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 删除编译打包过程中生成的符号文件&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tmpSourcemapFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;releaseDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/js/bundle.js.map`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;existsSync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tmpSourcemapFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unlinkSync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tmpSourcemapFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;All tasks completed!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;外网收集的报错堆栈如何解析请参考我的另一篇文章&lt;a href=&quot;/2019/09/11/JavaScript-Source-Mapping.html&quot;&gt;sourcemapping-JavaScript混淆堆栈解析映射工具&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;关于linux下命令行工具的讨论&quot;&gt;关于Linux下命令行工具的讨论&lt;/h2&gt;

&lt;p&gt;最终我们使用Linux机器执行发布编译，使用的是Laya官方提供的&lt;code class=&quot;highlighter-rouge&quot;&gt;layaair2-cmd&lt;/code&gt;这个npm工具，用于命令行编译与发布，实际上也是执行的gulp脚本。但是linux上没有Laya IDE，使用的是机器全局的node环境。所以可以全局安装以上依赖的npm包，手动修改&lt;code class=&quot;highlighter-rouge&quot;&gt;layaair2-cmd&lt;/code&gt;工具中的编译发布脚本即可实现以上的特性。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;官方提供的命令行工具&lt;code class=&quot;highlighter-rouge&quot;&gt;layaair2-cmd&lt;/code&gt;经常还未开发测试完成便发布新版本，从1.3.0以后的版本开始，到目前最新发布的1.4.5都没法正常跑编译与发布，建议保留1.2.0版本，不要轻易升级。并且命令行工具版本与Laya引擎版本有对应关系，也不建议轻易升级Laya引擎版本。像这样关键内容的版本发布如此随意，可以看出Laya内部并没有做很好的流程管理和版本控制。希望还是能把流程把控好，虽然可能效率低一些，但是正式和规范更能够赢得开发者的信任。多学习crbug.com管理和修复Chrome的流程，一个庞大且优秀的项目，只有流程化规范化才能走的更远。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://v3.gulpjs.com.cn/docs/recipes/fast-browserify-builds-with-watchify/&quot;&gt;使用watchify加速browserify编译 - Gulp&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/watchify&quot;&gt;watchify - npm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/exorcist&quot;&gt;exorcist - npm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/gulp-sourcemaps&quot;&gt;gulp-sourcemaps - npm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/live-server&quot;&gt;live-server - npm&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 01 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/01/Laya-Compile-Optimization.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/01/Laya-Compile-Optimization.html</guid>
        
        <category>H5</category>
        
        <category>Laya</category>
        
        
        <category>H5</category>
        
      </item>
    
      <item>
        <title>JavaScript混淆堆栈本地解析映射工具</title>
        <description>&lt;h2 id=&quot;为什么要写这个工具&quot;&gt;为什么要写这个工具&lt;/h2&gt;

&lt;p&gt;发布环境的产品都经过压缩混淆，并且没有attach sourcemap。因此前端收集到的错误堆栈都是被混淆过的，文件与行号列号变量名都可能发生了变化。因此需要通过sourcemap文件映射到源码上去。如果使用typescript编译+压缩混淆生成的sourcemap文件，可以直接映射到typescript源码。因此针对前端&lt;code class=&quot;highlighter-rouge&quot;&gt;window.onerror&lt;/code&gt;捕获到的错误堆栈写了这样一个工具用于解析与映射，已经在&lt;a href=&quot;https://www.npmjs.com/package/sourcemapping&quot;&gt;npm&lt;/a&gt;发布。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/09/11/ynP6tEe3Nwo9Tpb.png&quot; alt=&quot;npm发布.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;使用方法&quot;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;需要传入2个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;window.onerror中捕获的JSON.stringfy(errorObj.stack)即需要被解析的堆栈字符串
    &lt;blockquote&gt;
      &lt;p&gt;e.g.&lt;br /&gt;
ReferenceError: exclued is not defined\n &lt;br /&gt;
  at getParameterByName (http://localhost:7777/aabbcc/logline.min.js:1:9827)\n &lt;br /&gt;
  at http://localhost:7777/aabbcc/index.js:15:11&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;存放sourcemap文件的路径，绝对路径或相对路径都可以
    &lt;blockquote&gt;
      &lt;p&gt;e.g. ./test&lt;br /&gt;
注意：sourcemap文件命名规则为各压缩混淆工具的默认规则，即:javascript文件名.map，需要直接存放在传入的路径下&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Usage: sourcemapping [options]

Options:
  -v, --version         output the version number
  -s, --stack &amp;lt;string&amp;gt;  stack string which can obtain from JSON.stringfy(Error.stack)
  -m, --map &amp;lt;string&amp;gt;    sourcemap dir path. Where to find sourcemap
  -h, --help            output usage information

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sourcemapping -s &quot;ReferenceError: exclued is not defined\n    at getParameterByName (http://localhost:7777/aabbcc/logline.min.js:1:9827)\n    at http://localhost:7777/aabbcc/index.js:15:11&quot; -m &quot;./test&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;输出&quot;&gt;输出&lt;/h2&gt;

&lt;p&gt;默认输出到控制台&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;----Sourcemap Result----
Uncaught ReferenceError: exclued is not defined
    at Logline (../src/logline.js:62:31)
    at (index.js:15:11)
------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;github源码&quot;&gt;&lt;a href=&quot;https://github.com/7ippo/sourcemapping&quot;&gt;☆Github源码☆&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// sourcemapping.ts
#!/usr/bin/env node

import * as path from 'path';
import * as ErrorStackParser from 'error-stack-parser';
import * as commander from 'commander';
import { readFileSync, existsSync } from 'fs';
import { SourceMapConsumer } from 'source-map';

let raw_stack_string_array: string[];

function stackStringProcess(value: any, previous: any): string {
    // input '\n' will be translated into '\\n' and cause ErrorStackParser parsing failure
    raw_stack_string_array = value.split(String.raw`\n`);
    return raw_stack_string_array.join('\n');
}

function printToConsole(error_msg: string, stack_frames: ErrorStackParser.StackFrame[]): void {
    console.log(&quot;----Sourcemap Result----&quot;)
    console.log(error_msg);
    for (const frame of stack_frames) {
        let msg = &quot;    at &quot;;
        if (frame.functionName) msg += frame.functionName + &quot; &quot;;
        msg += &quot;(&quot;;
        if (frame.fileName) msg += frame.fileName + &quot;:&quot;;
        if (frame.lineNumber) msg += frame.lineNumber + &quot;:&quot;;
        if (frame.columnNumber) msg += frame.columnNumber;
        msg += &quot;)&quot;;
        console.log(msg);
    }
    console.log(&quot;------------------------&quot;)
}

async function loadAllConsumer(dir_path: string, stack_frame_array: ErrorStackParser.StackFrame[],
    sourcemap_map: Map&amp;lt;string, SourceMapConsumer&amp;gt;) {
    // load all sourcemap files into memory
    const sourcemap_list = new Set();
    const regExp = /.+\/(.+)$/;
    for (const frame of stack_frame_array) {
        if (frame.hasOwnProperty('fileName')) {
            const name = regExp.exec(frame.fileName)[1];
            frame.fileName = name;
            if (!sourcemap_list.has(name)) {
                sourcemap_list.add(name);
                let sourcemap_filepath = path.join(dir_path, name + '.map');
                if (existsSync(sourcemap_filepath)) {
                    let sourcemap: any;
                    try {
                        sourcemap = JSON.parse(readFileSync(sourcemap_filepath, 'utf-8'))
                    } catch (error) {
                        console.error('Read&amp;amp;Parse sourcemap:' + sourcemap_filepath + 'failed. ' + error.toString());
                        process.exit(0);
                    }
                    const consumer = await new SourceMapConsumer(sourcemap);
                    !sourcemap_map.has(name) &amp;amp;&amp;amp; sourcemap_map.set(name, consumer);
                }
            }
        }
    }
}

const program = new commander.Command();
program.version('1.0.8', '-v, --version');
program.option('-s, --stack &amp;lt;string&amp;gt;', 'stack string which can obtain from JSON.stringfy(Error.stack)', stackStringProcess);
program.option('-m, --map &amp;lt;string&amp;gt;', 'sourcemap dir path. Where to find sourcemap');
program.parse(process.argv);

if (program.stack &amp;amp;&amp;amp; program.map) {
    const msgExp = /^(.+)\n/;
    const msg = msgExp.exec(program.stack)[1];
    if (!msg) {
        console.error('Error message parsing failed, please check input stack which must contain error message. \ne.g. Uncaught ReferenceError: a is not defined\\n');
        process.exit(0);
    }
    let error_obj: Error = {
        'stack': program.stack,
        'message': msg,
        'name': msg.split(':')[0]
    }
    let stack_frame_array: ErrorStackParser.StackFrame[] = [];
    try {
        stack_frame_array = ErrorStackParser.parse(error_obj)
    } catch (error) {
        console.error('ErrorStackParser parsing failed' + error.toString());
        process.exit(0);
    }

    const sourcemap_map = new Map&amp;lt;string, SourceMapConsumer&amp;gt;();

    // load all sourcemap files
    loadAllConsumer(program.map, stack_frame_array, sourcemap_map).then(() =&amp;gt; {
        // parse stack_frame_array
        stack_frame_array.forEach(stack_frame =&amp;gt; {
            let name = stack_frame.fileName;
            if (sourcemap_map.has(name)) {
                let consumer = sourcemap_map.get(name);
                let origin = consumer.originalPositionFor({
                    line: stack_frame.lineNumber,
                    column: stack_frame.columnNumber
                });
                if (origin.line) stack_frame.lineNumber = origin.line;
                if (origin.column) stack_frame.columnNumber = origin.column;
                if (origin.source) stack_frame.fileName = origin.source;
                if (origin.name) stack_frame.functionName = origin.name;
            }
        });

        // print result
        printToConsole(program.msg, stack_frame_array);
    });

    // destroy all consumers
    for (let consumer of Array.from(sourcemap_map.values())) {
        consumer.destroy();
    }
} else {
    console.error(&quot;No error stack string OR error msg string OR sourcemap dir found. Please Check input.&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 11 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/09/11/JavaScript-Source-Mapping.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/11/JavaScript-Source-Mapping.html</guid>
        
        <category>H5</category>
        
        <category>npm</category>
        
        <category>工具</category>
        
        
        <category>H5</category>
        
      </item>
    
      <item>
        <title>Chrome调试关联本地sourcemap文件</title>
        <description>&lt;h2 id=&quot;why&quot;&gt;Why&lt;/h2&gt;

&lt;p&gt;外网发布环境都是被混淆的JavaScript代码，因为发布环境下不会保存或关联sourcemap(否则混淆没有任何意义了)，所以日志与报错的堆栈都指向混淆后的代码。开发人员持有sourcemap文件，除了有本地解析映射的需求外，有时也存在直接调试外网混淆代码的需求，这时候就可以关联上本地的sourcemap文件，对线上的混淆代码进行映射和解析，直观反映成源码，可以通过Chrome自带功能解决该需求。&lt;/p&gt;

&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;本地有对应线上混淆JavaScript文件的sourcemap文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;方法&quot;&gt;方法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;F12打开Chrome - dev-tool - Sources&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/09/10/TIt6r3jyeOfMbQB.png&quot; alt=&quot;步骤1.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选中被混淆的代码，或者通过控制台的链接打开被混淆的代码&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/09/10/BQN51ou4vdqnteI.png&quot; alt=&quot;步骤2.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;右键 - Add source map&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/09/10/BqWGS4PQCbfw5Xc.png&quot; alt=&quot;步骤3.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过file协议选择本地的map文件,先在浏览器地址栏中输入确保可以访问到。&lt;br /&gt;
e.g. file:///D:/H5Research/CatchJSError/logline.min.js.map
&lt;img src=&quot;https://i.loli.net/2019/09/10/sYdumbNcy2XJ5Qa.png&quot; alt=&quot;步骤4.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加后Sources左侧栏出现源码&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/09/10/XAC2MaUj9yqlvKt.png&quot; alt=&quot;步骤5.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;回到控制台发现已经映射到源码了&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/09/10/C9kYeTNK83L6ZUd.png&quot; alt=&quot;步骤6.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 11 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/09/11/Chrome-Devtool-Mapping-Sourcemap.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/11/Chrome-Devtool-Mapping-Sourcemap.html</guid>
        
        <category>H5</category>
        
        <category>Chrome</category>
        
        
        <category>H5</category>
        
      </item>
    
      <item>
        <title>H5游戏缓存策略的讨论</title>
        <description>&lt;h2&gt;缓存策略的几个思考点&lt;/h2&gt;
&lt;p&gt;对于H5游戏，缓存的使用主要考虑几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;热更新&lt;/li&gt;
&lt;li&gt;在确保缓存命中率的情况下，合理控制缓存大小&lt;/li&gt;
&lt;li&gt;尽可能减少网络请求，减轻服务器压力&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;浏览器的缓存控制的几种方式及其利弊&lt;/h2&gt;
&lt;h3&gt;版本控制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;通过&lt;strong&gt;版本控制&lt;/strong&gt;，通过gulp工具添加md5后缀改资源文件名，可以实现热更。当资源发生更新，通过版本管理工具同步更新引用该资源的位置，指向新的文件。请求的url发生变化，浏览器便不会读取缓存。假如再通过&lt;code&gt;Cache-Control:max-age&lt;/code&gt;或&lt;code&gt;Expire&lt;/code&gt;设置一个很长的缓存有效期，比如1年，那么在没有发布更新时，缓存的使用率是100%，且不会发生网络请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;弊端&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;当大文件采取版本管理频繁更新时，会出现缓存大小膨胀的情况。e.g.一份压缩后2.3M的主逻辑js文件&lt;code&gt;bundle-md5.js&lt;/code&gt;，如果发布10次更新，每次更新生成不同的文件名。那么如果用户恰好在每次更新后打开游戏，便会在浏览器内存中缓存11份不同md5后缀的该文件，直接占用25.3M的缓存空间，这还只是更新内容的一小部分。缓存大小随更新发布的急速膨胀也会导致触发某些浏览器环境如小程序中的限制：缓存大小达到一定标准(&lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/guide/base-ability/file-system.html&quot;&gt;微信小游戏50MB限制&lt;/a&gt;)，后续请求的结果将无法写入缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/01/5d429eab611c431148.png&quot; alt=&quot;Chrome中的多份同文件缓存&quot; width=&quot;500&quot; data-action=&quot;zoom&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*使用&lt;code&gt;ChromeCacheViewer&lt;/code&gt;可以看到存在多份同文件不同后缀名的缓存*&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;Cache-Control:no-cache&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;通过在响应头添加&lt;code&gt;Cache-Control:no-cache&lt;/code&gt;实测在主流浏览器环境中都可以实现热更新。每次浏览器请求资源前都会携带缓存文件的缓存指示去找服务器验证，如果资源没更新，服务器返回304，浏览器就从本地缓存中读取。如果资源有更新，服务器返回最新资源，浏览器读取并且更新本地缓存。可见不管更新几次，本地缓存中有且仅有一份资源，解决了版本管理的弊端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，ETag作为缓存指示正在被大型网站弃用：主要原因是大部分CDN服务器开启了gzip压缩，而同一份文件(主要是css/js，图片压缩率不高一般不会压缩)在不同配置下执行gzip压缩后无法保证其唯一性，这会导致ETag失效，所以&lt;a href=&quot;https://help.aliyun.com/knowledge_detail/40071.html&quot;&gt;nginx官方在开启gzip模块后会移除ETag&lt;/a&gt;。另外如果可以忽略在1秒内多次更新的情况，使用Last-Modified可以实现同样的功能，还能节约服务器计算资源。IETF没有规定ETag的计算方法，具体实现由不同服务器(Apache Nginx Tengine)自己决定。所以ETag是否会因为负载均衡策略导致同一份资源在不同服务器上计算结果不同我们不得而知，为了不浪费带宽资源，还是建议&lt;strong&gt;关闭ETag&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/01/5d429eaab482f33401.png&quot; alt=&quot;gzip与ETag&quot; width=&quot;500&quot; data-action=&quot;zoom&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*从缓存文件中可以看到内容编码是gzip便不会有ETag指示*&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;弊端&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;直接走协商缓存，跳过了强缓存命中的阶段，每次请求资源时都会发Validation请求给服务器校验资源是否最新。对于不频繁更新的一些资源来说，服务器频繁建立TCP连接的开销应该纳入考量，这样消耗服务器带宽和计算资源是否有必要还需要讨论。如果可以接受每请求一个资源都发起一个网络请求，那所有资源都使用该策略即可。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;Cache-Control:max-age&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;按照RFC的解释，在响应头添加max-age指示，意味着响应的内容从生成之时起(服务器时间)，在经过max-age指定的时间后才失效。也就是说在浏览器先走强缓存，判断缓存的Age是否有效。有效时间内的缓存命中则不会发起网络请求，超出有效时间即缓存陈旧(stale)则需要发起Validation请求验证资源是否有更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;浏览器只会保存一份缓存副本，且在缓存有效期内再次请求资源时不会发起HTTP请求，服务器压力最小。缓存失效后又会通过Validation请求校验实现更新资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;弊端&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;缓存有效时间内，无法实现热更新，所以一般不会单独采用这个策略，而是结合版本控制一起做。判断缓存是否有效这个阶段属于浏览器的执行逻辑，除了外加别的方案比如代码检测到更新强制获取最新文件外没法改动。&lt;/p&gt;
&lt;h2&gt;方案一 较复杂的细分方案及其标准&lt;/h2&gt;
&lt;p&gt;为了能满足我们之前提的三点需求，我们先将游戏资源文件按照&lt;strong&gt;修改频次&lt;/strong&gt;、&lt;strong&gt;文件大小&lt;strong&gt;、&lt;/strong&gt;有无强热更要求&lt;/strong&gt;三个方面进行细分，再去讨论对应策略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高频修改的定义：每&lt;strong&gt;3&lt;/strong&gt;次更新中会更改到的文件属于高频修改文件，否则属于低频修改文件；&lt;/li&gt;
&lt;li&gt;大文件的定义：单个文件超过&lt;strong&gt;1MB&lt;/strong&gt;大小属于大文件，否则属于小文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：对于css/js/json文件通常开启gzip编码压缩后进行HTTP传输，衡量时1MB标准线应适用于压缩后大小，对于png/jpg等不压缩的资源则为原大小。&lt;em&gt;1MB标准线的划分参考于本地25751条Chrome缓存文件，只有15条缓存文件大小超过1MB。另外标准划分不同项目有不同需求，还需要后续调整。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;高频大/小文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;即便是高频修改的小文件，若使用版本管理修改文件名，更新次数多了也可能浪费不少缓存空间。为避免缓存大小膨胀，必须保证浏览器对一个资源多个版本只保留一份副本。所以不使用版本管理来控制，不改文件名。建议针对这类资源使用响应头添加&lt;code&gt;Cache-Control:no-cache&lt;/code&gt;策略。&lt;/li&gt;
&lt;li&gt;相关文件类型：主逻辑js、入口html文件，入口js，version.json这类映射文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;低频大/小文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为更新频次低，建议使用版本管理。&lt;code&gt;Cache-Control:max-age&lt;/code&gt;策略设置缓存有效期为&lt;strong&gt;半年&lt;/strong&gt;。因为使用了版本管理，缓存有效期已经没有了意义，设置久一点减少网络请求。这意味着顶多半年后，才会对这个资源发起一次Validation请求，这对于一个H5游戏的生命周期来说已经足够长了。这样一来极大的减少了网络请求数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么&lt;code&gt;max-age&lt;/code&gt;不设置更久? 半年比于一年对服务器来说每年一个资源就多一次请求差别不大，设置什么都可以。&lt;br /&gt;
设置短一点，缓存过期之后会被清理吗? 不会。除非主动去清理，浏览器和微信小程序都不会自动清理过期的缓存文件。对于&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/ability/file-system.html&quot;&gt;微信小程序&lt;/a&gt;而言，缓存文件会随代码包被清理而一块删除。而代码包在用户长期不打开的情况下会被微信清理，以及用户手动删除小程序时被清理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;相关文件类型：字体资源ttf(这个缓存文件为什么占8MB这么大)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;除此以外，低频可以根据更新的可能性再做细分：普通低频(偶尔修改)与超低频文件(没有特殊情况不会修改)。普通低频文件可以设置max-age为&lt;strong&gt;1个月&lt;/strong&gt;，超低频文件设置为&lt;strong&gt;一年&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;有强热更要求的大文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为避免缓存大小膨胀，不使用版本管理修改文件名，同时使用&lt;code&gt;Cache-Control:no-cache&lt;/code&gt;策略&lt;/li&gt;
&lt;li&gt;相关文件类型：loading&lt;em&gt;bg.png login&lt;/em&gt;bg.png logo.png等大场景图、大图集与logo/icon这类可能发生版权问题要替换的资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;有强热更要求的小文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;相关文件类型：重要但是没有特殊情况不会修改的文件，比如做数据统计的js脚本。策略同低频文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;方案二 代码控制更新方案&lt;/h2&gt;
&lt;p&gt;如果要考虑控制缓存大小，就不推荐用版本管理。但是又同时要求热更新，使用&lt;code&gt;no-cache&lt;/code&gt;响应头的话又没法减少过多的网络请求数量。浏览器缓存策略的选择其实是相互矛盾、需要取舍的。换一个角度的话，我们可以弃用版本管理，不改文件名，所有文件通过max-age设置一个较长的缓存有效时间比如半年。然后每次游戏打开时：代码控制发送一个网络请求，携带当前游戏的版本号。根据版本号生成一个差异文件清单返回给客户端(类似&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache&quot;&gt;H5应用缓存机制&lt;/a&gt;，虽然该标准已经被废弃)，然后再通过&lt;code&gt;XMLHttpRequest&lt;/code&gt;加上强制刷新的请求头&lt;code&gt;Cache-Control:no-cache&lt;/code&gt;与&lt;code&gt;Pragma:no-cache&lt;/code&gt;提前获取差异文件列表中的最新资源，下载下来以更新本地的旧缓存。那么在缓存有效期内，真正请求该资源时，会直接读取缓存中的内容，不会再发生网络请求。&lt;/p&gt;
&lt;p&gt;该方案的优势是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存大小最优化，每个文件本地只会存在一份缓存副本&lt;/li&gt;
&lt;li&gt;解决热更问题的同时最小化网络请求的数量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;劣势是这样提前下载更新缓存，某些更新了的资源如果玩家没有用到，也下载了下来，没有做到按需加载。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果把差异文件列表存储起来，重写Laya的网络请求类，每次网络请求前去判断当前请求的资源是否属于差异文件(即是否是旧资源)，如果是则在请求头中添加强制刷新字段获取最新资源，如果不是则使用本地缓存。这样就可以做到按需加载，也能保持该方案的优势。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;微信小程序缓存大小限制50MB环境下的缓存方案&lt;/h2&gt;
&lt;p&gt;无论使用上面的哪一种方案，缓存大小在几次更新后必定会超出50MB，触发微信小游戏的缓存限制条件，这也要求面向小程序环境的项目还需要做一些特殊处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果不做特殊缓存策略，那么在小程序环境中会自动缓存前期网络请求的50MB资源文件到本地(一些文件类型不会自动缓存)，超过50MB后会抛出写入缓存失败的事件，每个没有被缓存的资源都要走网络请求。&lt;/li&gt;
&lt;li&gt;如果使用&lt;a href=&quot;https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-5&quot;&gt;Laya的自动缓存管理策略&lt;/a&gt;，超过50MB后每次按资源时间清理最早的一部分文件,清理的空间大小可以配置。但是早期的资源被清理后，下次又要重新请求，逻辑上不太正确。&lt;/li&gt;
&lt;li&gt;Laya允许关闭自动缓存策略，通过Laya封装的微信Adapter调用下载和清理方法，手动去下载文件缓存到本地,手动清理控制缓存在50MB以内。对此可以每个项目维护一个缓存文件清单，把重要的大文件列入，缓存在客户端本地，再结合以上的缓存控制方案保证缓存文件的新鲜度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参考链接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jb51.net/article/132710.htm&quot;&gt;关于HTTP传输中gzip压缩的分析 - 脚本之家&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/pdfrfc/rfc7234.txt.pdf&quot;&gt;Hypertext Transfer Protocol (HTTP/1.1): Caching - RFC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.nirsoft.net/utils/chrome_cache_view.html&quot;&gt;ChromeCacheViewer - Chrome缓存分析工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/ability/file-system.html&quot;&gt;文件系统 - 微信小程序官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-5&quot;&gt;微信小游戏的50M物理缓存管理 - Laya&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 02 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/02/Discuss-H5-Game-Cache-Strategy.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/02/Discuss-H5-Game-Cache-Strategy.html</guid>
        
        <category>H5</category>
        
        <category>HTTP</category>
        
        <category>缓存</category>
        
        
        <category>H5</category>
        
      </item>
    
      <item>
        <title>一首诗</title>
        <description>&lt;p&gt;你我都是孩子，&lt;/p&gt;

&lt;p&gt;你却像我的影子，&lt;/p&gt;

&lt;p&gt;陪伴是彼此存活的方式，&lt;/p&gt;

&lt;p&gt;也让你我成为彼此最珍贵的，最难以割舍的&lt;/p&gt;

&lt;p&gt;挚友。&lt;/p&gt;

&lt;p&gt;热切的讨论让我们忘了明天，&lt;/p&gt;

&lt;p&gt;嬉笑和打闹留在了这个房间，&lt;/p&gt;

&lt;p&gt;以至于分别时会止不住想念。&lt;/p&gt;

&lt;p&gt;过了多少日子依然会想起，&lt;/p&gt;

&lt;p&gt;和你认识是在南京湛蓝清澈的秋天。&lt;/p&gt;

&lt;p&gt;或许是从那时起，&lt;/p&gt;

&lt;p&gt;我便不再像年轻时一样空谈往后，&lt;/p&gt;

&lt;p&gt;而是知道了余生漫漫，道阻且长。&lt;/p&gt;

&lt;p&gt;不过有你，路走起来也不那么苦涩，&lt;/p&gt;

&lt;p&gt;因为你一笑啊，&lt;/p&gt;

&lt;p&gt;我就拥有了整个世界。&lt;/p&gt;

&lt;p&gt;近来托朋友给你带了香榭的落叶，&lt;/p&gt;

&lt;p&gt;又计划着和你去远方看碧草蓝天。&lt;/p&gt;

&lt;p&gt;心有所想，若有所思&lt;/p&gt;

&lt;p&gt;全系着你的影子。&lt;/p&gt;

&lt;p&gt;我最珍爱的挚友，&lt;/p&gt;

&lt;p&gt;你的每一步，也是我丈量自己的样子，&lt;/p&gt;

&lt;p&gt;你活着，就是我存活的方式。&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/01/A-Poem.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/01/A-Poem.html</guid>
        
        <category>随笔</category>
        
        
        <category>lover</category>
        
      </item>
    
      <item>
        <title>浅谈浏览器缓存机制与H5游戏缓存策略</title>
        <description>&lt;h2&gt;缓存类型&lt;/h2&gt;
&lt;p&gt;HTTP缓存有很多种，广义上分为共享缓存(public)和私有缓存(private)。共享缓存包括代理缓存、网关缓存、CDN、反向代理缓存和负载均衡器等，本文讨论的是私有缓存：浏览器缓存。从H5游戏开发的角度看，如何在解决不同浏览器环境下缓存带来的热更新问题的同时，最大化利用缓存是追求的目标，为此需要了解缓存机制，制定一个合适的缓存策略并验证分析其正确性。&lt;/p&gt;
&lt;h2&gt;先了解浏览器的缓存逻辑&lt;/h2&gt;
&lt;h3&gt;1. 第一次请求&lt;/h3&gt;
&lt;p&gt;第一次请求，因为浏览器没有缓存该内容，所以缓存不会命中。向服务器请求资源返回的响应头中，会有缓存结果和缓存指示(directives)，浏览器将内容和缓存指示一同存入缓存中。&lt;/p&gt;
&lt;h3&gt;2. 第二次请求同样的资源&lt;/h3&gt;
&lt;p&gt;浏览器在缓存中找到该资源的缓存指示，根据指示选择之后的缓存策略。根据是否需要向服务器重新发起HTTP请求，我们可以将缓存过程分为两个部分，分别是强缓存和协商缓存。&lt;/p&gt;
&lt;h4&gt;1)强缓存阶段&lt;/h4&gt;
&lt;p&gt;不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size栏显示from disk cache(从硬盘缓存读取)或from memory cache(从内存缓存读取)。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c3f553ed4f29614.png&quot; alt=&quot;图1，强缓存命中&quot; data-action=&quot;zoom&quot; /&gt;&lt;br /&gt;
强缓存可以通过设置三种 HTTP Header 实现：&lt;code&gt;Expires&lt;/code&gt;，&lt;code&gt;Pragma&lt;/code&gt; 和 &lt;code&gt;Cache-Control&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;Expires: Wed, 19 Jun 2019 15:00:00 GMT&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Expires&lt;/strong&gt; :&lt;br /&gt;
&lt;strong&gt;HTTP/1.0&lt;/strong&gt;的产物，属于HTTP响应的头部字段，值为HTTP Date类型，指定了所请求的资源到期的具体时间。浏览器在下一次请求时会判断本地时间，如果没有超过Expires设置的过期时间，则直接从缓存中读取，否则需要发起HTTP请求。但是需要说明的是，&lt;code&gt;Expires&lt;/code&gt;已经被&lt;code&gt;Cache-Control&lt;/code&gt;替代，如果响应头中存在&lt;code&gt;Cache-Control&lt;/code&gt;控制缓存过期时间的字段，则&lt;code&gt;Expires&lt;/code&gt;会被忽略。P.S. 搭建的HTTP服务器使用的HTTP/1.1协议，抓包没有看到响应中有&lt;code&gt;Expires&lt;/code&gt;字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;Pragma:no-cache&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Pragma&lt;/strong&gt; :&lt;br /&gt;
&lt;strong&gt;HTTP/1.0&lt;/strong&gt;的产物，属于HTTP请求与响应通用的头部字段，只有一个&lt;code&gt;no-cache&lt;/code&gt;命令，行为与&lt;code&gt;Cache-Control: no-cache&lt;/code&gt;一致，优先级低于&lt;code&gt;Cache-Control&lt;/code&gt;。作为请求头时作用是强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行验证，确保返回最新资源(强制刷新时浏览器会在请求头中加入&lt;code&gt;Pragma:no-cache&lt;/code&gt;)。作为响应头时行为不统一，依赖浏览器具体实现，所以该字段不可靠。MDN建议只在需要兼容 &lt;code&gt;HTTP/1.0&lt;/code&gt; 客户端的场合下应用 Pragma 首部。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c9f23dfecd58526.png&quot; alt=&quot;强刷新请求头中的Pragma字段与Cache-Control字段&quot; data-action=&quot;zoom&quot; /&gt;  
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;Cache-control: must-revalidate,no-cache,no-store,no-transform,public,private,proxy-revalidate,max-age=&amp;lt;seconds&amp;gt;,s-maxage=&amp;lt;seconds&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt; :&lt;br /&gt;
&lt;strong&gt;HTTP/1.1&lt;/strong&gt;的产物，属于HTTP请求与响应通用的头部字段,命令可用于控制内容可缓存性、到期时间、是否重新验证和重新加载等。可通过组合命令实现具体的缓存策略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;no-cache&lt;/code&gt;: 作为请求头时同Pragma字段行为一致，强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行验证，确保返回最新资源，强制刷新请求会携带该字段。作为响应头时表现为客户端在使用缓存前需要发送请求验证缓存可用，即跳过强缓存，进行协商缓存。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;: 设置缓存有效的最大周期，超过这个时间缓存被认为过期(单位秒)，需要重新向服务器请求资源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;must-revalidate&lt;/code&gt; :  只能作为响应头字段，指示一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存服务器不能用该资源响应后续请求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public/private&lt;/code&gt;: &lt;code&gt;public&lt;/code&gt;表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，&lt;code&gt;private&lt;/code&gt;表明响应只能被用户缓存，不能作为共享缓存（即代理服务器不能缓存）。&lt;/p&gt;
&lt;p&gt;其他字段含义可参考&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control&quot;&gt;MDN&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;2)协商缓存阶段&lt;/h4&gt;
&lt;p&gt;协商缓存就是强制缓存失效后，浏览器携带缓存指示向服务器发起请求，由服务器根据缓存指示决定是否使用缓存的过程。协商缓存使用的缓存指示存在请求和响应的HTTP头部中，包括&lt;code&gt;响应头Last-Modified/请求头If-Modified-Since&lt;/code&gt;和&lt;code&gt;响应头ETag/请求头If-None-Match&lt;/code&gt;。协商缓存的结果有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;协商缓存失效，服务器返回200和最新资源&lt;/li&gt;
&lt;li&gt;协商缓存有效，服务器返回304 Not Modified，浏览器从缓存中读取对应资源&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;Last-Modified: Wed, 19 Jun 2019 15:00:00 GMT
If-Modified-Since: Wed, 19 Jun 2019 15:00:00 GMT&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Last-Modified/If-Modified-Since&lt;/strong&gt;:&lt;br /&gt;
服务器会在响应头部添加&lt;code&gt;Last-Modified&lt;/code&gt;字段，值为资源在服务器上的最后修改时间。浏览器将该缓存指示同缓存结果一同存入缓存中。浏览器请求资源时，如果存在&lt;code&gt;Last-Modified&lt;/code&gt;字段，会把该值通过&lt;code&gt;If-Modified-Since&lt;/code&gt;字段添加到请求头中。服务器再次收到这个资源请求，会根据&lt;code&gt;If-Modified-Since&lt;/code&gt;中的值与服务器中该资源的最后修改时间对比。如果没有变化，返回304和空的响应体，浏览器直接从缓存读取。如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c40d1e448c35360.png&quot; alt=&quot;Last-Modified Example&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;ETag: W/&amp;quot;2251799814418149-5669-2019-06-18T12:14:19.152Z&amp;quot;
If-None-Match: W/&amp;quot;2251799814418149-5669-2019-06-18T12:14:19.152Z&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ETag/If-None-Match&lt;/strong&gt;:&lt;br /&gt;
&lt;code&gt;ETag&lt;/code&gt;是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。只要资源有变化，&lt;code&gt;ETag&lt;/code&gt;就会重新生成。服务器通过比较客户端传来的&lt;code&gt;If-None-Match&lt;/code&gt;跟自己服务器上该资源的&lt;code&gt;ETag&lt;/code&gt;是否一致来决定返回结果。如果不一致，GET返回200，新资源和新&lt;code&gt;ETag&lt;/code&gt;，一致则返回304 Not Modified。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;ETag与Last-Modified对比&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;精确度上&lt;code&gt;ETag&lt;/code&gt;要优于&lt;code&gt;Last-Modified&lt;/code&gt;。&lt;code&gt;Last-Modified&lt;/code&gt;的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的&lt;code&gt;Last-Modified&lt;/code&gt;其实并没有体现出来修改，但是&lt;code&gt;ETag&lt;/code&gt;每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的&lt;code&gt;Last-Modified&lt;/code&gt;也有可能不一致。&lt;/li&gt;
&lt;li&gt;性能上ETag要逊于&lt;code&gt;Last-Modified&lt;/code&gt;，毕竟&lt;code&gt;Last-Modified&lt;/code&gt;只需要记录时间，而&lt;code&gt;ETag&lt;/code&gt;需要服务器通过算法来计算出一个hash值。&lt;/li&gt;
&lt;li&gt;优先级上服务器校验优先考虑&lt;code&gt;ETag&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;打开页面的方式影响浏览器缓存的使用逻辑&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;地址栏回车：浏览器先查看请求资源有无缓存，无缓存则向服务器请求资源。若该资源有缓存则根据缓存指示采用对应缓存策略。先查找强缓存，强缓存有效则直接使用缓存200(from cache)，强缓存无效则走协商缓存返回304 Not Modified或返回最新资源200&lt;/li&gt;
&lt;li&gt;F5/ctrl+R：刷新页面。仅请求该页面，并跳过强缓存阶段，走协商缓存，所以会向服务器发送协商请求，返回304 Not Modified或返回最新资源200。注意：该页面所引用的资源不会跳过强缓存，且对Chrome而言，在页面通过地址栏回车的方式打开与页面相同URL的行为等同于刷新&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c3ee62087918381.png&quot; alt=&quot;图7：F5刷新逻辑&quot; data-action=&quot;zoom&quot; /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+F5/ctrl+shift+R：强制刷新页面及页面所引用的资源，跳过所有缓存阶段，无论如何都会向服务器发送请求，强制返回最新资源200&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c3f0d7522c59021.png&quot; alt=&quot;图8强刷&quot; data-action=&quot;zoom&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;H5游戏应该选择怎样的缓存策略&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;游戏入口index.html确保不被缓存，游戏依赖的资源文件通过gulp构建工具做版本管理&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每次更新文件内容时，更改文件名加上md5后缀。因为入口引用的资源名称变了，浏览器会直接请求新的资源。当没有变化时，又会直接读取缓存。这一步一些H5游戏引擎如laya已经实现了，通过修改laya的gulp脚本，可以自定义修改构建的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如何确保入口不被缓存？我们可以使用meta标签的&lt;code&gt;http-equiv&lt;/code&gt;属性把content内容添加到HTTP响应的头部信息，但是默认的HTTP服务器(比如自己搭建的node http服务器)不会在响应时根据meta标签来处理头部信息。这种情况下需要通过&lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_headers_module.html&quot;&gt;nginx设置&lt;/a&gt;显示地在请求index.html的响应头中加入这些字段。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--meta标签--&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Cache-Control&amp;quot; content=&amp;quot;no-cache,max-age=0,must-revalidate&amp;quot;&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Expires&amp;quot; content=&amp;quot;0&amp;quot;&amp;gt;  &lt;!--兼容HTTP/1.0--&gt;
&amp;lt;meta http-equiv=&amp;quot;Pragma&amp;quot; content=&amp;quot;no-cache&amp;quot;&amp;gt; &lt;!--兼容HTTP/1.0--&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;// nginx设置
add_header Pragma no-cache;
expires    epoch;

// 注:expires epoch语法等同于设置Expires字段为Thu, 01 Jan 1970 00:00:01 GMT以及Cache-Control字段为no-cache
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c4766e27bf98921.png&quot; alt=&quot;nginx设置后&quot; data-action=&quot;zoom&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*上图为nginx设置应用在&lt;a href=&quot;http://develop.h5game.com/h5client1/web/index.html&quot;&gt;内网H5RPG项目&lt;/a&gt;的结果*&lt;/em&gt;  
&lt;/p&gt;
&lt;h2&gt;不同浏览器环境的表现验证&lt;/h2&gt;
&lt;p&gt;缓存机制的逻辑最终还是由浏览器来实现，部分浏览器不一定严格遵守W3C的规范，为此需要验证不同浏览器环境下我们选择的缓存策略表现。我们选择&lt;a href=&quot;http://develop.h5game.com/h5client1/web/index.html&quot;&gt;内网H5RPG项目&lt;/a&gt;来进行多种浏览器环境的测试。nginx设置如下:&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c7b516a40c14526.jpg&quot; alt=&quot;nginx设置&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;验证方法：&lt;/p&gt;
&lt;p&gt;PC开热点让手机连接，在不同的浏览器环境中测试我们使用的缓存策略，使用Wireshark抓包查看请求和响应。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开/允许使用缓存&lt;/li&gt;
&lt;li&gt;第一次请求资源&lt;/li&gt;
&lt;li&gt;第二次请求资源(&lt;strong&gt;不使用刷新&lt;/strong&gt;)查看是否会向服务器发送请求(检查是否使用强缓存)，只要发送了请求，则使用的协商缓存，达到预期的效果，实现了热更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Chrome&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;: &lt;em&gt;Chrome 74.0.3729.169(Release)(64 bit)&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;是否有请求&lt;/strong&gt;:&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c7e8a6f56d95279.png&quot; alt=&quot;Chrome第二次请求&quot; data-action=&quot;zoom&quot; /&gt;&lt;br /&gt;
&lt;strong&gt;结论&lt;/strong&gt;: 只有两个请求，分别是index.html以及version.json，并且使用协商缓存返回304，其余资源都是直接读取缓存。符合预期。&lt;/p&gt;
&lt;h3&gt;Safari&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;: &lt;em&gt;iPhone 7 iOS 12.2&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;是否有请求&lt;/strong&gt;:&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c812e6e33774720.png&quot; alt=&quot;Safari第二次请求&quot; data-action=&quot;zoom&quot; /&gt;&lt;br /&gt;
&lt;strong&gt;结论&lt;/strong&gt;: 只有两个请求，分别是index.html以及version.json，并且使用协商缓存返回304，其余资源都是直接读取缓存。符合预期。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用iPhone Safari测试，需要关闭无痕模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Wechat Browser&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;: &lt;em&gt;WeChat 7.0.4&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;是否有请求&lt;/strong&gt;:&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c83aee434831989.png&quot; alt=&quot;微信浏览器第二次请求&quot; data-action=&quot;zoom&quot; /&gt;
&lt;strong&gt;结论&lt;/strong&gt;: 同样只有两个请求，并且使用协商缓存返回304，其余资源都是读取缓存。符合预期。&lt;/p&gt;
&lt;h3&gt;X5 Core(TBS) apk&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;: &lt;em&gt;TBS V4.5 43646&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;是否有请求&lt;/strong&gt;:&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c9a3604ea782416.png&quot; alt=&quot;X5内核默认设置不缓存&quot; data-action=&quot;zoom&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*demo默认设置不使用缓存，相当于强刷*&lt;/em&gt;  
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c9a82afa7273901.png&quot; alt=&quot;修改CacheMode后符合预期&quot; data-action=&quot;zoom&quot; /&gt;&lt;br /&gt;
&lt;em&gt;*设置WebView CacheMode后使用协商缓存*&lt;/em&gt;  
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;: X5 WebView默认情况下不使用缓存，所有GET请求都会带上no-cache请求头去获取最新资源，每次进入apk都相当于强制刷新。需要设置&lt;code&gt;CacheMode&lt;/code&gt;，设置后正常走协商缓存，符合预期。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;webSetting.setCacheMode(IX5WebSettings.DEFAULT_CACHE_CAPACITY);&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;最后制作一张流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/21/5d0c9e04485d821258.png&quot; alt=&quot;GET请求浏览器缓存流程图&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ&quot;&gt;HTTP 缓存 - MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/54cc04190252&quot;&gt;深入理解浏览器的缓存机制 - 简书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/pdfrfc/rfc7234.txt.pdf&quot;&gt;Hypertext Transfer Protocol (HTTP/1.1): Caching - RFC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 21 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/06/21/Small-Talk-About-Browser-Cache.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/21/Small-Talk-About-Browser-Cache.html</guid>
        
        <category>H5</category>
        
        <category>HTTP</category>
        
        <category>缓存</category>
        
        
        <category>H5</category>
        
      </item>
    
      <item>
        <title>Unity入门:编写一个2D Roguelike游戏</title>
        <description>&lt;p&gt;跑完了Unity官方的Basic Tutorial Demo后，意犹未尽的下载了一个Tutorial Project Demo:2D Roguelike。跟着官方的&lt;a href=&quot;https://unity3d.com/cn/learn/tutorials/s/2d-roguelike-tutorial&quot;&gt;教程&lt;/a&gt;从头开始做了一个Roguelike类型的2D生存游戏，每一关随机生成地图，食物和敌人。玩家要尽可能到达更高的关数。每天晚上跟着码代码和理解，花了两天时间终于build出来了windows版本的游戏，自己玩了玩还挺有意思，虽然有一个碰撞的bug...不过也算是上手了Unity的编辑器，对游戏这个概念有一个从代码到动画表现上的多层次理解。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c5492e939016.png&quot; alt=&quot;Windows Build&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;对游戏以及Unity一些浅薄的理解&lt;/h2&gt;
&lt;p&gt;对这个游戏以及Unity有了一些浅薄的理解:  
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们看到的游戏中的物体都被看做是一个对象，&lt;strong&gt;GameObject&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象的形态外貌（&lt;strong&gt;Sprite Render&lt;/strong&gt;）由我们赋予，比如人物场景等任何元素的样子。外形是对象的一个属性，我们可以赋值成一些贴图。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象的动画由一帧一帧的图片组成，动画（&lt;strong&gt;Animator&lt;/strong&gt;）也是对象的一个可以被添加的属性，可以被添加移除以达到复用效果的属性更应该被称为组件（&lt;strong&gt;Component&lt;/strong&gt;）。我们可以设置动画播放的快慢，是否连续播放，是否不可被打断等动画效果，也可以通过代码控制动画播放的时机。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于动画有一个有意思的事情，就是动画有限状态机。其负责播放动画，以及在不同动画状态间来回切换。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c55bbff23067.png&quot; alt=&quot;AnimationController&quot; data-action=&quot;zoom&quot; /&gt;&lt;br /&gt;
比如Demo中的主角，当玩家没有指令时，为状态一：这个状态下动画控制器（Animator Controller）就负责循环播放“PlayerIdle”（待机）这个动画，表现是主角一直在“呼吸抖动”&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c55cc8646305.png&quot; alt=&quot;AnimationController2&quot; data-action=&quot;zoom&quot; /&gt;&lt;br /&gt;
当触发被攻击或者破坏墙壁的这两件事件时，代码通过Animator  Controller切换动画状态。被攻击事件时切换到“PlayerChop”状态，预先设定是进入这个状态后播放一次然后退出，所以主角动画表现是被攻击晃了一下，然后又回到“PlayerIdle”这个状态，循环播放待机动画。&lt;br /&gt;
也就是说，动画控制器负责播放动画（包括播放几次，速度快慢，几个动画状态），代码控制怎么在动画状态之间切换，何时进入，何时退出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象组件Component的理解：为了让我们的对象具有某些特性，我们还需要添加一些Component组件，其实际上是让这个对象拥有多一些其他类所拥有的方法和属性。比如这个Demo中，我们把主角和敌人视作可以检测碰撞的刚体，所以都加了Box Collider 2D和Rigidbody 2D两个组件。在控制这两种对象时，我们就可以使用这两种类中的方法来检测碰撞，然后扣取主角的生命值。墙体只检测碰撞来阻止敌人和主角移动，所以都添加Box Collider 2D组件。至于对象之间的互动，何时互动，我们都是通过C#代码来操控的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;地图大小固定是8x8的方块，因为是Roguelike的游戏，墙（可以被主角攻击打碎），敌人，地面上的水果食物都是根据关数在一个范围内随机生成（UnityEngine的Random类），在8x8地图上随机摆放，下一关入口则固定在右上方，主角每一关一开始都出现在左下角。&lt;br /&gt;
&lt;img src=&quot;https://i.loli.net/2019/05/25/5ce905c57b0dc60751.png&quot; alt=&quot;Game&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个demo还涉及一些简单的UI和音频，分别通过Text类和AudioSource类来实现，通过脚本设置内容，在移动或被攻击的时候去更新内容，字体和颜色等属性可以在Unity中通过Text Component来改，也可以通过脚本GetComponent来修改。&lt;/p&gt;   
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;游戏设计需要面向对象&lt;/h2&gt;
&lt;p&gt;设计这些游戏对象的方法，我们肯定是采用面向对象的编程方法，极大的节省了代码量和维护成本，更好理解对象之间的行为方式。对于这个很简单的Roguelike游戏，我们可以设计这么几个类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GameManager类：用于管理整个游戏基本的初始化，随机地图生成，以及游戏基本逻辑（每个回合敌人都会移动），还有过场动画，角色死亡动画等;&lt;/li&gt;
&lt;li&gt;MovingObject类：考虑到主角和敌人都会移动，可以设计这样一个类，用于解决对象的移动表现（从一个地块到相邻的地块其实动画上可以有很多表现形式，具体怎么表现需要代码决定），是否可以移动（是否遇到障碍了）以及处理对象之间的碰撞关系（设计一个抽象类，由具体类去实现）;&lt;/li&gt;
&lt;li&gt;Player类：继承MovingObject类，处理详细的逻辑，比如向墙壁、食物、敌人移动分别是什么表现，还得检查食物是否小于0（死亡）;&lt;/li&gt;
&lt;li&gt;Enemy类：有点像写AI的移动逻辑了，每个回合什么表现，遇到主角时播放攻击动画等都由这个类控制;&lt;/li&gt;
&lt;li&gt;BoardManager类：地图场景的管理类，具体怎么生成随机地图，怎么生成墙体、食物、敌人，随机位置还不可以重复;&lt;/li&gt;
&lt;li&gt;Wall类：除了周围的碎石，场景中间的石块也是有表现的，可以被击碎，所以也要写一个具体的类来描述这一类对象;&lt;/li&gt;
&lt;li&gt;SoundManager类：管理背景音乐的循环播放。  
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;采用面向对象的编程方法，设计由顶向下，对整体的概念就会非常清晰，可以一点一点实现细节，也不会出现后期发现设计有问题，要推倒重来的情况。如果你思维很健壮，能考虑很多情况和可能性，还可以避免很多bug，亦或者是使很多bug更容易理解。比如这个例子中，只有主角和敌人可以移动，那就设计一个MovingObject的类，把二者通用的属性和方法都写进去，然后单独设计主角和敌人时，只需要继承这个类，实现独有的逻辑即可。  
&lt;/p&gt;
&lt;h2&gt;也只是刚刚入门&lt;/h2&gt;
&lt;p&gt;经过了这么一个demo，基本有了对小型简单游戏的设计理解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有了一个比较好的idea后，能描述出游戏的雏形，核心玩法是什么，特色是什么，实现机制是什么？比如Roguelike，就是地牢生存，特点是随机事件；&lt;/li&gt;
&lt;li&gt;思考如何设计游戏中的对象，和对象间的互动；&lt;/li&gt;
&lt;li&gt;在纸上画出游戏的各个元素，动画，原型，音效，用代码合理的组织起来；&lt;/li&gt;
&lt;li&gt;通过代码实现具体表现。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 28 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/28/Unity-Write-A-2DRoguelike-Game.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/28/Unity-Write-A-2DRoguelike-Game.html</guid>
        
        <category>Unity</category>
        
        <category>C#</category>
        
        
        <category>技术</category>
        
      </item>
    
  </channel>
</rss>
