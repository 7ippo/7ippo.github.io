<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Laya编译发布优化 | Tingsven’s blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Laya编译发布优化" />
<meta name="author" content="周子博" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Laya IDE编译与发布的一些问题 随着游戏开发的推进，越来越多的功能和内容被添加，IDE的编译与发布也越来越慢，逐渐暴露了一些流程问题。 bundle文件过大需要拆分。假设把sourcemap的内容独立出去，bundle也有9.4MB之大，uglify压缩后也有4MB多。日后稍微更新一点内容，这个庞大的文件就要用户去重新下载。倘若频繁更新发布，网络请求对服务器造成的负担不说，对用户而言加载速度则是很大问题。 编译速度太慢。稍微改动一点点内容便要花1分钟去编译与查看效果。 browserify打包生成内嵌sourcemap导致bundle膨胀。我们使用2.0的IDE版本，在什么也不修改的情况下，bundle体积已经膨胀到30MB。其中21MB都是browserify打包生成的符号文件sourcemap的内容，被base64编码后添加到bundle的最后一行。 Laya压缩混淆js不生成符号文件。发布时勾选Laya IDE中的压缩混淆js选项，js被混淆，却不会生成映射到typescript源码的符号文件。这对发布后收集错误堆栈时的解析有很大影响。 Laya IDE的编译与发布实际上是在IDE安装目录的node环境下执行工程目录下.laya文件夹中的gulp脚本。所以基于以上问题，我对Laya IDE的编译发布脚本做了一些改动。 拆分bundle 首先解决bundle过大的问题。browserify工具没有提供很好的解决方案，但是我们可以很轻松的用webpack对其进行模块拆分。二者都是将typescript进行模块打包，但是webpack很友好的提供了splitChunks的插件，简单配置一下我们就能将bundle拆分若干份符合我们大小要求的文件。这也是我们微信小游戏分包使用的策略。 首先我们全局安装拆分需要的npm工具。由于我们使用typescript编写项目，所以还需要安装typescript编译需要的一些包。 npm i typescript ts-loader clean-webpack-plugin webpack webpack-cli -g npm link ts-loader clean-webpack-plugin 其中，在工程根路径下只需要链接全局安装的ts-loader clean-webpack-plugin两个包，修改tsconfig.json： { &quot;compilerOptions&quot;: { &quot;module&quot;: &quot;commonjs&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [ &quot;es6&quot;, &quot;dom&quot; ], &quot;noEmitHelpers&quot;: false, //需要生成一些helper方法，否则会报__extend undefined &quot;sourceMap&quot;: false }, &quot;exclude&quot;: [ &quot;node_modules&quot; ] } 然后配置webpack： const path = require(&#39;path&#39;); const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;); const distFolder = &quot;./dist&quot;; module.exports = { mode: &#39;development&#39;, entry: { bundle2:&#39;./src/main.ts&#39;, // 项目主入口 bundle1:&#39;./src/a/b.ts&#39;, // 另一个入口 }, plugins: [ new CleanWebpackPlugin() ], devtool: &#39;source-map&#39;, module: { rules: [ { test: /\.ts$/, use: &#39;ts-loader&#39;, exclude: /node_modules/ } ] }, optimization: { // 配置splitChunks插件，拆分公共的代码块出来 splitChunks: { chunks: &#39;all&#39;, minSize: 300000, // 拆出来的代码块最小约300kb maxSize: 3000000 // 拆出来的代码块最大约3MB } }, resolve: { extensions: [ &quot;.ts&quot; ] }, output: { filename: &#39;[name].js&#39;, path: path.resolve(__dirname, distFolder) } }; 在工程目录执行webpack打包后，就可以在dist文件夹下看到拆分后的bundle了。将其引入index.js中即可运行查看效果，推荐在bin目录使用live-server快速搭建http服务器查看效果。 webpack拆分出来的模块可以异步加载，可以打乱顺序引入index.js中运行，这也是微信小游戏分包的关键。 加快编译速度 目前工程体量里，typescript源文件有1000多个，执行一次编译需要耗时50多秒。编译时间之久，导致很难实现编写代码-浏览器查看效果-修改代码-浏览器自动刷新查看效果这样理想的工作流了。不过可以通过增量编译来加快编译速度，尽可能实现理想的工作流。关于增量编译可以有三种实现。 tsc -w 在Laya2.0版本以前，项目并不会用import，export去管理模块关系，每个js文件都是全局执行，顺序引入，所以可以使用tsc -w -p . --outDir bin/js命令开启typescript增量编译输出js文件，然后用脚本处理index.js依照依赖关系顺序引入执行。使用-w选项开启增量编译后，每修改一个typescript文件就会在毫秒内编译成js。浏览器刷新后就能立刻看到效果。这是最符合理想情况的开发环境了，但是考虑到现有的项目都是模块化编写，写法不同于全局变量的方式，不同模块间都有import与export引用关系。使用tsc编译出来的js文件并不能顺序执行，这也是需要打包的原因。所以最后也没有使用这种方案。 想要获取源码文件的依赖关系顺序，可以使用dependency-tree工具。 想要浏览器监测到文件变化自动刷新，推荐使用webpack-dev-server或者是live-server工具，使用webpack打包或者自行修改一些js代码时，比起耗费编译的大量时间用Laya的运行调试来看效果，不如使用本地工具快速跑一个http服务器来测试。 watchify 第二种方法是继续使用browserify打包，同时使用watchify工具。可以参考gulp官网使用watchify进行增量编译。这需要修改编译脚本.laya/compile.js，安装两个npm包: npm i watchify gulp-util -g # 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去 cd LayaAirIDE_2.0.2\resources\app npm link watchify gulp-util 然后修改Laya工程根目录.laya中的compile.js编译脚本，以下提供compile.js添加或修改的部分用于参考: //添加引用watchify let watchify = require(ideModuleDir + &quot;watchify&quot;); let gutil = require(ideModuleDir + &quot;gulp-util&quot;); let b = watchify(browserify({ basedir: workSpaceDir, //是否开启调试，开启后会生成jsmap，方便调试ts源码，但会影响编译速度 debug: true, entries: [&#39;src/Main.ts&#39;], cache: {}, packageCache: {} }).plugin(tsify));//使用tsify插件编译ts function bundleOnWatch() { console.time(&quot;增量编译耗时&quot;); console.log(&quot;[&quot; + Date().toLocaleString() + &quot;]&quot;, &quot;检测到文件更改，开始增量编译...&quot;) b.bundle() //使用source把输出文件命名为bundle.js .pipe(source(&#39;bundle.js&#39;)) //把bundle.js复制到bin/js目录 .pipe(gulp.dest(workSpaceDir + &quot;/bin/js&quot;) .on(&#39;end&#39;, function() { console.log(&quot;[&quot; + Date().toLocaleString() + &quot;]&quot;, &quot;编译完成!&quot;); console.timeEnd(&quot;增量编译耗时&quot;); }) ); } //使用browserify，转换ts到js，并输出到bin/js目录 gulp.task(&quot;compile&quot;, prevTasks, function () { /** * ...省略 * */ return b .bundle() //使用source把输出文件命名为bundle.js .pipe(source(&#39;bundle.js&#39;)) // 把bundle.js复制到bin/js目录 .pipe(gulp.dest(workSpaceDir + &quot;/bin/js&quot;)); }); b.on(&quot;update&quot;, bundleOnWatch); // 每次监测到typeScript文件改变时执行打包 b.on(&quot;log&quot;, gutil.log); // 将日志打印到控制台 实测效果第一次编译和正常编译一样，需要50s，但是增量编译缩短至25s，打包速度提升了50%，如果不需要调试文件即debug: false，增量编译缩短至19s。再使用热重载的本地http服务器，勉强可以实现相对理想的工作流。 webpack –watch webpack4本身的打包速度就比Laya使用的browserify快，同样的项目体量，不生成sourcemap符号文件，browserify需要42s，webpack打包只需要37秒。并且使用webpack --watch开启增量编译模式后，第一次以后的打包时间缩短到18秒，再配置webpack-dev-server实现自动reload，这样的工作流也算是比较理想了。 编译browserify打包时拆分出独立sourcemap文件 如果继续使用browserify，在工程体量变大后还会遇到一个问题就是browserify打包生成的是inline-sourcemap，内嵌到bundle.js文件中。如果不做改动，现在编译出一个bundle可以达到30MB，其中base64编码后的sourcemap内容占21MB，先不考虑发布是否压缩的问题，连内网浏览时去下载执行js都需要耗很长的时间，游戏此间一直为白屏。为此可以使用exorcist抽离出sourcemap为独立文件。需要安装exorcist包: npm i exorcist -g # 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去 cd LayaAirIDE_2.0.2\resources\app npm link exorcist 然后修改Laya工程根目录.laya中的compile.js编译脚本，以下提供compile.js添加或修改的部分用于参考: // 提取分离sourcemap let exorcist = require(ideModuleDir + &quot;exorcist&quot;); // 使用browserify，转换ts到js，并输出到bin/js目录 gulp.task(&quot;compile&quot;, prevTasks, function () { /** * ... * */ return browserify({ basedir: workSpaceDir, // 是否开启调试，开启后会生成jsmap，方便调试ts源码，但会影响编译速度 debug: true, entries: [&#39;src/Main.ts&#39;], cache: {}, packageCache: {} }) // 使用tsify插件编译ts .plugin(tsify) .bundle() // 分离sourcemap .pipe(exorcist(workSpaceDir + &quot;/bin/js/bundle.js.map&quot;)) // 使用source把输出文件命名为bundle.js .pipe(source(&#39;bundle.js&#39;)) // 把bundle.js复制到bin/js目录 .pipe(gulp.dest(workSpaceDir + &quot;/bin/js&quot;)); }); *被分离后的bundle与sourcemap文件* 发布时生成sourcemap *laya发布界面* 发布时Laya提供压缩混淆js的选项，其使用gulp-uglify进行压缩，却不生成sourcemap符号文件，给开发者日后解析外网收集的报错带来了不少困难。为此需要使用gulp-sourcemaps，在uglify压缩过程生成sourcemap文件，并且最好还能与上一步browserify打包分离出来的sourcemap文件合并成一个map文件，可以直接从js混淆后代码映射到typescript源码。为此需要npm安装gulp-sourcemaps: npm i gulp-sourcemaps -g # 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去 cd LayaAirIDE_2.0.2\resources\app npm link gulp-sourcemaps 然后修改Laya工程根目录.laya中的publish.js发布脚本，以下提供publish.js添加或修改的部分用于参考: // 引入gulp-sourcemaps生成sourcemap const sourcemaps = require(ideModuleDir + &#39;gulp-sourcemaps&#39;); /** * ... * */ // 压缩js gulp.task(&quot;compressJs&quot;, [&quot;compressJson&quot;], function () { if (config.compressJs) { return gulp.src(config.compressJsFilter) .pipe(sourcemaps.init({loadMaps:true, largeFile:true})) .pipe(uglify()) .on(&#39;error&#39;, function (err) { console.warn(err.toString()); }) .pipe(sourcemaps.write(&quot;sourcemaps&quot;, {addComment:false})) .pipe(gulp.dest(releaseDir)); } }); /** * ... * */ gulp.task(&quot;publish&quot;, [&quot;version2&quot;], function () { /** * ... * */ // 删除编译打包过程中生成的符号文件 let tmpSourcemapFile = `${releaseDir}/js/bundle.js.map`; if (fs.existsSync(tmpSourcemapFile)) { fs.unlinkSync(tmpSourcemapFile); } console.log(&quot;All tasks completed!&quot;); }); 外网收集的报错堆栈如何解析请参考我的另一篇文章sourcemapping-JavaScript混淆堆栈解析映射工具 关于Linux下命令行工具的讨论 最终我们使用Linux机器执行发布编译，使用的是Laya官方提供的layaair2-cmd这个npm工具，用于命令行编译与发布，实际上也是执行的gulp脚本。但是linux上没有Laya IDE，使用的是机器全局的node环境。所以可以全局安装以上依赖的npm包，手动修改layaair2-cmd工具中的编译发布脚本即可实现以上的特性。 官方提供的命令行工具layaair2-cmd经常还未开发测试完成便发布新版本，从1.3.0以后的版本开始，到目前最新发布的1.4.5都没法正常跑编译与发布，建议保留1.2.0版本，不要轻易升级。并且命令行工具版本与Laya引擎版本有对应关系，也不建议轻易升级Laya引擎版本。像这样关键内容的版本发布如此随意，可以看出Laya内部并没有做很好的流程管理和版本控制。希望还是能把流程把控好，虽然可能效率低一些，但是正式和规范更能够赢得开发者的信任。多学习crbug.com管理和修复Chrome的流程，一个庞大且优秀的项目，只有流程化规范化才能走的更远。 参考 使用watchify加速browserify编译 - Gulp watchify - npm exorcist - npm gulp-sourcemaps - npm live-server - npm" />
<meta property="og:description" content="Laya IDE编译与发布的一些问题 随着游戏开发的推进，越来越多的功能和内容被添加，IDE的编译与发布也越来越慢，逐渐暴露了一些流程问题。 bundle文件过大需要拆分。假设把sourcemap的内容独立出去，bundle也有9.4MB之大，uglify压缩后也有4MB多。日后稍微更新一点内容，这个庞大的文件就要用户去重新下载。倘若频繁更新发布，网络请求对服务器造成的负担不说，对用户而言加载速度则是很大问题。 编译速度太慢。稍微改动一点点内容便要花1分钟去编译与查看效果。 browserify打包生成内嵌sourcemap导致bundle膨胀。我们使用2.0的IDE版本，在什么也不修改的情况下，bundle体积已经膨胀到30MB。其中21MB都是browserify打包生成的符号文件sourcemap的内容，被base64编码后添加到bundle的最后一行。 Laya压缩混淆js不生成符号文件。发布时勾选Laya IDE中的压缩混淆js选项，js被混淆，却不会生成映射到typescript源码的符号文件。这对发布后收集错误堆栈时的解析有很大影响。 Laya IDE的编译与发布实际上是在IDE安装目录的node环境下执行工程目录下.laya文件夹中的gulp脚本。所以基于以上问题，我对Laya IDE的编译发布脚本做了一些改动。 拆分bundle 首先解决bundle过大的问题。browserify工具没有提供很好的解决方案，但是我们可以很轻松的用webpack对其进行模块拆分。二者都是将typescript进行模块打包，但是webpack很友好的提供了splitChunks的插件，简单配置一下我们就能将bundle拆分若干份符合我们大小要求的文件。这也是我们微信小游戏分包使用的策略。 首先我们全局安装拆分需要的npm工具。由于我们使用typescript编写项目，所以还需要安装typescript编译需要的一些包。 npm i typescript ts-loader clean-webpack-plugin webpack webpack-cli -g npm link ts-loader clean-webpack-plugin 其中，在工程根路径下只需要链接全局安装的ts-loader clean-webpack-plugin两个包，修改tsconfig.json： { &quot;compilerOptions&quot;: { &quot;module&quot;: &quot;commonjs&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [ &quot;es6&quot;, &quot;dom&quot; ], &quot;noEmitHelpers&quot;: false, //需要生成一些helper方法，否则会报__extend undefined &quot;sourceMap&quot;: false }, &quot;exclude&quot;: [ &quot;node_modules&quot; ] } 然后配置webpack： const path = require(&#39;path&#39;); const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;); const distFolder = &quot;./dist&quot;; module.exports = { mode: &#39;development&#39;, entry: { bundle2:&#39;./src/main.ts&#39;, // 项目主入口 bundle1:&#39;./src/a/b.ts&#39;, // 另一个入口 }, plugins: [ new CleanWebpackPlugin() ], devtool: &#39;source-map&#39;, module: { rules: [ { test: /\.ts$/, use: &#39;ts-loader&#39;, exclude: /node_modules/ } ] }, optimization: { // 配置splitChunks插件，拆分公共的代码块出来 splitChunks: { chunks: &#39;all&#39;, minSize: 300000, // 拆出来的代码块最小约300kb maxSize: 3000000 // 拆出来的代码块最大约3MB } }, resolve: { extensions: [ &quot;.ts&quot; ] }, output: { filename: &#39;[name].js&#39;, path: path.resolve(__dirname, distFolder) } }; 在工程目录执行webpack打包后，就可以在dist文件夹下看到拆分后的bundle了。将其引入index.js中即可运行查看效果，推荐在bin目录使用live-server快速搭建http服务器查看效果。 webpack拆分出来的模块可以异步加载，可以打乱顺序引入index.js中运行，这也是微信小游戏分包的关键。 加快编译速度 目前工程体量里，typescript源文件有1000多个，执行一次编译需要耗时50多秒。编译时间之久，导致很难实现编写代码-浏览器查看效果-修改代码-浏览器自动刷新查看效果这样理想的工作流了。不过可以通过增量编译来加快编译速度，尽可能实现理想的工作流。关于增量编译可以有三种实现。 tsc -w 在Laya2.0版本以前，项目并不会用import，export去管理模块关系，每个js文件都是全局执行，顺序引入，所以可以使用tsc -w -p . --outDir bin/js命令开启typescript增量编译输出js文件，然后用脚本处理index.js依照依赖关系顺序引入执行。使用-w选项开启增量编译后，每修改一个typescript文件就会在毫秒内编译成js。浏览器刷新后就能立刻看到效果。这是最符合理想情况的开发环境了，但是考虑到现有的项目都是模块化编写，写法不同于全局变量的方式，不同模块间都有import与export引用关系。使用tsc编译出来的js文件并不能顺序执行，这也是需要打包的原因。所以最后也没有使用这种方案。 想要获取源码文件的依赖关系顺序，可以使用dependency-tree工具。 想要浏览器监测到文件变化自动刷新，推荐使用webpack-dev-server或者是live-server工具，使用webpack打包或者自行修改一些js代码时，比起耗费编译的大量时间用Laya的运行调试来看效果，不如使用本地工具快速跑一个http服务器来测试。 watchify 第二种方法是继续使用browserify打包，同时使用watchify工具。可以参考gulp官网使用watchify进行增量编译。这需要修改编译脚本.laya/compile.js，安装两个npm包: npm i watchify gulp-util -g # 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去 cd LayaAirIDE_2.0.2\resources\app npm link watchify gulp-util 然后修改Laya工程根目录.laya中的compile.js编译脚本，以下提供compile.js添加或修改的部分用于参考: //添加引用watchify let watchify = require(ideModuleDir + &quot;watchify&quot;); let gutil = require(ideModuleDir + &quot;gulp-util&quot;); let b = watchify(browserify({ basedir: workSpaceDir, //是否开启调试，开启后会生成jsmap，方便调试ts源码，但会影响编译速度 debug: true, entries: [&#39;src/Main.ts&#39;], cache: {}, packageCache: {} }).plugin(tsify));//使用tsify插件编译ts function bundleOnWatch() { console.time(&quot;增量编译耗时&quot;); console.log(&quot;[&quot; + Date().toLocaleString() + &quot;]&quot;, &quot;检测到文件更改，开始增量编译...&quot;) b.bundle() //使用source把输出文件命名为bundle.js .pipe(source(&#39;bundle.js&#39;)) //把bundle.js复制到bin/js目录 .pipe(gulp.dest(workSpaceDir + &quot;/bin/js&quot;) .on(&#39;end&#39;, function() { console.log(&quot;[&quot; + Date().toLocaleString() + &quot;]&quot;, &quot;编译完成!&quot;); console.timeEnd(&quot;增量编译耗时&quot;); }) ); } //使用browserify，转换ts到js，并输出到bin/js目录 gulp.task(&quot;compile&quot;, prevTasks, function () { /** * ...省略 * */ return b .bundle() //使用source把输出文件命名为bundle.js .pipe(source(&#39;bundle.js&#39;)) // 把bundle.js复制到bin/js目录 .pipe(gulp.dest(workSpaceDir + &quot;/bin/js&quot;)); }); b.on(&quot;update&quot;, bundleOnWatch); // 每次监测到typeScript文件改变时执行打包 b.on(&quot;log&quot;, gutil.log); // 将日志打印到控制台 实测效果第一次编译和正常编译一样，需要50s，但是增量编译缩短至25s，打包速度提升了50%，如果不需要调试文件即debug: false，增量编译缩短至19s。再使用热重载的本地http服务器，勉强可以实现相对理想的工作流。 webpack –watch webpack4本身的打包速度就比Laya使用的browserify快，同样的项目体量，不生成sourcemap符号文件，browserify需要42s，webpack打包只需要37秒。并且使用webpack --watch开启增量编译模式后，第一次以后的打包时间缩短到18秒，再配置webpack-dev-server实现自动reload，这样的工作流也算是比较理想了。 编译browserify打包时拆分出独立sourcemap文件 如果继续使用browserify，在工程体量变大后还会遇到一个问题就是browserify打包生成的是inline-sourcemap，内嵌到bundle.js文件中。如果不做改动，现在编译出一个bundle可以达到30MB，其中base64编码后的sourcemap内容占21MB，先不考虑发布是否压缩的问题，连内网浏览时去下载执行js都需要耗很长的时间，游戏此间一直为白屏。为此可以使用exorcist抽离出sourcemap为独立文件。需要安装exorcist包: npm i exorcist -g # 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去 cd LayaAirIDE_2.0.2\resources\app npm link exorcist 然后修改Laya工程根目录.laya中的compile.js编译脚本，以下提供compile.js添加或修改的部分用于参考: // 提取分离sourcemap let exorcist = require(ideModuleDir + &quot;exorcist&quot;); // 使用browserify，转换ts到js，并输出到bin/js目录 gulp.task(&quot;compile&quot;, prevTasks, function () { /** * ... * */ return browserify({ basedir: workSpaceDir, // 是否开启调试，开启后会生成jsmap，方便调试ts源码，但会影响编译速度 debug: true, entries: [&#39;src/Main.ts&#39;], cache: {}, packageCache: {} }) // 使用tsify插件编译ts .plugin(tsify) .bundle() // 分离sourcemap .pipe(exorcist(workSpaceDir + &quot;/bin/js/bundle.js.map&quot;)) // 使用source把输出文件命名为bundle.js .pipe(source(&#39;bundle.js&#39;)) // 把bundle.js复制到bin/js目录 .pipe(gulp.dest(workSpaceDir + &quot;/bin/js&quot;)); }); *被分离后的bundle与sourcemap文件* 发布时生成sourcemap *laya发布界面* 发布时Laya提供压缩混淆js的选项，其使用gulp-uglify进行压缩，却不生成sourcemap符号文件，给开发者日后解析外网收集的报错带来了不少困难。为此需要使用gulp-sourcemaps，在uglify压缩过程生成sourcemap文件，并且最好还能与上一步browserify打包分离出来的sourcemap文件合并成一个map文件，可以直接从js混淆后代码映射到typescript源码。为此需要npm安装gulp-sourcemaps: npm i gulp-sourcemaps -g # 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去 cd LayaAirIDE_2.0.2\resources\app npm link gulp-sourcemaps 然后修改Laya工程根目录.laya中的publish.js发布脚本，以下提供publish.js添加或修改的部分用于参考: // 引入gulp-sourcemaps生成sourcemap const sourcemaps = require(ideModuleDir + &#39;gulp-sourcemaps&#39;); /** * ... * */ // 压缩js gulp.task(&quot;compressJs&quot;, [&quot;compressJson&quot;], function () { if (config.compressJs) { return gulp.src(config.compressJsFilter) .pipe(sourcemaps.init({loadMaps:true, largeFile:true})) .pipe(uglify()) .on(&#39;error&#39;, function (err) { console.warn(err.toString()); }) .pipe(sourcemaps.write(&quot;sourcemaps&quot;, {addComment:false})) .pipe(gulp.dest(releaseDir)); } }); /** * ... * */ gulp.task(&quot;publish&quot;, [&quot;version2&quot;], function () { /** * ... * */ // 删除编译打包过程中生成的符号文件 let tmpSourcemapFile = `${releaseDir}/js/bundle.js.map`; if (fs.existsSync(tmpSourcemapFile)) { fs.unlinkSync(tmpSourcemapFile); } console.log(&quot;All tasks completed!&quot;); }); 外网收集的报错堆栈如何解析请参考我的另一篇文章sourcemapping-JavaScript混淆堆栈解析映射工具 关于Linux下命令行工具的讨论 最终我们使用Linux机器执行发布编译，使用的是Laya官方提供的layaair2-cmd这个npm工具，用于命令行编译与发布，实际上也是执行的gulp脚本。但是linux上没有Laya IDE，使用的是机器全局的node环境。所以可以全局安装以上依赖的npm包，手动修改layaair2-cmd工具中的编译发布脚本即可实现以上的特性。 官方提供的命令行工具layaair2-cmd经常还未开发测试完成便发布新版本，从1.3.0以后的版本开始，到目前最新发布的1.4.5都没法正常跑编译与发布，建议保留1.2.0版本，不要轻易升级。并且命令行工具版本与Laya引擎版本有对应关系，也不建议轻易升级Laya引擎版本。像这样关键内容的版本发布如此随意，可以看出Laya内部并没有做很好的流程管理和版本控制。希望还是能把流程把控好，虽然可能效率低一些，但是正式和规范更能够赢得开发者的信任。多学习crbug.com管理和修复Chrome的流程，一个庞大且优秀的项目，只有流程化规范化才能走的更远。 参考 使用watchify加速browserify编译 - Gulp watchify - npm exorcist - npm gulp-sourcemaps - npm live-server - npm" />
<link rel="canonical" href="http://localhost:4000/2019/11/01/Laya%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83%E4%BC%98%E5%8C%96.html" />
<meta property="og:url" content="http://localhost:4000/2019/11/01/Laya%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83%E4%BC%98%E5%8C%96.html" />
<meta property="og:site_name" content="Tingsven’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-11-01T00:00:00+08:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Laya编译发布优化","dateModified":"2019-11-01T00:00:00+08:00","datePublished":"2019-11-01T00:00:00+08:00","url":"http://localhost:4000/2019/11/01/Laya%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83%E4%BC%98%E5%8C%96.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/11/01/Laya%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83%E4%BC%98%E5%8C%96.html"},"author":{"@type":"Person","name":"周子博"},"description":"Laya IDE编译与发布的一些问题 随着游戏开发的推进，越来越多的功能和内容被添加，IDE的编译与发布也越来越慢，逐渐暴露了一些流程问题。 bundle文件过大需要拆分。假设把sourcemap的内容独立出去，bundle也有9.4MB之大，uglify压缩后也有4MB多。日后稍微更新一点内容，这个庞大的文件就要用户去重新下载。倘若频繁更新发布，网络请求对服务器造成的负担不说，对用户而言加载速度则是很大问题。 编译速度太慢。稍微改动一点点内容便要花1分钟去编译与查看效果。 browserify打包生成内嵌sourcemap导致bundle膨胀。我们使用2.0的IDE版本，在什么也不修改的情况下，bundle体积已经膨胀到30MB。其中21MB都是browserify打包生成的符号文件sourcemap的内容，被base64编码后添加到bundle的最后一行。 Laya压缩混淆js不生成符号文件。发布时勾选Laya IDE中的压缩混淆js选项，js被混淆，却不会生成映射到typescript源码的符号文件。这对发布后收集错误堆栈时的解析有很大影响。 Laya IDE的编译与发布实际上是在IDE安装目录的node环境下执行工程目录下.laya文件夹中的gulp脚本。所以基于以上问题，我对Laya IDE的编译发布脚本做了一些改动。 拆分bundle 首先解决bundle过大的问题。browserify工具没有提供很好的解决方案，但是我们可以很轻松的用webpack对其进行模块拆分。二者都是将typescript进行模块打包，但是webpack很友好的提供了splitChunks的插件，简单配置一下我们就能将bundle拆分若干份符合我们大小要求的文件。这也是我们微信小游戏分包使用的策略。 首先我们全局安装拆分需要的npm工具。由于我们使用typescript编写项目，所以还需要安装typescript编译需要的一些包。 npm i typescript ts-loader clean-webpack-plugin webpack webpack-cli -g npm link ts-loader clean-webpack-plugin 其中，在工程根路径下只需要链接全局安装的ts-loader clean-webpack-plugin两个包，修改tsconfig.json： { &quot;compilerOptions&quot;: { &quot;module&quot;: &quot;commonjs&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [ &quot;es6&quot;, &quot;dom&quot; ], &quot;noEmitHelpers&quot;: false, //需要生成一些helper方法，否则会报__extend undefined &quot;sourceMap&quot;: false }, &quot;exclude&quot;: [ &quot;node_modules&quot; ] } 然后配置webpack： const path = require(&#39;path&#39;); const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;); const distFolder = &quot;./dist&quot;; module.exports = { mode: &#39;development&#39;, entry: { bundle2:&#39;./src/main.ts&#39;, // 项目主入口 bundle1:&#39;./src/a/b.ts&#39;, // 另一个入口 }, plugins: [ new CleanWebpackPlugin() ], devtool: &#39;source-map&#39;, module: { rules: [ { test: /\\.ts$/, use: &#39;ts-loader&#39;, exclude: /node_modules/ } ] }, optimization: { // 配置splitChunks插件，拆分公共的代码块出来 splitChunks: { chunks: &#39;all&#39;, minSize: 300000, // 拆出来的代码块最小约300kb maxSize: 3000000 // 拆出来的代码块最大约3MB } }, resolve: { extensions: [ &quot;.ts&quot; ] }, output: { filename: &#39;[name].js&#39;, path: path.resolve(__dirname, distFolder) } }; 在工程目录执行webpack打包后，就可以在dist文件夹下看到拆分后的bundle了。将其引入index.js中即可运行查看效果，推荐在bin目录使用live-server快速搭建http服务器查看效果。 webpack拆分出来的模块可以异步加载，可以打乱顺序引入index.js中运行，这也是微信小游戏分包的关键。 加快编译速度 目前工程体量里，typescript源文件有1000多个，执行一次编译需要耗时50多秒。编译时间之久，导致很难实现编写代码-浏览器查看效果-修改代码-浏览器自动刷新查看效果这样理想的工作流了。不过可以通过增量编译来加快编译速度，尽可能实现理想的工作流。关于增量编译可以有三种实现。 tsc -w 在Laya2.0版本以前，项目并不会用import，export去管理模块关系，每个js文件都是全局执行，顺序引入，所以可以使用tsc -w -p . --outDir bin/js命令开启typescript增量编译输出js文件，然后用脚本处理index.js依照依赖关系顺序引入执行。使用-w选项开启增量编译后，每修改一个typescript文件就会在毫秒内编译成js。浏览器刷新后就能立刻看到效果。这是最符合理想情况的开发环境了，但是考虑到现有的项目都是模块化编写，写法不同于全局变量的方式，不同模块间都有import与export引用关系。使用tsc编译出来的js文件并不能顺序执行，这也是需要打包的原因。所以最后也没有使用这种方案。 想要获取源码文件的依赖关系顺序，可以使用dependency-tree工具。 想要浏览器监测到文件变化自动刷新，推荐使用webpack-dev-server或者是live-server工具，使用webpack打包或者自行修改一些js代码时，比起耗费编译的大量时间用Laya的运行调试来看效果，不如使用本地工具快速跑一个http服务器来测试。 watchify 第二种方法是继续使用browserify打包，同时使用watchify工具。可以参考gulp官网使用watchify进行增量编译。这需要修改编译脚本.laya/compile.js，安装两个npm包: npm i watchify gulp-util -g # 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去 cd LayaAirIDE_2.0.2\\resources\\app npm link watchify gulp-util 然后修改Laya工程根目录.laya中的compile.js编译脚本，以下提供compile.js添加或修改的部分用于参考: //添加引用watchify let watchify = require(ideModuleDir + &quot;watchify&quot;); let gutil = require(ideModuleDir + &quot;gulp-util&quot;); let b = watchify(browserify({ basedir: workSpaceDir, //是否开启调试，开启后会生成jsmap，方便调试ts源码，但会影响编译速度 debug: true, entries: [&#39;src/Main.ts&#39;], cache: {}, packageCache: {} }).plugin(tsify));//使用tsify插件编译ts function bundleOnWatch() { console.time(&quot;增量编译耗时&quot;); console.log(&quot;[&quot; + Date().toLocaleString() + &quot;]&quot;, &quot;检测到文件更改，开始增量编译...&quot;) b.bundle() //使用source把输出文件命名为bundle.js .pipe(source(&#39;bundle.js&#39;)) //把bundle.js复制到bin/js目录 .pipe(gulp.dest(workSpaceDir + &quot;/bin/js&quot;) .on(&#39;end&#39;, function() { console.log(&quot;[&quot; + Date().toLocaleString() + &quot;]&quot;, &quot;编译完成!&quot;); console.timeEnd(&quot;增量编译耗时&quot;); }) ); } //使用browserify，转换ts到js，并输出到bin/js目录 gulp.task(&quot;compile&quot;, prevTasks, function () { /** * ...省略 * */ return b .bundle() //使用source把输出文件命名为bundle.js .pipe(source(&#39;bundle.js&#39;)) // 把bundle.js复制到bin/js目录 .pipe(gulp.dest(workSpaceDir + &quot;/bin/js&quot;)); }); b.on(&quot;update&quot;, bundleOnWatch); // 每次监测到typeScript文件改变时执行打包 b.on(&quot;log&quot;, gutil.log); // 将日志打印到控制台 实测效果第一次编译和正常编译一样，需要50s，但是增量编译缩短至25s，打包速度提升了50%，如果不需要调试文件即debug: false，增量编译缩短至19s。再使用热重载的本地http服务器，勉强可以实现相对理想的工作流。 webpack –watch webpack4本身的打包速度就比Laya使用的browserify快，同样的项目体量，不生成sourcemap符号文件，browserify需要42s，webpack打包只需要37秒。并且使用webpack --watch开启增量编译模式后，第一次以后的打包时间缩短到18秒，再配置webpack-dev-server实现自动reload，这样的工作流也算是比较理想了。 编译browserify打包时拆分出独立sourcemap文件 如果继续使用browserify，在工程体量变大后还会遇到一个问题就是browserify打包生成的是inline-sourcemap，内嵌到bundle.js文件中。如果不做改动，现在编译出一个bundle可以达到30MB，其中base64编码后的sourcemap内容占21MB，先不考虑发布是否压缩的问题，连内网浏览时去下载执行js都需要耗很长的时间，游戏此间一直为白屏。为此可以使用exorcist抽离出sourcemap为独立文件。需要安装exorcist包: npm i exorcist -g # 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去 cd LayaAirIDE_2.0.2\\resources\\app npm link exorcist 然后修改Laya工程根目录.laya中的compile.js编译脚本，以下提供compile.js添加或修改的部分用于参考: // 提取分离sourcemap let exorcist = require(ideModuleDir + &quot;exorcist&quot;); // 使用browserify，转换ts到js，并输出到bin/js目录 gulp.task(&quot;compile&quot;, prevTasks, function () { /** * ... * */ return browserify({ basedir: workSpaceDir, // 是否开启调试，开启后会生成jsmap，方便调试ts源码，但会影响编译速度 debug: true, entries: [&#39;src/Main.ts&#39;], cache: {}, packageCache: {} }) // 使用tsify插件编译ts .plugin(tsify) .bundle() // 分离sourcemap .pipe(exorcist(workSpaceDir + &quot;/bin/js/bundle.js.map&quot;)) // 使用source把输出文件命名为bundle.js .pipe(source(&#39;bundle.js&#39;)) // 把bundle.js复制到bin/js目录 .pipe(gulp.dest(workSpaceDir + &quot;/bin/js&quot;)); }); *被分离后的bundle与sourcemap文件* 发布时生成sourcemap *laya发布界面* 发布时Laya提供压缩混淆js的选项，其使用gulp-uglify进行压缩，却不生成sourcemap符号文件，给开发者日后解析外网收集的报错带来了不少困难。为此需要使用gulp-sourcemaps，在uglify压缩过程生成sourcemap文件，并且最好还能与上一步browserify打包分离出来的sourcemap文件合并成一个map文件，可以直接从js混淆后代码映射到typescript源码。为此需要npm安装gulp-sourcemaps: npm i gulp-sourcemaps -g # 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去 cd LayaAirIDE_2.0.2\\resources\\app npm link gulp-sourcemaps 然后修改Laya工程根目录.laya中的publish.js发布脚本，以下提供publish.js添加或修改的部分用于参考: // 引入gulp-sourcemaps生成sourcemap const sourcemaps = require(ideModuleDir + &#39;gulp-sourcemaps&#39;); /** * ... * */ // 压缩js gulp.task(&quot;compressJs&quot;, [&quot;compressJson&quot;], function () { if (config.compressJs) { return gulp.src(config.compressJsFilter) .pipe(sourcemaps.init({loadMaps:true, largeFile:true})) .pipe(uglify()) .on(&#39;error&#39;, function (err) { console.warn(err.toString()); }) .pipe(sourcemaps.write(&quot;sourcemaps&quot;, {addComment:false})) .pipe(gulp.dest(releaseDir)); } }); /** * ... * */ gulp.task(&quot;publish&quot;, [&quot;version2&quot;], function () { /** * ... * */ // 删除编译打包过程中生成的符号文件 let tmpSourcemapFile = `${releaseDir}/js/bundle.js.map`; if (fs.existsSync(tmpSourcemapFile)) { fs.unlinkSync(tmpSourcemapFile); } console.log(&quot;All tasks completed!&quot;); }); 外网收集的报错堆栈如何解析请参考我的另一篇文章sourcemapping-JavaScript混淆堆栈解析映射工具 关于Linux下命令行工具的讨论 最终我们使用Linux机器执行发布编译，使用的是Laya官方提供的layaair2-cmd这个npm工具，用于命令行编译与发布，实际上也是执行的gulp脚本。但是linux上没有Laya IDE，使用的是机器全局的node环境。所以可以全局安装以上依赖的npm包，手动修改layaair2-cmd工具中的编译发布脚本即可实现以上的特性。 官方提供的命令行工具layaair2-cmd经常还未开发测试完成便发布新版本，从1.3.0以后的版本开始，到目前最新发布的1.4.5都没法正常跑编译与发布，建议保留1.2.0版本，不要轻易升级。并且命令行工具版本与Laya引擎版本有对应关系，也不建议轻易升级Laya引擎版本。像这样关键内容的版本发布如此随意，可以看出Laya内部并没有做很好的流程管理和版本控制。希望还是能把流程把控好，虽然可能效率低一些，但是正式和规范更能够赢得开发者的信任。多学习crbug.com管理和修复Chrome的流程，一个庞大且优秀的项目，只有流程化规范化才能走的更远。 参考 使用watchify加速browserify编译 - Gulp watchify - npm exorcist - npm gulp-sourcemaps - npm live-server - npm","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="keywords"  content="H5, Laya">
    <link rel="stylesheet" href="//cdn.staticfile.org/normalize/6.0.0/normalize.min.css">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_roc50gemkxpw4s4i.css">
    <link rel="stylesheet" href="/assets/css/github-markdown.css">
    <link rel="stylesheet" href="/assets/css/prism.css">
    <link rel="stylesheet" href="/assets/css/share.min.css">
    <link rel="stylesheet" href="/assets/css/app.min.css">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/assets/css/zoom.css">
    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
    <script src="/assets/js/transition.js"></script>
    <script src="/assets/js/zoom.js"></script>
	
	<!--
Author: Ray-Eldath
refer to:
 - http://docs.mathjax.org/en/latest/options/index.html
-->

	<script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
		jax: ["input/TeX", "output/HTML-CSS"],
		tex2jax: {
			inlineMath: [ ["$", "$"] ],
			displayMath: [ ["$$", "$$"] ],
			skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
		},
		"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
      });
    </script>

	
    <!--
Author: Ray-Eldath
-->
<style>
    .markdown-body .anchor{
        float: left;
        margin-top: -8px;
        margin-left: -20px;
        padding-right: 4px;
        line-height: 1;
        opacity: 0;
    }
    
    .markdown-body .anchor .anchor-icon{
        font-size: 15px
    }
</style>
<script>
    $(document).ready(function() {
        let nodes = document.querySelector(".markdown-body").querySelectorAll("h1,h2,h3")
        for(let node of nodes) {
            var anchor = document.createElement("a")
            var anchorIcon = document.createElement("i")
            anchorIcon.setAttribute("class", "fa fa-anchor fa-lg anchor-icon")
            anchorIcon.setAttribute("aria-hidden", true)
            anchor.setAttribute("class", "anchor")
            anchor.setAttribute("href", "#" + node.getAttribute("id"))
            
            anchor.onmouseover = function() {
                this.style.opacity = "0.4"
            }
            
            anchor.onmouseout = function() {
                this.style.opacity = "0"
            }
            
            anchor.appendChild(anchorIcon)
            node.appendChild(anchor)
        }
    })
</script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146060169-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-146060169-1');
</script>
</head>


<body>
  <!--[if lt IE 10]>
<div class="alert-danger" role="alert">你的浏览器实在太太太旧了，放学别走，升级完浏览器再说！<a target="_blank" class="alert-link" href="http://browsehappy.com">立即升级</a></div>
<![endif]-->
  <input id="nm-switch" type="hidden" value="true"> <header class="g-header">
    <div class="g-logo">
      <a href="/"></a>
    </div>
    <i id="menu-toggle" class="iconfont icon-menu"></i>
    <nav class="g-nav">
        <ul>
            
            <li><a href="/">home</a></li>
            
            <li><a href="/tags.html">tags</a></li>
            
        </ul>
    </nav>
</header>


  <header
    class="g-banner post-header post-pattern-glamorous bgcolor-default "
    data-theme="default"
  >
    <div class="post-wrapper">
      <div class="post-tags">
        
          
            <a href="http://localhost:4000/tags#H5" class="post-tag">H5</a>
          
            <a href="http://localhost:4000/tags#Laya" class="post-tag">Laya</a>
          
        
      </div>
      <h1>Laya编译发布优化</h1>
      <div class="post-meta">
        <span class="post-meta-item"><i class="iconfont icon-author"></i>周子博</span>
        <time class="post-meta-item" datetime="19-11-01"><i class="iconfont icon-date"></i>01 Nov 2019</time>
        <i class="iconfont icon-search"></i> <span id="/2019/11/01/Laya%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83%E4%BC%98%E5%8C%96.html" class="post-meta-item leancloud_visitors" data-flag-title="Laya编译发布优化">-</span> 次阅读
      </div>
    </div>
    
    <div class="filter"></div>
      <div class="post-cover" style="background: url('https://i.loli.net/2019/11/01/YbJWUTpzCKRDhmP.jpg') center no-repeat; background-size: cover;"></div>
    
  </header>

  <div class="post-content visible">
    
    <h2 class="post-subtitle">讨论bundle分离，编译速度优化，sourcemap生成与Linux命令行工具</h2>
    

    <article class="markdown-body">
      <h2 id="laya-ide编译与发布的一些问题">Laya IDE编译与发布的一些问题</h2>

<p>随着游戏开发的推进，越来越多的功能和内容被添加，IDE的编译与发布也越来越慢，逐渐暴露了一些流程问题。</p>

<ol>
  <li>bundle文件过大需要拆分。假设把sourcemap的内容独立出去，bundle也有9.4MB之大，uglify压缩后也有4MB多。日后稍微更新一点内容，这个庞大的文件就要用户去重新下载。倘若频繁更新发布，网络请求对服务器造成的负担不说，对用户而言加载速度则是很大问题。</li>
  <li>编译速度太慢。稍微改动一点点内容便要花1分钟去编译与查看效果。</li>
  <li>browserify打包生成内嵌sourcemap导致bundle膨胀。我们使用2.0的IDE版本，在什么也不修改的情况下，bundle体积已经膨胀到30MB。其中21MB都是browserify打包生成的符号文件sourcemap的内容，被base64编码后添加到bundle的最后一行。</li>
  <li>Laya压缩混淆js不生成符号文件。发布时勾选Laya IDE中的压缩混淆js选项，js被混淆，却不会生成映射到typescript源码的符号文件。这对发布后收集错误堆栈时的解析有很大影响。</li>
</ol>

<p>Laya IDE的编译与发布实际上是在IDE安装目录的node环境下执行工程目录下.laya文件夹中的gulp脚本。所以基于以上问题，我对Laya IDE的编译发布脚本做了一些改动。</p>

<p><img src="https://i.loli.net/2019/11/01/zYWEKolCXImRky7.png" alt="编译脚本" data-action="zoom" /></p>

<h2 id="拆分bundle">拆分bundle</h2>

<p>首先解决bundle过大的问题。browserify工具没有提供很好的解决方案，但是我们可以很轻松的用webpack对其进行模块拆分。二者都是将typescript进行模块打包，但是webpack很友好的提供了splitChunks的插件，简单配置一下我们就能将bundle拆分若干份符合我们大小要求的文件。这也是我们微信小游戏分包使用的策略。</p>

<p>首先我们全局安装拆分需要的npm工具。由于我们使用typescript编写项目，所以还需要安装typescript编译需要的一些包。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm i typescript  ts-loader clean-webpack-plugin webpack webpack-cli <span class="nt">-g</span>
npm <span class="nb">link </span>ts-loader clean-webpack-plugin
</code></pre></div></div>

<p>其中，在工程根路径下只需要链接全局安装的<code class="highlighter-rouge">ts-loader</code> <code class="highlighter-rouge">clean-webpack-plugin</code>两个包，修改tsconfig.json：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="dl">"</span><span class="s2">compilerOptions</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">module</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">commonjs</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">target</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">es5</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">lib</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
      <span class="dl">"</span><span class="s2">es6</span><span class="dl">"</span><span class="p">,</span>
      <span class="dl">"</span><span class="s2">dom</span><span class="dl">"</span>
    <span class="p">],</span>
    <span class="dl">"</span><span class="s2">noEmitHelpers</span><span class="dl">"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>  <span class="c1">//需要生成一些helper方法，否则会报__extend undefined</span>
    <span class="dl">"</span><span class="s2">sourceMap</span><span class="dl">"</span><span class="p">:</span> <span class="kc">false</span>
  <span class="p">},</span>
  <span class="dl">"</span><span class="s2">exclude</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
    <span class="dl">"</span><span class="s2">node_modules</span><span class="dl">"</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后配置webpack：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">CleanWebpackPlugin</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">clean-webpack-plugin</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">distFolder</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">./dist</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">mode</span><span class="p">:</span> <span class="dl">'</span><span class="s1">development</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">entry</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">bundle2</span><span class="p">:</span><span class="dl">'</span><span class="s1">./src/main.ts</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 项目主入口</span>
    <span class="na">bundle1</span><span class="p">:</span><span class="dl">'</span><span class="s1">./src/a/b.ts</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 另一个入口</span>
  <span class="p">},</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span>
    <span class="k">new</span> <span class="nx">CleanWebpackPlugin</span><span class="p">()</span>
  <span class="p">],</span>
  <span class="na">devtool</span><span class="p">:</span> <span class="dl">'</span><span class="s1">source-map</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.</span><span class="sr">ts$/</span><span class="p">,</span>
        <span class="na">use</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ts-loader</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">exclude</span><span class="p">:</span> <span class="sr">/node_modules/</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">},</span>
  <span class="na">optimization</span><span class="p">:</span> <span class="p">{</span> <span class="c1">// 配置splitChunks插件，拆分公共的代码块出来</span>
    <span class="na">splitChunks</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">chunks</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">minSize</span><span class="p">:</span> <span class="mi">300000</span><span class="p">,</span> <span class="c1">// 拆出来的代码块最小约300kb</span>
      <span class="na">maxSize</span><span class="p">:</span> <span class="mi">3000000</span> <span class="c1">// 拆出来的代码块最大约3MB</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">extensions</span><span class="p">:</span> <span class="p">[</span> <span class="dl">"</span><span class="s2">.ts</span><span class="dl">"</span> <span class="p">]</span>
  <span class="p">},</span>
  <span class="na">output</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">filename</span><span class="p">:</span> <span class="dl">'</span><span class="s1">[name].js</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">path</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="nx">distFolder</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在工程目录执行webpack打包后，就可以在dist文件夹下看到拆分后的bundle了。将其引入index.js中即可运行查看效果，推荐在bin目录使用<a href="https://www.npmjs.com/package/live-server">live-server</a>快速搭建http服务器查看效果。</p>

<blockquote>
  <p>webpack拆分出来的模块可以异步加载，可以打乱顺序引入index.js中运行，这也是微信小游戏分包的关键。</p>
</blockquote>

<h2 id="加快编译速度">加快编译速度</h2>

<p>目前工程体量里，typescript源文件有1000多个，执行一次编译需要耗时50多秒。编译时间之久，导致很难实现编写代码-浏览器查看效果-修改代码-浏览器自动刷新查看效果这样理想的工作流了。不过可以通过增量编译来加快编译速度，尽可能实现理想的工作流。关于增量编译可以有三种实现。</p>

<h3 id="tsc--w">tsc -w</h3>

<p>在Laya2.0版本以前，项目并不会用import，export去管理模块关系，每个js文件都是全局执行，顺序引入，所以可以使用<code class="highlighter-rouge">tsc -w -p . --outDir bin/js</code>命令开启typescript增量编译输出js文件，然后用脚本处理index.js依照依赖关系顺序引入执行。使用<code class="highlighter-rouge">-w</code>选项开启增量编译后，每修改一个typescript文件就会在毫秒内编译成js。浏览器刷新后就能立刻看到效果。这是最符合理想情况的开发环境了，但是考虑到现有的项目都是模块化编写，写法不同于全局变量的方式，不同模块间都有import与export引用关系。使用<code class="highlighter-rouge">tsc</code>编译出来的js文件并不能顺序执行，这也是需要打包的原因。所以最后也没有使用这种方案。</p>

<blockquote>
  <p>想要获取源码文件的依赖关系顺序，可以使用<a href="https://github.com/dependents/node-dependency-tree">dependency-tree</a>工具。<br />
想要浏览器监测到文件变化自动刷新，推荐使用<a href="https://www.npmjs.com/package/webpack-dev-server">webpack-dev-server</a>或者是<a href="https://www.npmjs.com/package/live-server">live-server</a>工具，使用webpack打包或者自行修改一些js代码时，比起耗费编译的大量时间用Laya的运行调试来看效果，不如使用本地工具快速跑一个http服务器来测试。</p>
</blockquote>

<h3 id="watchify">watchify</h3>

<p>第二种方法是继续使用browserify打包，同时使用watchify工具。可以参考<a href="https://v3.gulpjs.com.cn/docs/recipes/fast-browserify-builds-with-watchify/">gulp官网</a>使用watchify进行增量编译。这需要修改编译脚本.laya/compile.js，安装两个npm包:</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm i watchify gulp-util -g

<span class="c1"># 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去</span>
<span class="nb">cd </span>LayaAirIDE_2.0.2\resources\app
npm <span class="nb">link </span>watchify gulp-util
</code></pre></div></div>

<p>然后修改Laya工程根目录.laya中的compile.js编译脚本，以下提供compile.js<strong><em>添加或修改</em></strong>的部分用于参考:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//添加引用watchify</span>
<span class="kd">let</span> <span class="nx">watchify</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="nx">ideModuleDir</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">watchify</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">gutil</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="nx">ideModuleDir</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">gulp-util</span><span class="dl">"</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">watchify</span><span class="p">(</span><span class="nx">browserify</span><span class="p">({</span>
  <span class="na">basedir</span><span class="p">:</span> <span class="nx">workSpaceDir</span><span class="p">,</span>
  <span class="c1">//是否开启调试，开启后会生成jsmap，方便调试ts源码，但会影响编译速度</span>
  <span class="na">debug</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">entries</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">src/Main.ts</span><span class="dl">'</span><span class="p">],</span>
  <span class="na">cache</span><span class="p">:</span> <span class="p">{},</span>
  <span class="na">packageCache</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}).</span><span class="nx">plugin</span><span class="p">(</span><span class="nx">tsify</span><span class="p">));</span><span class="c1">//使用tsify插件编译ts</span>

<span class="kd">function</span> <span class="nx">bundleOnWatch</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">time</span><span class="p">(</span><span class="dl">"</span><span class="s2">增量编译耗时</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">[</span><span class="dl">"</span> <span class="o">+</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">toLocaleString</span><span class="p">()</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">]</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">检测到文件更改，开始增量编译...</span><span class="dl">"</span><span class="p">)</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">bundle</span><span class="p">()</span>
    <span class="c1">//使用source把输出文件命名为bundle.js</span>
    <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">source</span><span class="p">(</span><span class="dl">'</span><span class="s1">bundle.js</span><span class="dl">'</span><span class="p">))</span>
    <span class="c1">//把bundle.js复制到bin/js目录</span>
    <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="nx">workSpaceDir</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">/bin/js</span><span class="dl">"</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">end</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">[</span><span class="dl">"</span> <span class="o">+</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">toLocaleString</span><span class="p">()</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">]</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">编译完成!</span><span class="dl">"</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">timeEnd</span><span class="p">(</span><span class="dl">"</span><span class="s2">增量编译耗时</span><span class="dl">"</span><span class="p">);</span>
      <span class="p">})</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="c1">//使用browserify，转换ts到js，并输出到bin/js目录</span>
<span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="dl">"</span><span class="s2">compile</span><span class="dl">"</span><span class="p">,</span> <span class="nx">prevTasks</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="cm">/**
   * ...省略
   * */</span>

  <span class="k">return</span> <span class="nx">b</span>
    <span class="p">.</span><span class="nx">bundle</span><span class="p">()</span>
    <span class="c1">//使用source把输出文件命名为bundle.js</span>
    <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">source</span><span class="p">(</span><span class="dl">'</span><span class="s1">bundle.js</span><span class="dl">'</span><span class="p">))</span>
    <span class="c1">// 把bundle.js复制到bin/js目录</span>
    <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="nx">workSpaceDir</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">/bin/js</span><span class="dl">"</span><span class="p">));</span>
<span class="p">});</span>

<span class="nx">b</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">update</span><span class="dl">"</span><span class="p">,</span> <span class="nx">bundleOnWatch</span><span class="p">);</span> <span class="c1">// 每次监测到typeScript文件改变时执行打包</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">log</span><span class="dl">"</span><span class="p">,</span> <span class="nx">gutil</span><span class="p">.</span><span class="nx">log</span><span class="p">);</span> <span class="c1">// 将日志打印到控制台</span>
</code></pre></div></div>

<p>实测效果第一次编译和正常编译一样，需要50s，但是增量编译缩短至25s，打包速度提升了50%，如果不需要调试文件即<code class="highlighter-rouge">debug: false</code>，增量编译缩短至19s。再使用热重载的本地http服务器，勉强可以实现相对理想的工作流。</p>

<h3 id="webpack-watch">webpack –watch</h3>

<p>webpack4本身的打包速度就比Laya使用的browserify快，同样的项目体量，不生成sourcemap符号文件，browserify需要42s，webpack打包只需要37秒。并且使用<code class="highlighter-rouge">webpack --watch</code>开启增量编译模式后，第一次以后的打包时间缩短到18秒，再配置webpack-dev-server实现自动reload，这样的工作流也算是比较理想了。</p>

<h2 id="编译browserify打包时拆分出独立sourcemap文件">编译browserify打包时拆分出独立sourcemap文件</h2>

<p>如果继续使用browserify，在工程体量变大后还会遇到一个问题就是browserify打包生成的是inline-sourcemap，内嵌到bundle.js文件中。如果不做改动，现在编译出一个bundle可以达到30MB，其中base64编码后的sourcemap内容占21MB，先不考虑发布是否压缩的问题，连内网浏览时去下载执行js都需要耗很长的时间，游戏此间一直为白屏。为此可以使用<code class="highlighter-rouge">exorcist</code>抽离出sourcemap为独立文件。需要安装<code class="highlighter-rouge">exorcist</code>包:</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm i exorcist -g

<span class="c1"># 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去</span>
<span class="nb">cd </span>LayaAirIDE_2.0.2\resources\app
npm <span class="nb">link </span>exorcist
</code></pre></div></div>

<p>然后修改Laya工程根目录.laya中的compile.js编译脚本，以下提供compile.js<strong><em>添加或修改</em></strong>的部分用于参考:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 提取分离sourcemap</span>
<span class="kd">let</span> <span class="nx">exorcist</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="nx">ideModuleDir</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">exorcist</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// 使用browserify，转换ts到js，并输出到bin/js目录</span>
<span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="dl">"</span><span class="s2">compile</span><span class="dl">"</span><span class="p">,</span> <span class="nx">prevTasks</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="cm">/**
   * ...
   * */</span>
  <span class="k">return</span> <span class="nx">browserify</span><span class="p">({</span>
    <span class="na">basedir</span><span class="p">:</span> <span class="nx">workSpaceDir</span><span class="p">,</span>
    <span class="c1">// 是否开启调试，开启后会生成jsmap，方便调试ts源码，但会影响编译速度</span>
    <span class="na">debug</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">entries</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">src/Main.ts</span><span class="dl">'</span><span class="p">],</span>
    <span class="na">cache</span><span class="p">:</span> <span class="p">{},</span>
    <span class="na">packageCache</span><span class="p">:</span> <span class="p">{}</span>
  <span class="p">})</span>
    <span class="c1">// 使用tsify插件编译ts</span>
    <span class="p">.</span><span class="nx">plugin</span><span class="p">(</span><span class="nx">tsify</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">bundle</span><span class="p">()</span>
    <span class="c1">// 分离sourcemap</span>
    <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">exorcist</span><span class="p">(</span><span class="nx">workSpaceDir</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">/bin/js/bundle.js.map</span><span class="dl">"</span><span class="p">))</span>
    <span class="c1">// 使用source把输出文件命名为bundle.js</span>
    <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">source</span><span class="p">(</span><span class="dl">'</span><span class="s1">bundle.js</span><span class="dl">'</span><span class="p">))</span>
    <span class="c1">// 把bundle.js复制到bin/js目录</span>
    <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="nx">workSpaceDir</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">/bin/js</span><span class="dl">"</span><span class="p">));</span>
<span class="p">});</span>
</code></pre></div></div>

<p><img src="https://i.loli.net/2019/11/01/PsJnZLhbz8e4kGm.jpg" alt="分离sourcemap" data-action="zoom" /><br />
*<em>被分离后的bundle与sourcemap文件</em>*</p>

<h2 id="发布时生成sourcemap">发布时生成sourcemap</h2>

<p><img src="https://i.loli.net/2019/11/01/iBYR5TsDKc7jyzo.jpg" alt="laya发布" data-action="zoom" />
*<em>laya发布界面</em>*</p>

<p>发布时Laya提供压缩混淆js的选项，其使用<code class="highlighter-rouge">gulp-uglify</code>进行压缩，却不生成sourcemap符号文件，给开发者日后解析外网收集的报错带来了不少困难。为此需要使用<code class="highlighter-rouge">gulp-sourcemaps</code>，在uglify压缩过程生成sourcemap文件，并且最好还能与上一步<code class="highlighter-rouge">browserify</code>打包分离出来的sourcemap文件合并成一个map文件，可以直接从js混淆后代码映射到typescript源码。为此需要npm安装<code class="highlighter-rouge">gulp-sourcemaps</code>:</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm i gulp-sourcemaps -g

<span class="c1"># 链接Laya IDE所使用的Node环境中一些包到全局安装的包上去</span>
<span class="nb">cd </span>LayaAirIDE_2.0.2\resources\app
npm <span class="nb">link </span>gulp-sourcemaps
</code></pre></div></div>

<p>然后修改Laya工程根目录.laya中的publish.js发布脚本，以下提供publish.js<strong><em>添加或修改</em></strong>的部分用于参考:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 引入gulp-sourcemaps生成sourcemap</span>
<span class="kd">const</span> <span class="nx">sourcemaps</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="nx">ideModuleDir</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">gulp-sourcemaps</span><span class="dl">'</span><span class="p">);</span>
<span class="cm">/**
 * ...
 * */</span>
<span class="c1">// 压缩js</span>
<span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="dl">"</span><span class="s2">compressJs</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">compressJson</span><span class="dl">"</span><span class="p">],</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">compressJs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">compressJsFilter</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">sourcemaps</span><span class="p">.</span><span class="nx">init</span><span class="p">({</span><span class="na">loadMaps</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span> <span class="na">largeFile</span><span class="p">:</span><span class="kc">true</span><span class="p">}))</span>
      <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">uglify</span><span class="p">())</span>
      <span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
      <span class="p">})</span>
      <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">sourcemaps</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">"</span><span class="s2">sourcemaps</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span><span class="na">addComment</span><span class="p">:</span><span class="kc">false</span><span class="p">}))</span>
      <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="nx">releaseDir</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="cm">/**
 * ...
 * */</span>
<span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="dl">"</span><span class="s2">publish</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">version2</span><span class="dl">"</span><span class="p">],</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="cm">/**
     * ...
     * */</span>
    <span class="c1">// 删除编译打包过程中生成的符号文件</span>
    <span class="kd">let</span> <span class="nx">tmpSourcemapFile</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">releaseDir</span><span class="p">}</span><span class="s2">/js/bundle.js.map`</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">existsSync</span><span class="p">(</span><span class="nx">tmpSourcemapFile</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">fs</span><span class="p">.</span><span class="nx">unlinkSync</span><span class="p">(</span><span class="nx">tmpSourcemapFile</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">All tasks completed!</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<blockquote>
  <p>外网收集的报错堆栈如何解析请参考我的另一篇文章<a href="/2019/09/11/JavaScript混淆堆栈解析映射工具.html">sourcemapping-JavaScript混淆堆栈解析映射工具</a></p>
</blockquote>

<h2 id="关于linux下命令行工具的讨论">关于Linux下命令行工具的讨论</h2>

<p>最终我们使用Linux机器执行发布编译，使用的是Laya官方提供的<code class="highlighter-rouge">layaair2-cmd</code>这个npm工具，用于命令行编译与发布，实际上也是执行的gulp脚本。但是linux上没有Laya IDE，使用的是机器全局的node环境。所以可以全局安装以上依赖的npm包，手动修改<code class="highlighter-rouge">layaair2-cmd</code>工具中的编译发布脚本即可实现以上的特性。</p>

<blockquote>
  <p>官方提供的命令行工具<code class="highlighter-rouge">layaair2-cmd</code>经常还未开发测试完成便发布新版本，从1.3.0以后的版本开始，到目前最新发布的1.4.5都没法正常跑编译与发布，建议保留1.2.0版本，不要轻易升级。并且命令行工具版本与Laya引擎版本有对应关系，也不建议轻易升级Laya引擎版本。像这样关键内容的版本发布如此随意，可以看出Laya内部并没有做很好的流程管理和版本控制。希望还是能把流程把控好，虽然可能效率低一些，但是正式和规范更能够赢得开发者的信任。多学习crbug.com管理和修复Chrome的流程，一个庞大且优秀的项目，只有流程化规范化才能走的更远。</p>
</blockquote>

<h2 id="参考">参考</h2>

<ol>
  <li><a href="https://v3.gulpjs.com.cn/docs/recipes/fast-browserify-builds-with-watchify/">使用watchify加速browserify编译 - Gulp</a></li>
  <li><a href="https://www.npmjs.com/package/watchify">watchify - npm</a></li>
  <li><a href="https://www.npmjs.com/package/exorcist">exorcist - npm</a></li>
  <li><a href="https://www.npmjs.com/package/gulp-sourcemaps">gulp-sourcemaps - npm</a></li>
  <li><a href="https://www.npmjs.com/package/live-server">live-server - npm</a></li>
</ol>

    </article>

    
    <div class="social-share-wrapper">
      <div class="social-share"></div>
    </div>
    
  </div>

  <section class="author-detail">
    <section class="post-footer-item author-card">
      <div class="avatar">
        <img src="http://localhost:4000/assets/img/profile.jpg" alt="">
      </div>
      <div class="author-name" rel="author">周子博</div>
      <div class="bio">
        <p>爱Vera，爱生活，爱游戏</p>
      </div>
      
      <ul class="sns-links">
        
        <li>
          <a href="/contact.html" target="_blank">
                    <i class="iconfont icon-email"></i>
                </a>
        </li>
        
        <li>
          <a href="//weibo.com/swazz" target="_blank">
                    <i class="iconfont icon-weibo"></i>
                </a>
        </li>
        
        <li>
          <a href="//github.com/7ippo" target="_blank">
                    <i class="iconfont icon-github"></i>
                </a>
        </li>
        
      </ul>
      
    </section>
    <section class="post-footer-item read-next">
      
      <div class="read-next-item">
        <a href="/2020/01/18/Laya%E9%A1%B9%E7%9B%AE%E8%BD%BB%E6%9D%BE%E4%B8%8A%E7%BA%BF%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F.html" class="read-next-link"></a>
        <section>
          <span>Laya项目轻松上线微信小游戏</span>
          <p>Laya引擎为了H5游戏上线微信等小游戏平台的无缝对接做了许多工作，但是项目上线微信小游戏还是遇到了不少的问题。不...</p>
        </section>
        
        <div class="filter"></div>
        <img src="https://i.loli.net/2020/03/28/Cr8ZpQLzYP6nSDW.jpg" alt="">
        
     </div>
      

      
      <div class="read-next-item">
        <a href="/2019/09/11/JavaScript%E6%B7%B7%E6%B7%86%E5%A0%86%E6%A0%88%E8%A7%A3%E6%9E%90%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7.html" class="read-next-link"></a>
          <section>
            <span>js混淆堆栈本地解析映射工具</span>
            <p>为什么要写这个工具发布环境的产品都经过压缩混淆，并且没有attach sourcemap。因此前端收集到的错误堆栈...</p>
          </section>
          
          <div class="filter"></div>
          <img src="https://i.loli.net/2019/09/11/DwE4xOzsCRGyt9H.jpg" alt="">
          
      </div>
      
    </section>
    
    <section class="post-footer-item comment">
        <div id="disqus_thread"></div>
    </section>
    
  </section>

  <footer class="g-footer">
  <section>Tingsven's blog ©
  
  
    2017
    -
  
  2020
  </section>
  <section>Powered by <a href="//jekyllrb.com">Jekyll</a> | <a href="https://github.com/kaeyleo/jekyll-theme-H2O">Theme H2O</a></section>
</footer>

<!-- 同时兼容http与https -->
<script src="//cdn1.lncld.net/static/js/2.5.0/av-min.js"></script>
<script>
    AV.initialize("EYgyitdcYOMWLdS6JfHNHD43-gzGzoHsz", "3hmJaI6a8V7rhyspVOMsr2oR");
    // 自己创建的Class的名字
    var name='Counter';
    function createRecord(Counter){
      // 设置 ACL
      var acl = new AV.ACL();
      acl.setPublicReadAccess(true);
      acl.setPublicWriteAccess(true);
      // 获得span的所有元素
      var elements=document.getElementsByClassName('leancloud_visitors');
      // 一次创建多条记录
      var allcounter=[];
      for (var i = 0; i < elements.length ; i++) {
        // 若某span的内容不包括 '-' ，则不必创建记录
        if(elements[i].textContent.indexOf('-') == -1){
          continue;
        }
        var title = elements[i].getAttribute('data-flag-title');
        var url = elements[i].id;
        var newcounter = new Counter();
        newcounter.setACL(acl);
        newcounter.set("title", title);
        newcounter.set("url", url);
        newcounter.set("time", 1);
        allcounter.push(newcounter);
        // 顺便更新显示span为默认值1
        elements[i].textContent=1;
      }
      AV.Object.saveAll(allcounter).then(function (todo) {
        // 成功保存记录之后
        console.log('New Visit Record Success');
      }, function (error) {
        // 异常错误 
        console.error('New Visit Record Fail: ' + error.message);
      });
    }
    function showCount(Counter){
      var $visitors = $(".leancloud_visitors");
      if($visitors.length == 0) return;
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);
      query.equalTo('url', url);
      query.find().then(function (results) {
        // 当获取到的记录为0时置默认值
        if(results.length==0){
          createRecord(Counter);
          return;
        }
        // 将获取到的数据设置为text
        var item = results[0];
        var url = item.get('url');
        var time = item.get('time');
        var element = document.getElementById(url);
        element.textContent = time + 1;
        // 访问量+1
        item.increment('time');
        item.save().then(function (testObject) {
        });
      }, function (error) {
        console.log('save error:'+error.message);
      });
    }
    $(function() {
      var Counter = AV.Object.extend(name);
      showCount(Counter);
    });
</script>


  <script src="/assets/js/social-share.min.js"></script>
  <script>
    socialShare('.social-share', {
      sites: [
        
          'wechat'
          ,
          
        
          'weibo'
          ,
          
        
          'douban'
          ,
          
        
          'twitter'
          
        
      ],
      wechatQrcodeTitle: "分享到微信朋友圈",
      wechatQrcodeHelper: '<p>扫码后点击右上角</p><p>将本文分享至朋友圈</p>'
    });
  </script>

  
  <script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://tingsven.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  

  <script src="/assets/js/prism.js"></script>
  <script src="/assets/js/index.min.js"></script>
</body>

</html>
